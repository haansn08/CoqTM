\include{beamerhead}
\include{mypreamble}
%% My favourite color theme for beamer
\usecolortheme{orchid}
% \usepackage{verbatim}

%% Use "mathematical" versions of the type names
\renewcommand{\Type}{\mathbb{T}}
\renewcommand{\Nat}{\mathbb{N}}
\renewcommand{\Bool}{\mathbb{B}}
\renewcommand{\Option}{\mathcal{O}}
\renewcommand{\List}{\mathcal{L}}
\newcommand{\Pow}{\mathcal{P}}

\beamertemplatenavigationsymbolsempty%
% \setbeamertemplate{footline}[page number]
%% Show only current page number
\setbeamertemplate{footline}{\raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[20pt]{\scriptsize{\color{gray}\insertframenumber}}}}}

%% Display a list of references at the bottom
\newcommand\refs[1]{%
  \begin{textblock*}{8cm}(0.3cm,9.0cm)%
    \scriptsize {\color{gray}#1}
  \end{textblock*}
}


\title{Formalising multi-tape Turing machines in Coq}
\subtitle{First Bachelor Seminar Talk}
\author{Maximilian Wuttke}
\institute{Saarland University\\
  \bigskip
  \tiny
  Programming Systems Lab
}
\date{December 21, 2017\\
  \bigskip{}
  \bigskip{}
  {
    \tiny
    Advisor: Yannick Forster\\
    Supervisor: Prof.\ Dr.\ Gert Smolka%
  }
}


% Passt nicht gut
% \include{beamerlayout}

\begin{document}

\frame{\titlepage}

\begin{frame}{Motivation: Finish the reduction chain}
  \[\MS{L} \rightarrow m\MS{TM} \rightarrow \MS{TM} \rightarrow \MS{PCP}\]

  \begin{itemize}
    \pause\item Reduction of $\MS{TM} \rightarrow \MS{PCP}$ formalised in Coq%
    \footnote{\tiny Yannick Forster, Edith Heiter, Gert Smolka: Verification of PCP-Related Computational Reductions in Coq; 2017}
    \pause\item Computational theory of $L$ formalised in Coq%
    \footnote{\tiny Yannick Forster and Gert Smolka: Weak Call-by-Value Lambda Calculus as a Model of Computation in Coq; 2017}
    \pause\item Now we formalise multi-tape Turing machines%
    \pause\item Goal: build a multi-tape Turing machine that simulates $L$%
    \footnote{\tiny Yannick Forster, Fabian Kunze, Marc Roth: The strong invariance thesis for a lambda-calculus; LOLA 2017}%
\end{itemize}
\end{frame}

\begin{frame}{Introduction: Turing machines}
  Pros:
  \begin{itemize}
    \item are easy to understand / imagine;
    \item are the de-facto standard model of computation
  \end{itemize}
  \pause%
  Cons:
  \begin{itemize}
    \item not compositional;
    \item encoding data is tedious;
    \item formal reasoning is tedious;
    \item completely unstructured
  \end{itemize}
\end{frame}

\begin{frame}{Introduction: Related Work}
  \footnotesize
  \begin{thebibliography}{10}
    \beamertemplatearticlebibitems%
    \bibitem{}
    Xu, Jian and Zhang, Xingyuan and Urban, Christian
    \newblock{\em Mechanising Turing Machines and Computability Theory in Isabelle/HOL}%
    \newblock{ITP 2013}

    \bibitem{}
    Andrea Asperti and Wilmer Ricciotti
    \newblock{\em A formalization of multi-tape Turing machines}%
    \newblock{Theoretical Computer Science, 2015}

    \bibitem{}
    Alberto Ciaffaglione
    \newblock{\em Towards Turing computability via coinduction}%
    \newblock{Science of Computer Programming, 2016}
  \end{thebibliography}
\end{frame}


\begin{frame}{Definitions}
  Let $\Sigma$ be a finite type and $n:\Nat$.
  \begin{definition}[$n$-tape Turing machine over $\Sigma$]
    An $n$-tape Turing machine over $\Sigma$ is a record $\MS{mTM}~\Sigma~n$:
    \begin{itemize}
      \item $Q$ is the finite type of states;
      \item $\gamma \from Q \times \Option(\Sigma)^n \to Q \times (\Option(\Sigma) \times \MS{Move})^n$
        \\ (transition function);
      \item $s:Q$ (start state);
      \item $h \from Q \to \Bool$ (halting states)
    \end{itemize}
    Where $\MS{Move} := \setOf{L, R, N}$.
  \end{definition}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Tape]
    % XXX List
    A tape over $\Sigma$ is either:
    $ \niltape$, $\leftof{r}{R}$, $\midtape{R}{m}{L}$, or $\rightof{L}{l}$,\\
    Where $r,l : \Sigma$ and $R,L : \List(\Sigma)$.
    \pause%
    \begin{alignat*}{2}
      \MS{Tape} := ~ & \MS{niltape} \\
      | ~ & \MS{leftof}  ~ (r:\Sigma) ~ (R:\List(\Sigma)) \\
      | ~ & \MS{midtape} ~ (L:\List(\Sigma)) ~ (m:\Sigma) ~ (R:\List(\Sigma)) \\
      | ~ & \MS{rightof} ~ (l:\Sigma) ~ (L:\List(\Sigma)).
    \end{alignat*}
  \end{definition}
  \pause%
  \begin{definition}[Configuration]
    A configuration is a record $\MS{Conf}_M := \{\MS{state}:Q_M;~ \MS{tapes}:\Tape^n\}$.
  \end{definition}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Step function]
    With the functions
    \begin{alignat*}{2}
      % \MS{mv}      & \from \Move \to \Tape \to \Tape \\
      % \MS{wr}      & \from \Tape \to \Option~\Sigma \to \Tape \\
      \MS{wr\_mv}  & \from \Tape \to (\Option(\Sigma) \times \Move) \to \Tape \\
      \MS{current} & \from \Tape \to \Option(\Sigma)
    \end{alignat*}
    we the \textbf{step function} $\MS{step}_M \from \MS{Conf}_M \to \MS{Conf}_M$:
    \begin{alignat*}{2}
      \MS{step}_M &~(\MS{tapes}, q) &~:=~& \mlet{(q', \MS{actions}) := \gamma_M(q, \map~\MS{current}~\MS{tapes})}{ \\
                  &                 &~  ~& (q', \map_2~\MS{wr\_mv}~\MS{tapes}~\MS{actions})}
      \end{alignat*}
  \end{definition}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Execution]
    \begin{align*}
      \MS{loop}~k~f~h~s :=
      \begin{cases}
        \Some{s}                  & h(s) = \true \\
        \None                     & h(s) = \false \land k = 0 \\
        \MS{loop}~(k-1)~f~h~(f(s)) & h(s) = \false \land k > 0
      \end{cases}
    \end{align*}
    \pause%
    \begin{alignat*}{4}
      \MS{iconf}_M ~ t_{in}          &:= (\MS{tapes}, s_M) \\
      \MS{hconf}_M ~ (\MS{tapes}, q) &:= h_M(q) \\
      \MS{exec}_M  ~ t_{in}~k        &:= \MS{loop}~k~\MS{step}_M~\MS{hconf}~(\MS{initc}_M~t_{in})
    \end{alignat*}
    {
      \small
      $\MS{exec}_M \from \Tape^n \to \Nat \to \Option(\MS{Conf})$
    }
  \end{definition}

  \pause%
  We write $\mathbf{M(t_{in}) \triangleright^n c_{out}}$, if $\MS{exec}_M~t_{in}~n= \Some{c_{out}}$.
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Correctness of machines}
  \begin{definition}[Realisation, $M \VDash_f R$]
    Let $R \subseteq (\Tape^n) \times (F \times \Tape^n)$ and $f \from Q_M \to F$, for a finite $F$.\\
    \begin{multline*}
      \mathbf{M \VDash_f R} :=
      \forall (t_{in} : \Tape^n)~(n:\Nat)~(q_{out}:Q_M)~(t_{out} : \Tape^n). \\
      M(t_{in}) \triangleright^n (q_{out}, t_{out}) \rightarrow
      \left(t_{in}, \left(f(q_{out}), t_{out} \right) \right) \in R.
    \end{multline*}
    Then we say that $M$ \textbf{realises} $R$.
  \end{definition}
  \pause%
  For \textbf{partioned machines} $M : \setOf{M' : \MS{mTM}~\Sigma~n;~ f \from Q_{M'} \to F}$,\\
  we write $\mathbf{M \VDash R}$.
\end{frame}

\begin{frame}{Termination of machines}
  \begin{definition}[Termination, $M \downarrow T$]
    Let $T \subseteq (\Tape^n) \times \Nat$.
    \[
      \mathbf{M \downarrow T} :=
      \forall (t_{in},~n) \in T.~
      \exists c_{out},~M(t_{in}) \triangleright^n c_{out}
    \]
    We say that $M$ \textbf{terminates in} $T$.
  \end{definition}
\end{frame}

\begin{frame}{Relations}
  \footnotesize
  Let $R, S \subseteq X \times Y$; $T \subseteq Y \times Z$; $U \subseteq X \times X$; $V \subseteq X \times (F \times Y)$; and
  $\Phi \from F \to \Pow(X \times Y)$.
  \vspace{0.5cm}

  \begin{columns}
    \begin{column}{0.6\textwidth}
      Standard relation combinators:
      \begin{alignat*}{2}
        R \cap  S &:= \setMap{(x, y)}{(x, y) \in R \land (x,y) \in S} \\
        R \cup  S &:= \setMap{(x, y)}{(x, y) \in R \lor  (x,y) \in S} \\
        R \circ T &:= \setMap{(x, z)}{\exists y,~ (x,y) \in R \land (y,z) \in T} \\
        \MS{Id}_X &:= \setMap{(x, x)}{x : X}
      \end{alignat*}
      Reflexive transitive closure:
      \[\inferrule{ }{(x,x) \in U^*} \qquad \inferrule{(x, y) \in U \and (y,z) \in U^*}{(x, z) \in U^*}\]
      Big union:
      \[\bigcup_{a:F}\Phi(a) := \setMap{(x, y)}{\exists a, (x,y) \in (\Phi~a)}\]
    \end{column}
    \begin{column}{0.4\textwidth}
      Parametrise relations:
      \begin{alignat*}{2}
        \ignoreParam R &:= \setMap{(x, (a, y))}{a : F \land (x, y) \in R} \\
        \hideParam   R &:= \setMap{((x, a), y)}{a : F \land (x, y) \in R}
      \end{alignat*}
      Relational if:
      \begin{alignat*}{3}
        R \rif S :=  &\setMap{(x, (\true,  y))&&}{(x, y) \in R} \\
              \cup\, &\setMap{(x, (\false, y))&&}{(x, y) \in S}
      \end{alignat*}
      Restriction: {\tiny(for a fixed $a : F$)}
      \begin{alignat*}{3}
        V\at {a} &:= \setMap{(x,      z)}{(x,(a, z)) \in V} \\
        % V\att{a} &:= \setMap{(x, (a, z))}{(x,(a, z)) \in V} \\
      \end{alignat*}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Combinators}
  \begin{itemize}
    \item Implement programming primitives as operators on Turing machines:
    \begin{itemize}
      \item match
      \item sequential composition
      \item if then else
      \item do-while
    \end{itemize}
  \item Verify them using correctness relations
  \end{itemize}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Sequential composition and If Then Else}
  Let $M_1$ be parametrised over $F$ and $M_2$ over $F'$.
  \begin{corollary}[Correctness of sequential composition]
    If $M_1 \VDash R_1$ and $M_2 \VDash R_2$, then $(M_1 \mseq M_2) \VDash R_1 \circ \hideParam R_2$.
  \end{corollary}
  \bigskip
  \pause
  Let $M_1$ be parametrised over $\Bool$ and $M_2$ and $M_3$ over $F$.
  \begin{corollary}[Correctness of boolean if]
    If $M_1 \VDash R_1$ and $M_2 \VDash R_2$ and $M_3 \VDash R_3$, then
    $(\mif{M_1}{M_2}{M_3}) \VDash (R_1 \at \true) \circ R_2 \cup (R_1 \at \false) \circ R_3$.
  \end{corollary}
\end{frame}

\begin{frame}{Machine transformations}
  \textbf{Problem:}
  When combining machines, the numbers of tapes and the alphabet have to match!
  \pause%
  \bigskip

  \textbf{Solution:} Two operations on machines:
  \begin{itemize}
    \item $n$-Lift: add/rearange tapes
    \item $\Sigma$-Lift: translate symbols
  \end{itemize}
\end{frame}

\begin{frame}{$n$-Lift}
  Let $f \from \Fin_m \hookrightarrow \Fin_n$ be an injection between tape indexes.

  Let $M$ be an $m$-tape $F$-partitioned Turing machine parametrised over $\Sigma$,
  and $R$ be a $F$-parametrised relation.

  Define an $n$-tape Turing machine $\MS{Lift}_f~M$ and a relation $\MS{Lift}_f~R$.
  \begin{align*}
    \MS{Lift}_f~R := \setMap{(t_{in}, (a, t_{out})) &}{ \bigl(f^{-1}(t_{in}), (a, f^{-1}(t_{out})) \bigr) \in R } \cap \\
    \Uparrow \setMap{(t_{in}, t_{out}) &}{ \forall i \notin \MS{img}~f.~ t_{in}[i] = t_{out}[i] }
  \end{align*}
  {\footnotesize (Where $f^{-1} \from \Tape^m \to \Tapes^n$)}
  % (Tapes that are not in the image of $f$ do nothing, the other tapes simulate the corresponding tapes of $M$.)

  \begin{lemma}[Correctness of the $n$-Lift]
    \[
      M \VDash R \rightarrow (\MS{Lift}_f~M) \VDash (\MS{Lift}_f~R)
    \]
  \end{lemma}

\end{frame}

\begin{frame}{$\Sigma$-Lift}
  Let $f \from \Sigma \hookrightarrow \Tau$ be an injection between alphabets.

  Let $\mathbf{default} : \Sigma$.

  Let $M$ be an $m$-tape $F$-partitioned Turing machine parametrised over $\Sigma$,
  and $R$ be a $F$-parametrised relation.

  Define an $n$-tape Turing machine $\MS{Lift}_{f,\MS{default}}~M$ and a relation $\MS{Lift}_{f,\MS{default}}~R$.
  \begin{align*}
    \MS{lift}_{f,\MS{default}}~R := \setMap{(t_{in}, (a, t_{out}))}{ (f^{-1}_{\MS{default}} (t_{in}) , (a, f^{-1}_{\MS{default}} (t_{out}))) \in R}
  \end{align*}

  \begin{lemma}[Correctness of the $\Sigma$-Lift]
    \[
      M \VDash R \rightarrow (\MS{Lift}_{f, \MS{default}}~M) \VDash (\MS{Lift}_{f, \MS{default}}~R)
    \]
  \end{lemma}
\end{frame}

\begin{frame}{Encoding}
  \begin{definition}[Encodable types]
    A type $X$ is \emph{encodable} over $\Sigma$, if there exists a function $\MS{encode} \from X \to \List~\Sigma$, s.t.
    \begin{multline*}
      \forall (v_1~v_2:X)~(r_1~r_2: \List(\Sigma)). \\
      \MS{encode}(x) \app r_1 = \MS{encode}(v_2) \app r_2 \rightarrow
      v_1 = v_2 \land r_1 = r_2
    \end{multline*}
  \end{definition}
  \pause%
  \begin{definition}[Tape encodes value]
    We write $\Sigma^+$ instead of $\Sigma + \Bool$. \\
    For a $X$ encodable over $\Sigma$, a $\Sigma^+$-tape $t$ \textbf{encodes} a value $x:X$, if
    \[t = \midtape{(r_1 \app [\inr \true])}{(\inl y)}{(\map~\inl~ys \app \inr \false \cons r_2)}\]
    for $y \cons ys = \MS{encode}(x)$, and some $r_1, r_2 \in \List~\Sigma^+$.
  \end{definition}
\end{frame}

\begin{frame}{Calculate functions}
  \begin{definition}[Calculate function]
    A machine $M$ \emph{computes} a function $f \from X \to Y$ from $i < n$ to $j < n$, if $M \VDash \MS{FunRel}_{f,i,j}$ with
    %\small
    \begin{multline*}
      \MS{FunRel}_{f,i,j} := \\
      \ignoreParam \setMap{(t_{in}, t_{out})}{
      \forall x:X,~ \MS{encodes}(t_{in}[i], x) \rightarrow \MS{encodes}(t_{out}[j], f(x))}
    \end{multline*}
  \end{definition}
  % \pause%
  % \begin{lemma}[Finite functions]
  %   All functions with finite range and domain are computable in one step.
  % \end{lemma}
  \pause%
  Extendable to multiple tapes.
\end{frame}

\begin{frame}{Example: De Morgan machine}
  Assume $\MS{AND} : \MS{mTM}~\Bool^+~2$ that computes $andb \from \Bool \to \Bool \to \Bool$ from $0$ and $1$ to $1$.

  Assume $\MS{NOT} : \MS{mTM}~\Bool^+~1$ that computes $notb \from \Bool \to \Bool$.
  \[
    \MS{OR} := \MS{Lift}_{[0 \mapsto 0]}~\MS{NOT} \mseq \MS{Lift}_{[0 \mapsto 1]} \MS{NOT} \mseq \MS{AND} \mseq \MS{Lift}_{[0 \mapsto 1]}~\MS{NOT}
  \]
  \pause%
  \textbf{Fact:} \MS{OR} computes $\orb \from \Bool \to \Bool \to \Bool$ from $0$ and $1$ to $1$.

  \textbf{Proof:}
  Using the correctness lemmas about $\MS{Lift}$ and sequential composition we get a relation $R'$ that $M$ realises.
  Show $R' \subseteq \MS{FunRel}_{orb,i,j}$.
  This follows with the De Morgan law.
\end{frame}

\begin{frame}{Example: De Morgan machine 2}
  \textbf{Fact:}
  \[
    OR' := \MS{Lift}_{[\true \mapsto \false, \false \mapsto \true]}~\MS{AND}
  \]
  also computes $orb$ from $0$ and $1$ to $1$.

  \pause%
  \begin{table}
    \begin{tabular}{|cc|cc|c|c|c|}
      \hline
      $a$ & $\bar{a}$ & $b$ & $\bar{b}$ & $a\land b$ & $\bar{a}\land\bar{b}$ & $\overline{\bar{a}\land\bar{b}}=a\lor b$\tabularnewline
      \hline
      0 & 1 & 0 & 1 & 0 & 1 & 0\tabularnewline
      0 & 1 & 1 & 0 & 0 & 0 & 1\tabularnewline
      1 & 0 & 0 & 1 & 0 & 0 & 1\tabularnewline
      1 & 0 & 1 & 0 & 1 & 0 & 1\tabularnewline
      \hline
    \end{tabular}
  \end{table}
\end{frame}

\begin{frame}{Other results}
  \begin{itemize}
    \item Termination relations
    \item $\MS{match}$
    \item $\MS{while}$
    \item $\MS{mirror}$
    \item Basic machines (move, read, write, nop)
    \item \textbf{Fact:} All finite functions can be computed in 1 step.
  \end{itemize}
\end{frame}

\begin{frame}{Conclusion}
  What we have
  \begin{itemize}
    \item Formal definition of Turing machines and a framework of correctness predicates;
    \item Construction and verification of combinators and transformations;
    \item Formal definition of encoding and computation;
    \item Implementation of some basic and compound machines
  \end{itemize}

  Future work
  \begin{itemize}
    \item Verify compound machines with $\MS{while}$, e.g.\ the projection functions for tuples and lists;
    \item Build towards an interpreter for the weak CBV lambda calculus $L$ with time and space analysis;
    \item Build a Universal Turing machine
  \end{itemize}
\end{frame}

\appendix % appendix sections will not occur in the headline

%% Backup-Slides

\begin{frame}{Backup Slides}
  This Are The Backup Slides!
  \vfill
  Thank you!
\end{frame}

\begin{frame}{Related Work}
  \footnotesize
  \begin{thebibliography}{10}
    \beamertemplatearticlebibitems%
    \bibitem{}
    Xu, Jian and Zhang, Xingyuan and Urban, Christian
    \newblock{\em Mechanising Turing Machines and Computability Theory in Isabelle/HOL}%
    \newblock{ITP 2013}
    \bibitem{}
    Andrea Asperti and Wilmer Ricciotti
    \newblock{\em A formalization of multi-tape Turing machines}%
    \newblock{Theoretical Computer Science, 2015}
    \bibitem{}
    Alberto Ciaffaglione
    \newblock{\em Towards Turing computability via coinduction}%
    \newblock{Science of Computer Programming, 2016}
    \bibitem{}
    Yannick Forster and Gert Smolka
    \newblock{\em Weak Call-by-Value Lambda Calculus as a Model of Computation in Coq}%
    \newblock{ITP 2017}
    \bibitem{}
    Yannick Forster, Fabian Kunze, Marc Roth
    \newblock{\em The strong invariance thesis for a lambda-calculus}%
    \newblock{LOLA 2017}
    \bibitem{}
    Yannick Forster, Edith Heiter, Gert Smolka
    \newblock{\em Verification of PCP-Related Computational Reductions in Coq}%
    \newblock{(Pre-print)}
  \end{thebibliography}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{The idea}
  Given:
  \begin{itemize}
    \item Two finite types $F$ and $F'$,
    \item A machine $M$ and a partitioning function $p \from Q_M \to F$,
    \item For all $a:F$, a machine $M'_a$ with a partitioning function $p'ay \from Q_{M'_a} \to F'$
  \end{itemize}
  Do:
  \begin{enumerate}
    \item Execute a machine $M$.
    \item Depending on the state of termination $q_h$:
      \begin{itemize}
        \item Execute the machine $M'_{p(q_h)}$.
      \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Example for a match machine}
	\vspace{-1cm}
  \include{fig-match}
  \[
    p(h_1) = \true \qquad p(h_2) = \true \qquad p(h_3) = \false
  \]
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Definition}
  \footnotesize
  $$Q_{\MS{match}} := Q_M + \depPair{y:F}{Q_{ \left( M'_{y} \right) }}$$
  \begin{alignat*}{2}
    \gamma_{\MS{match}} & (\inl q, \MS{symbols}) &&:=
    \begin{cases}
      \gamma_{M}(q, \MS{symbols})                                & h_M(q) = \false \\
      \left( s_{\left(M'_{p(q)}\right)}, (\None, N)^n \right)  & h_M(q) = \true
    \end{cases} \\
    \gamma_{\MS{match}} & (\inr (a, q), \MS{symbols}) &&:= \gamma_{\left({M'_a}\right)}(q, \MS{symbols})
  \end{alignat*}
  \begin{alignat*}{3}
    h_{\MS{match}} &~ (\inl      q) &&:= \false \\
    h_{\MS{match}} &~ (\inr (a, q)) &&:= h_{\left( M'_a \right)}(q)
  \end{alignat*}
  \begin{alignat*}{3}
    p_{\MS{match}} &~ (\inl      q) &&:= \dots \\
    p_{\MS{match}} &~ (\inr (a, q)) &&:= p'_a(q)
  \end{alignat*}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Correctness}
  \begin{lemma}[Correctness of $\MS{match}$]
    If $M \VDash R$ and for each $a:F$, $M'_a \VDash R'_a$, then
    $$\MS{match} \VDash \bigcup_{y:F} \left( (R \at y) \circ R'_a \right)$$
  \end{lemma}
\end{frame}


\begin{frame}{Sequential composition and If Then Else}

  \begin{definition}[Sequential composition]
    $$M_1 \mseq M_2 := \mmatch~M_1~(\lam y M_2)$$
  \end{definition}

  \begin{definition}[Boolean if]
    $$ \mif{M_1}{M_2}{M_3} := \MS{match}~(M_1) \left(\lam b \begin{cases} M_2 & b = \true \\ M_3 & b = \false \end{cases} \right) $$
  \end{definition}

\end{frame}

\begin{frame}{While}
  \begin{columns}

    \begin{column}{0.6\textwidth}
      Idea:
      \begin{itemize}
        \item Let $M$ be parametrised over $\Bool \times F$.
        \item Repeat $M$ until terminates in a rejecting state
        \item Partition function returns the $F$ part
      \end{itemize}
    \end{column}
    \pause%
    \begin{column}{0.4\textwidth}
      Example:
      \begin{figure}
        \resizebox{3.5cm}{!}{%
          \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,bend angle=45]
            \begin{scope}
              % Machine M
              \node[state]          (M init)                                    {$q_0$};
              \node[state]          (M exit 1)  [right of=M init,yshift= 1.5cm] {$q_{h1}$};
              \node[state, double]  (M exit 2)  [right of=M init,yshift= 0.0cm] {$q_{h2}$};
              \node[state, double]  (M exit 3)  [right of=M init,yshift=-1.5cm] {$q_{h3}$};
              \path (M init)
              edge[dotted]          (M exit 1)
              edge[dotted]  (M exit 2)
              edge[dotted]  (M exit 3);
              \path (M init) ++(-1.0,0) edge (M init);
              \path (M exit 1) edge[bend right] node[anchor=south,yshift=0.2em] {$(\None, N)$} (M init);
            \end{scope}

            \begin{pgfonlayer}{background}
              \filldraw [line width=4mm,join=round,blue!10]
              (M   exit 1.north -| M   init.west) rectangle (M   exit 3.south -| M   exit 3.east);
            \end{pgfonlayer}
          \end{tikzpicture}
        }
      \end{figure}
      \footnotesize
      \vspace{-0.2cm}
      \begin{align*}
        \#1(p(q_{h1})) &= \true \\
        \#1(p(q_{h2})) &= \#1(p(q_{h3})) = \false
      \end{align*}
    \end{column}
  \end{columns}
  \pause%
  \begin{lemma}[Correctness of $\MS{while}$]
    If $M \VDash R$, then
    \[
      \MS{while} \VDash
      \left( \bigcup_{y:F} R\at{(\true, y)} \right)^* \circ
      \setMap{(t, (y, t'))}{(t, ((\false, y), t')) \in R}
    \]
  \end{lemma}
\end{frame}


\begin{frame}{Encoding functions}
  \footnotesize
  \begin{alignat*}{3}
    \MS{encode}&_{\Sigma + \Tau + \Bool}&(\inl x) &:= \inr \false \cons \map~(\inl \circ \inr)~\MS{encode}(x) \\
    \MS{encode}&_{\Sigma + \Tau + \Bool}&(\inl y) &:= \inr \true  \cons \map~(\inl \circ \inl)~\MS{encode}(y) \\
    \MS{encode}&_{\Sigma + \Bool}& (\nil)         &:= \inr \false \\
    \MS{encode}&_{\Sigma + \Bool}& (x :: xs)      &:= \inr \true \cons \map~\inl~\MS{encode}_{\Sigma}(x) \app \MS{encode}_{\Sigma + \Bool}(xs) \\
    \MS{encode}&_{\Sigma+\Tau}   &(x,y)           &:= \map~\inl~\MS{encode}_{\Sigma}(x) \app \map~\inr~\MS{encode}_{\Tau}(y) \\
    \MS{encode}&_{\Bool}         &(0)             &:= [\false] \\
    \MS{encode}&_{\Bool}         &(\MS S~n)       &:= \true \cons \MS{encode}_{\Bool}(n)
  \end{alignat*}
\end{frame}

\begin{frame}{$n$-lift}
  \begin{figure}
    \center%
    \begin{tikzpicture}
      \begin{scope}
        \node(a0)[yshift=-0 cm]  {$0$};
        \node(a1)[yshift=-1 cm]  {$1$};
        \node(a2)[yshift=-2 cm]  {$2$};
      \end{scope}
      \begin{scope}[xshift=4cm, yshift=0cm]
        \node(b0)[yshift=-0 cm] {$0$};
        \node(b1)[yshift=-1 cm] {$1$};
        \node(b2)[yshift=-2 cm] {$2$};
        \node(b3)[yshift=-3 cm] {$3$};
        \node(b4)[yshift=-4 cm] {$4$};
      \end{scope}
      \begin{scope}[xshift=5cm, yshift=-3cm]
        \node(none)             {$\None$};
      \end{scope}
      \path (a0) edge[<->] (b1);
      \path (a1) edge[<->] (b0);
      \path (a2) edge[<->] (b3);
      \path (b2) edge[-> ] (none);
      \path (b4) edge[-> ] (none);
    \end{tikzpicture}
    \caption{Tape retract encoded as the index-vector $[1, 0, 3]$.}
  \end{figure}
\end{frame}


\begin{frame}{$\Sigma$-lift}
  \begin{figure}
    \center%
    \begin{tikzpicture}
      \begin{scope}
        \node(alpha)[yshift=-0 cm] {$\alpha$};
        \node(beta) [yshift=-1 cm] {$\beta$};
        \node(gamma)[yshift=-2 cm] {$\gamma$};
      \end{scope}
      \begin{scope}[xshift=4cm, yshift=1cm]
        % Symbols of $\Tau$
        \node(a)[yshift=-0 cm] {$a$};
        \node(b)[yshift=-1 cm] {$b$};
        \node(c)[yshift=-2 cm] {$c$};
        \node(d)[yshift=-3 cm] {$d$};
        \node(e)[yshift=-4 cm] {$e$};
      \end{scope}
      \path (alpha) edge[<->] (a);
      \path (beta)  edge[<->] (b);
      \path (gamma) edge[<->] (d);
      \path (gamma) edge[<-, dotted] (c);
      \path (gamma) edge[<-, dotted] (e);
    \end{tikzpicture}
    \caption{Example alphabet retract; $\gamma$ is the default symbol in $\Sigma$.}
  \end{figure}
\end{frame}

\begin{frame}{Basic machines}
  Classes of $1$-tape machines for each basic action \\(together with partitioning functions):
  \begin{itemize}
    \item Move head in the direction $D$
    \item Write one symbol
    \item Read one symbol
    \item nop
    \pause%
    \item Write a list of symbols (defined per recursion over the string)
  \end{itemize}
\end{frame}

\begin{frame}{Coq code dimensions}
	% \tiny \verbatiminput{../wc.txt}
	\begin{table}
		\begin{tabular}{|l|r|r|}
			\hline
			& Lines Spec & Lines Proof\tabularnewline
			\hline
			Prelim & 235+ & 286+\tabularnewline
			Relations/Retracts & 475 & 269\tabularnewline
			Def. $n$TM & 215 & 85\tabularnewline
			$\Sigma$-Lift & 132 & 129\tabularnewline
			$n$-Lift & 153 & 195\tabularnewline
			Basic machines & 142 & 69\tabularnewline
			Encoding & 170 & 164\tabularnewline
			Computation & 241 & 289\tabularnewline
			Combinators & 158 & 354\tabularnewline
			Finite and $\Bool$ TM & 112 & 203\tabularnewline
			\hline
			$\Sigma$ & 2033 & 2042\tabularnewline
			\hline
		\end{tabular}
	\end{table}
\end{frame}

\end{document}

% vim: ts=2 sts=2 sw=2 expandtab textwidth=150
