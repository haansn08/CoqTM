\include{beamerhead}
\include{mypreamble}
%% My favourite color theme for beamer
\usecolortheme{orchid}
% \usepackage{verbatim}

%% Use "mathematical" versions of the type names
\renewcommand{\Type}{\mathbb{T}}
\renewcommand{\Nat}{\mathbb{N}}
\renewcommand{\Bool}{\mathbb{B}}
\renewcommand{\Option}{\mathcal{O}}

\beamertemplatenavigationsymbolsempty%
% \setbeamertemplate{footline}[page number]
%% Show only current page number
\setbeamertemplate{footline}{\raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[20pt]{\scriptsize{\color{gray}\insertframenumber}}}}}

%% Display a list of references at the bottom
\newcommand\refs[1]{%
  \begin{textblock*}{8cm}(0.3cm,9.0cm)%
    \scriptsize {\color{gray}#1}
  \end{textblock*}
}


\title{Formalising multi-tape Turing machines in Coq}
\subtitle{First Bachelor Seminar Talk}
\author{Maximilian Wuttke}
\institute{{\scshape Saarland University}}
\date{December 21, 2017\\
  \bigskip{}
  \bigskip{}
  {
    \tiny
    Advisor: Yannick Forster\\
    Supervisor: Prof.\ Dr.\ Gert Smolka%
  }
}


% Passt nicht gut
% \include{beamerlayout}

\begin{document}

\frame{\titlepage}

\begin{frame}{Motivation: Finish the reduction chain}
  \[\MS{L} \rightarrow n\MS{TM} \rightarrow \MS{TM} \rightarrow \MS{PCP}\]

  \begin{itemize}
    \pause\item $\MS{TM} \rightarrow \MS{PCP}$ formalised by Edith
    \pause\item $L$ has been formalised by Yannick
    \pause\item Now we formalize $n\MS{TM}$s
    \pause\item Goal: build a multi-tape Turing machine that reduces $L$-terms
  \end{itemize}
\end{frame}

\begin{frame}{Introduction: Turing machines}
  Pros:
  \begin{itemize}
    \item are easy to understand / imagine;
    \item are the de-facto standard model of computation
  \end{itemize}
  \pause%
  Cons:
  \begin{itemize}
    \item not compositional;
    \item encoding data is tedious;
    \item formal reasoning is tedious;
    \item completely unstructured
  \end{itemize}
\end{frame}

\begin{frame}{Introduction: Related Work}
  \footnotesize
  \begin{thebibliography}{10}
    \beamertemplatearticlebibitems%
    \bibitem{}
    Xu, Jian and Zhang, Xingyuan and Urban, Christian
    \newblock{\em Mechanising Turing Machines and Computability Theory in Isabelle/HOL}%
    \newblock{ITP 2013}

    \bibitem{}
    Andrea Asperti and Wilmer Ricciotti
    \newblock{\em A formalization of multi-tape Turing machines}%
    \newblock{Theoretical Computer Science, 2015}

    \bibitem{}
    Alberto Ciaffaglione
    \newblock{\em Towards Turing computability via coinduction}%
    \newblock{Science of Computer Programming, 2016}
  \end{thebibliography}
\end{frame}


\begin{frame}{Definitions}
  Let $\Sigma$ be a finite type and $n:\Nat$.
  \begin{definition}[$n$-tape Turing machine over $\Sigma$]
    An $n$-tape Turing machine over $\Sigma$ is a record tuple:
    \begin{itemize}
      \item $Q$ is the finite type of states;
      \item $\gamma \from Q \times \Option(\Sigma)^n \to Q \times (\Option(\Sigma) \times \MS{Move})^n$
        \\ (transition function);
      \item $s:Q$ (start state);
      \item $h \from Q \to \Bool$ (halting states)
    \end{itemize}
    Where $\MS{Move} := \setOf{L, R, N}$.
  \end{definition}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Tape]
    A tape over $\Sigma$ is either:
    $ \niltape$, $\leftof{r}{R}$, $\midtape{R}{m}{L}$, or $\rightof{L}{l}$,\\
    Where $r,l : \Sigma$ and $R,L : \List~\Sigma$.
    \pause%
    \begin{alignat*}{2}
      \MS{Tape}:\Type := \quad & \MS{niltape} \\
      | \quad & \MS{leftof}  ~ (r:\Sigma) ~ (R:\List~\Sigma) \\
      | \quad & \MS{midtape} ~ (L:\List~\Sigma) ~ (m:\Sigma) ~ (R:\List~\Sigma) \\
      | \quad & \MS{rightof} ~ (l:\Sigma) ~ (L:\List~\Sigma).
    \end{alignat*}
  \end{definition}
  \pause%
  \begin{definition}[Configuration]
    A configuration of a machine $M$ is a record tuple $\MS{Conf} := \{\MS{state}:Q_M\mseq \MS{tapes}:\Tape^n\}$.
  \end{definition}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Step function]
    With the functions
    \begin{alignat*}{2}
      % \MS{mv}      & \from \Move \to \Tape \to \Tape \\
      % \MS{wr}      & \from \Tape \to \Option~\Sigma \to \Tape \\
      \MS{wr\_mv}  & \from \Tape \to (\Option(\Sigma) \times \Move) \to \Tape \\
      \MS{current} & \from \Tape \to \Option(\Sigma)
    \end{alignat*}
    we define for a machine $M$ the \textbf{step function} $\MS{step} \from \MS{Conf} \to \MS{Conf}$:
    \begin{alignat*}{2}
      \MS{step}&~(\MS{tapes}, q) &~:=~& \mlet{(q', \MS{actions}) := \gamma_M(q, \map~\MS{current}~\MS{tapes})}{ \\
               &                 &~  ~& (q', \map_2~\MS{wr\_mv}~\MS{tapes}~\MS{actions})}
      \end{alignat*}
  \end{definition}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Execution]
    \begin{align*}
      \MS{loop}~n~f~h~s :=
      \begin{cases}
        \Some{s}              & h(s) = \true \\
        \None                 & h(s) = \false \land n = 0 \\
        \MS{loop}~(n-1)~f~h~(f s)  & h(s) = \false \land n > 0
      \end{cases}
    \end{align*}
    \pause%
    \begin{alignat*}{3}
      \MS{init\_conf}    &~\MS{tapes}      &&:= (\MS{tapes}, s_M) \\
      \MS{halting\_conf} &~(\MS{tapes}, q) &&:= h_M(q) \\
      \MS{loopM}         &~\MS{initc}~k    &&:= \MS{loop}~k~\MS{step}~\MS{halting\_conf}~\MS{initc} \\
      \MS{exec}          &~\MS{tapes}      &&:= \MS{loopM}~(\MS{init\_conf}~\MS{tapes})
    \end{alignat*}
    {
      \small
      %(Types:
      %$\MS{loopM} \from \MS{Conf} \to \Nat \to \Option(\MS{Conf})$ and
      $\MS{exec} \from \Tape^n \to \Nat \to \Option(\MS{Conf})$
    }
  \end{definition}

  \pause%
  We write $\mathbf{M(t_{in}) \triangleright^n c_{out}}$, if $\MS{exec}~t_{in}~n= \Some{c_{out}}$.
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Correctness of machines}
  \begin{definition}[Realisation, $M \VDash_p R$]
    Let $R \subseteq (\Tape^n) \times (F \times \Tape^n)$ and $f \from Q_M \to F$, for a finite $F$.\\
    Then $M$ \textbf{realises} $R$, if
    \begin{multline*}
      \forall t_{in},~n:\Nat,~c_{out}={q_{out}, t_{out}}, \\
      M(t_{in}) \triangleright^n c_{out} \Rightarrow \\
      \left(t_{in}, \left(f(q_{out}), t_{out} \right) \right) \in R
    \end{multline*}
    We write $\mathbf{M \VDash_f R}$.
  \end{definition}
  \pause%
  We often use dependent tuples of machines with partitioning functions:
  If $M : \depPair{M' : \MS{TM}}{Q_{M'} \to F}$, then we write $\mathbf{M \VDash R}$.
\end{frame}

\begin{frame}{Termination of machines}
  \begin{definition}[Termination, $M \downarrow T$]
    Let $T \subseteq (\Tape^n) \times \Nat$.\\
    Then $M$ \textbf{terminates in} $T$, if
    \[
      \forall (t_{in},~n) \in T,~\exists c_{out},~M(t_{in}) \Rightarrow^n c_{out}
    \]
    We write $\mathbf{M \downarrow T}$.
  \end{definition}
\end{frame}

\begin{frame}{Relations}
  \footnotesize
  Let $R, S \subseteq X \times Y$; $T \subseteq Y \times Z$; $U \subseteq X \times X$; and $\Phi \from F \to \Rel~X~Y$.
  \vspace{0.5cm}

  \begin{columns}
    \begin{column}{0.6\textwidth}
      We use standard relational definitions:
      \begin{alignat*}{2}
        R \cap  S &:= \setMap{(x, y)}{(x, y) \in R \land (x,y) \in S} \\
        R \cup  S &:= \setMap{(x, y)}{(x, y) \in R \lor  (x,y) \in S} \\
        R \circ T &:= \setMap{(x, z)}{\exists y,~ (x,y) \in R \land (y,z) \in T} \\
        \MS{Id}_X &:= \setMap{(x, x)}{x : X}
      \end{alignat*}
      Reflexive transitive closure:
      $$\inferrule{ }{(x,x) \in U^*} \qquad \inferrule{(x, y) \in U \and (y,z) \in U^*}{(x, z) \in U^*}$$
    \end{column}
    \begin{column}{0.4\textwidth}
      Parametrise relations: {\tiny(for $a \in F$)}
      \begin{alignat*}{2}
        \ignoreParam R &:= \setMap{(x, (a, y))}{(x, y) \in R} \\
        \hideParam   R &:= \setMap{((x, a), y)}{(x, y) \in R}
      \end{alignat*}
      Relational if:
      \begin{alignat*}{3}
        R_1 \rif R_2 :=  &\setMap{(x, (\true, y))&}{(x, y) \in R} \\
        \cup\, &\setMap{(x, (\false, y))&}{(x,y) \in S}
      \end{alignat*}
      Big union:
      $$\bigcup_{a:F}\Phi(y) := \setMap{(x, y)}{\exists a, (x,y) \in (\Phi~a)}$$
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Combinators}
  \begin{itemize}
    \item Implement programming primitives as operators on Turing machines:
    \begin{itemize}
      \item match
      \item Sequential composition
      \item if then else
      \item do-while
    \end{itemize}
  \item Verify them using correctness relations
  \end{itemize}
  \refs{[Asperti and Ricciotti]} % use this to show references on a slide
\end{frame}

\begin{frame}{Match}
  \framesubtitle{The idea}
  Given:
  \begin{itemize}
    \item Two finite types $F$ and $F'$,
    \item A machine $M$ and a partitioning function $p \from Q_M \to F$,
    \item For all $y:F$, a machine $M'_y$ with a partitioning function $p'_y \from Q_{M'_y} \to F'$
  \end{itemize}
  Do:
  \begin{enumerate}
    \item Execute a machine $M$.
    \item Depending on the state of termination $q_h$:
      \begin{itemize}
        \item Execute the machine $M'_{p(q_h)}$.
      \end{itemize}
  \end{enumerate}
\end{frame}


\begin{frame}{Match}
  \framesubtitle{Example for a match machine}
	\vspace{-1cm}
  \include{fig-match}
  \[
    p(h_1) = \true \qquad p(h_2) = \true \qquad p(h_3) = \false
  \]
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Definition}
  \footnotesize
  $$Q_{\MS{match}} := Q_M + \depPair{y:F}{Q_{ \left( M'_{y} \right) }}$$
  \begin{alignat*}{2}
    \gamma_{\MS{match}} & (\inl q, \MS{symbols}) &&:=
    \begin{cases}
      \gamma_{M}(q, \MS{symbols})                                & h_M(q) = \false \\
      \left( s_{\left(M'_{p(q)}\right)}, (\None, N)^n \right)  & h_M(q) = \true
    \end{cases} \\
    \gamma_{\MS{match}} & (\inr (y, q), \MS{symbols}) &&:= \gamma_{\left({M'_y}\right)}(q, \MS{symbols})
  \end{alignat*}
  \begin{alignat*}{3}
    h_{\MS{match}} &~ (\inl      q) &&:= \false \\
    h_{\MS{match}} &~ (\inr (y, q)) &&:= h_{\left( M'_y \right)}(q)
  \end{alignat*}
  \begin{alignat*}{3}
    p_{\MS{match}} &~ (\inl      q) &&:= \dots \\
    p_{\MS{match}} &~ (\inr (y, q)) &&:= p'_y(q)
  \end{alignat*}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Correctness}
  \begin{lemma}[Correctness of $\MS{match}$]
    If $M \VDash R$ and for each $y:F$, $M'_y \VDash R'_y$, then
    $$\MS{match} \VDash \bigcup_{y:F} \left( (R \at y) \circ R'_y \right)$$
  \end{lemma}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Sequential composition is just an instance of match.}
  \begin{definition}[Sequential composition]
    For dependent pairs of machines and transition functions $M_1$ and $M_2$:
    $$M_1 \mseq M_2 := \mmatch~M_1~(\lam y M_2)$$
  \end{definition}

  \begin{corollary}[Correctness of sequential composition]
    If $M_1 \VDash R_1$ and $M_2 \VDash R_2$, then $M_1 \mseq M_2 \VDash R_1 \circ \hideParam R_2$.
  \end{corollary}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{If then else is just an instance of match.}
  \begin{definition}[Boolean if]
    For dependent pairs of machines and transition functions $M_1$, $M_2$, and $M_3$,
    where $M_1$ is partitioned over $\Bool$:
    $$ \mif{M_1}{M_2}{M_3} := \MS{match}~(M_1) \left(\lam b \begin{cases} M_2 & b = \true \\ M_3 & b = \false \end{cases} \right) $$
  \end{definition}

  \begin{corollary}[Correctness of boolean if]
    If $M_1 \VDash R_1$ and $M_2 \VDash R_2$ and $M_3 \VDash R_3$, then
    $\mif{M_1}{M_2}{M_3} \VDash (R_1 \at \true) \circ R_2 \cup (R_1 \at \false) \circ R_3$.
  \end{corollary}
\end{frame}

\begin{frame}{While}
  \center
  \resizebox{3.0cm}{!}{%
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,bend angle=45]
      \begin{scope}
        % Machine M
        \node[state]          (M init)                                    {$q_0$};
        \node[state]          (M exit 1)  [right of=M init,yshift= 1.5cm] {$q_{h1}$};
        \node[state, double]  (M exit 2)  [right of=M init,yshift= 0.0cm] {$q_{h2}$};
        \node[state, double]  (M exit 3)  [right of=M init,yshift=-1.5cm] {$q_{h3}$};
        \path (M init)
        edge[dotted]          (M exit 1)
        edge[dotted]  (M exit 2)
        edge[dotted]  (M exit 3);
        \path (M init) ++(-1.0,0) edge (M init);
        \path (M exit 1) edge[bend right] node[anchor=south,yshift=0.2em] {$(\None, N)$} (M init);
      \end{scope}

      \begin{pgfonlayer}{background}
        \filldraw [line width=4mm,join=round,blue!10]
        (M   exit 1.north -| M   init.west) rectangle (M   exit 3.south -| M   exit 3.east);
      \end{pgfonlayer}
    \end{tikzpicture}
  }
  \begin{lemma}[Correctness of $\MS{while}$]
    If $M \VDash R$, then
    $$ \MS{while} \VDash
    \left( \bigcup_{y:F} R\at{(\true, y)} \right)^* \circ
    \setMap{(t, (y, t'))}{R~t~((\false, y), t')}
    $$
  \end{lemma}
\end{frame}

\begin{frame}{Machine transformations}
  \textbf{Problem:}
  When combining machines, the numbers of tapes and the alphabet have to match!
  \pause

  Two operations on machines:
  \begin{itemize}
    \item $n$-Lift: injection on the tapes
    \item $\Sigma$-Lift: injection on the alphabet
  \end{itemize}
\end{frame}

\begin{frame}{$n$-lift}
  \begin{figure}
    \center
    \begin{tikzpicture}
      \begin{scope}
        \node(a0)[yshift=-0 cm]  {$0$};
        \node(a1)[yshift=-1 cm]  {$1$};
        \node(a2)[yshift=-2 cm]  {$2$};
      \end{scope}
      \begin{scope}[xshift=4cm, yshift=0cm]
        \node(b0)[yshift=-0 cm] {$0$};
        \node(b1)[yshift=-1 cm] {$1$};
        \node(b2)[yshift=-2 cm] {$2$};
        \node(b3)[yshift=-3 cm] {$3$};
        \node(b4)[yshift=-4 cm] {$4$};
      \end{scope}
      \begin{scope}[xshift=5cm, yshift=-3cm]
        \node(none)             {$\None$};
      \end{scope}
      \path (a0) edge[<->] (b1);
      \path (a1) edge[<->] (b0);
      \path (a2) edge[<->] (b3);
      \path (b2) edge[-> ] (none);
      \path (b4) edge[-> ] (none);
    \end{tikzpicture}
    \caption{Tape retract encoded as the index-vector $[1, 0, 3]$.}
  \end{figure}
\end{frame}


\begin{frame}{$\Sigma$-lift}
  \begin{figure}
    \center
    \begin{tikzpicture}
      \begin{scope}
        \node(alpha)[yshift=-0 cm] {$\alpha$};
        \node(beta) [yshift=-1 cm] {$\beta$};
        \node(gamma)[yshift=-2 cm] {$\gamma$};
      \end{scope}
      \begin{scope}[xshift=4cm, yshift=1cm]
        % Symbols of $\Tau$
        \node(a)[yshift=-0 cm] {$a$};
        \node(b)[yshift=-1 cm] {$b$};
        \node(c)[yshift=-2 cm] {$c$};
        \node(d)[yshift=-3 cm] {$d$};
        \node(e)[yshift=-4 cm] {$e$};
      \end{scope}
      \path (alpha) edge[<->] (a);
      \path (beta)  edge[<->] (b);
      \path (gamma) edge[<->] (d);
      \path (gamma) edge[<-, dotted] (c);
      \path (gamma) edge[<-, dotted] (e);
    \end{tikzpicture}
    \caption{Example alphabet retract; $\gamma$ is the default symbol in $\Sigma$.}
  \end{figure}
\end{frame}

\begin{frame}{Basic machines}
  Classes of $1$-tape machines for each basic action \\(together with partitioning functions):
  \begin{itemize}
    \item Move head in the direction $D$
    \item Write one symbol
    \item Read one symbol
    \item nop
    \pause%
    \item Write a list of symbols (defined per recursion over the string)
  \end{itemize}
\end{frame}

\begin{frame}{Encoding}
  \begin{definition}[Encodable types]
    A type $X$ is \emph{encodable} over $\Sigma$, if there exists a function $\MS{encode} \from X \to \List~\Sigma$, s.t.
    $\MS{encode}(x) \app r_1 = \MS{encode}(v_2) \app r_2$
    implies $v_1 = v_2$ and $r_1 = r_2$, for all $v_1,v_2 : X$ and $r_1,r_2: \List~\Sigma$.
  \end{definition}
  \pause%
  \begin{definition}[Tape encodes value]
    We write $\Sigma^+$ instead of $\Sigma + \Bool$. \\
    For a $X$ encodable over $\Sigma$, a $\Sigma^+$-tape $t$ \textbf{encodes} a value $x:X$, if
    $$t = \midtape{(r_1 \app [\true])}{(\inl y)}{(\map~\inl~ys \app \false \cons r_2)} $$
    for $y \cons ys = \MS{encode}(x)$, and some $r_1, r_2 \in \List~\Sigma^+$.
  \end{definition}
\end{frame}

%% TODO
\begin{frame}{Calculate functions}
  \begin{definition}[Calculate function]
    A machine $M$ \emph{computes} a function $f \from X \to Y$ from $i < n$ to $j < n$, if
    \begin{multline*}
      M \VDash \ignoreParam \setMap{(t_{in}, t_{out})}{\\
      \forall x:X,~ \MS{encodes}(t_{in}[i], x) \rightarrow \MS{encodes}(t_{out}[j], f(x))}.
    \end{multline*}
  \end{definition}
  \pause%
  \begin{lemma}[Finite functions]
    All functions with finite range and domain are computable in one step.
  \end{lemma}
  \pause%
  Extendable to multiple tapes.
\end{frame}

\begin{frame}{Example: Boolean machines}
  \begin{itemize}
    \item There is a machine $\MS{AND}$ that computes boolean conjugation.
    \item When we apply the $\Sigma$-lift where we swap $\true$ with $\false$, we get $\MS{OR}$.
    \item Then $\MS{OR}$ computes boolean disjunction.
  \end{itemize}
	\begin{table}
		\begin{tabular}{|cc|cc|c|c|c|}
			\hline
			$a$ & $\bar{a}$ & $b$ & $\bar{b}$ & $a\land b$ & $\bar{a}\land\bar{b}$ & $\overline{\bar{a}\land\bar{b}}=a\lor b$\tabularnewline
			\hline
			\hline
			0 & 1 & 0 & 1 & 0 & 1 & 0\tabularnewline
			\hline
			0 & 1 & 1 & 0 & 0 & 0 & 1\tabularnewline
			\hline
			1 & 0 & 0 & 1 & 0 & 0 & 1\tabularnewline
			\hline
			1 & 0 & 1 & 0 & 1 & 0 & 1\tabularnewline
			\hline
		\end{tabular}
	\end{table}
\end{frame}


\begin{frame}{Conclusion}
  What we have
  \begin{itemize}
    \item Formal definition of Turing machines and a framework of correctness predicates
    \item Construction and verification of combinators and transformations
    \item Formal definition of encoding and computation
    \item Implementation of some basic and compound machines
  \end{itemize}

  Future work
  \begin{itemize}
    \item Verify compound machines with $\MS{while}$, e.g.\ the projection functions for tuples and lists
    \item Build towards an interpreter for the weak CBV lambda calculus $L$
    \item Time and space analysis; proof strong invariant thesis for $L$
  \end{itemize}
\end{frame}

\appendix % appendix sections will not occur in the headline

%% Backup-Slides

\begin{frame}{Backup Slides}
  This Are The Backup Slides!
  \vfill
  Thank you!
\end{frame}

\begin{frame}{coqwc}
	% \tiny \verbatiminput{../wc.txt}
	\begin{table}
		\begin{tabular}{|l|r|r|}
			\hline
			& Lines Spec & Lines Proof\tabularnewline
			\hline
			Prelim & 235+ & 286+\tabularnewline
			Relations/Retracts & 475 & 269\tabularnewline
			Def. $n$TM & 215 & 85\tabularnewline
			$\Sigma$-Lift & 132 & 129\tabularnewline
			$n$-Lift & 153 & 195\tabularnewline
			Basic machines & 142 & 69\tabularnewline
			Encoding & 170 & 164\tabularnewline
			Computation & 241 & 289\tabularnewline
			Combinators & 158 & 354\tabularnewline
			Finite and $\Bool$ TM & 112 & 203\tabularnewline
			\hline
			$\Sigma$ & 2033 & 2042\tabularnewline
			\hline
		\end{tabular}
	\end{table}
\end{frame}

\end{document}

% vim: ts=2 sts=2 sw=2 expandtab textwidth=150
