\include{beamerhead}
\include{mypreamble}
% My favourite color theme for beamer
\usecolortheme{orchid}
\usepackage{verbatim}

\title{Formalising multi-tape Turing machines in Coq}
\subtitle{First Bachelor Seminar Talk}
\author{Maximilian Wuttke}
\institute{{\scshape Saarland University}}
\date{Dezember 21, 2017}

% Passt nicht gut
% \include{beamerlayout}

\begin{document}

\frame{\titlepage}

\begin{frame}{Introduction: Finish the reduction chain}
  $$\lambda \rightarrow \SM{MTTM} \rightarrow \SM{TM} \rightarrow \SM{PCP}$$
\end{frame}

\begin{frame}{Introduction: Turing machines}
  Pros:
  \begin{itemize}
    \item are easy to understand / imagine;
    \item are the de-factor standard model of computation
  \end{itemize}
  \pause \\
  Cons:
  \begin{itemize}
    \item not compositional;
    \item encoding data is tedious;
    \item formal reasoning is tedious;
    \item completely unstructured
  \end{itemize}
\end{frame}

\begin{frame}{Introduction: Related Work}
  \footnotesize
  \begin{thebibliography}{10}
    \beamertemplatearticlebibitems
    \bibitem{}
    Xu, Jian and Zhang, Xingyuan and Urban, Christian
    \newblock{\em Mechanising Turing Machines and Computability Theory in Isabelle/HOL}
    \newblock{ITP 2013}

    \bibitem{}
    Andrea Asperti and Wilmer Ricciotti
    \newblock{\em A formalization of multi-tape Turing machines}
    \newblock{Theoretical Computer Science, 2015}

  \end{thebibliography}
\end{frame}


\begin{frame}{Definitions}
  \begin{definition}[$n$-tape Turing machine]
    Let $\Sigma$ be a finite type and $n:\Nat$.
    \\
    An $n$-tape Turing machine over $\Sigma$ is a tuple:
    \begin{itemize}
      \item $Q : \MS{finType}$ (states);
      \item $\gamma \from Q \times (\Option~\Sigma)^n \to Q \times (\Option~\Sigma \times \MS{Move})^n$
        \\ (transition function);
      \item $s:Q$ (start state);
      \item $h \from Q \to \Bool$ (halting states)
    \end{itemize}
    Where $\MS{Move} := \setOf{L, R, N}$.
  \end{definition}
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Tape]
    A tape over $\Sigma$ is either:
    $ \niltape$, $\leftof{r}{R}$, $\midtape{R}{m}{L}$, or $\rightof{L}{l}$,\\
    Where $r,l : \Sigma$ and $R,L : \List~\Sigma$.
    \pause
    \begin{alignat*}{2}
      \emph{Tape}:\Type := \quad & \MS{niltape} \\
      | \quad & \MS{leftof}  ~ (r:\Sigma) ~ (R:\List~\Sigma) \\
      | \quad & \MS{midtape} ~ (L:\List~\Sigma) ~ (m:\Sigma) ~ (R:\List~\Sigma) \\
      | \quad & \MS{rightof} ~ (l:\Sigma) ~ (L:\List~\Sigma).
    \end{alignat*}
  \end{definition}
  \pause
  \begin{definition}[Configuration]
    A configuration of a machine $M$ is a tuple $\MS{Conf} := \{\MS{state}:Q_M, \MS{tapes}:\Tape^n\}$.
  \end{definition}
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Step function]
    With the functions
    \begin{alignat*}{2}
      \MS{mv}      & \from \Move \to \Tape \to \Tape \\
      \MS{wr}      & \from \Tape \to \Option~\Sigma \to \Tape \\
      \MS{wr\_mv}  & \from \Tape \to (\Option~\Sigma \times \Move) \to \Tape \\
      \MS{current} & \from \Tape \to \Option~\Sigma
    \end{alignat*}
    we define for a machine $M$
    \begin{alignat*}{2}
      \MS{step}&~(\MS{tapes}, q) &~:=~& \mlet{(q', \MS{actions}) := \gamma_M(q, \map~\MS{current}~\MS{tapes})}{ \\
               &                 &~  ~& (q', \map_2~\MS{wr\_mv}~\MS{tapes}~\MS{actions})}
      \end{alignat*}
  \end{definition}
\end{frame}

\begin{frame}{Definitions}
  \begin{definition}[Execution]
    \begin{align*}
      \MS{loop}~n~f~h~s :=
      \begin{cases}
        \Some{s}              & h(s) = \true \\
        \None                 & h(s) = \false \land n = 0 \\
        \MS{loop}~(n-1)~f~h~(f s)  & h(s) = \false \land n > 0
      \end{cases}
    \end{align*}
    \pause
    \begin{alignat*}{3}
      \MS{init\_state}   &~\MS{tapes}      &&:= (\MS{tapes}, s_M) \\
      \MS{halting\_state}&~(\MS{tapes}, q) &&:= h_M(q) \\
      \MS{loopM}         &~\MS{initc}~k    &&:= \MS{loop}~k~\MS{step}~\MS{halting\_state}~\MS{initc} \\
      \MS{exec}          &~\MS{tapes}      &&:= \MS{loopM}~(\MS{init\_state}~\MS{tapes})
    \end{alignat*}
  \end{definition}

  \pause
  We write $\mathbf{M:t_{in} \Rightarrow^n c_{out}}$, if $\MS{exec}~t_{in}~n= \Some{c_{out}}$.
\end{frame}

\begin{frame}{Correctness of machines}
  \begin{definition}[Weak realisation, $M \VDash_p R$]
    Let $R \subseteq (\Tape^n) \times (F \times \Tape^n)$ and $p \from Q_M \to F$, for a finite $F$.\\
    Then $M$ \textbf{realises} $R$, if for all $t_{in}$, $n:\Nat$, $c_{out} = (q_{out}, t_{out})$,\\
    $M: t_{in} \Rightarrow^n c_{out}$ implies $\left(t_{in}, \left(p~q_{out}, t_{out} \right) \right) \in R$.\\
    We write $\mathbf{M \VDash_p R}$.
  \end{definition}
  We often use dependent tuples of machines with partitioning functions:
  If $M : \depPair{M' : \MS{TM}}{Q_M' \to F}$, then we write $\mathbf{M \VDash R}$.
\end{frame}

\begin{frame}{Termination of machines}
  \begin{definition}[Termination, $M \downarrow T$]
    Let $T \subseteq (\Tape^n) \times \Nat$.\\
    Then $M$ \textbf{terminates in} $T$, if for all $t_{in}$ and $n:\Nat$, $T~t_{in}~n$ implies
    that there exists a final configuration $c_{out}$, such that $M: t_{in} \Rightarrow^n c_{out}$.\\
    We write $\mathbf{M \downarrow T}$.
  \end{definition}
\end{frame}

\begin{frame}{Relations}
  \begin{columns}
    \footnotesize
    \begin{column}{0.5\textwidth}
      We use standard relational definitions:
      \begin{alignat*}{2}
        R \cap  S &:= \setMap{(x, y)}{R~x~y \land S~x~y} \\
        R \cup  S &:= \setMap{(x, y)}{R~x~y \lor  S~x~y} \\
        R \circ S &:= \setMap{(x, z)}{\exists y,~ R~x~y \land S~y~z} \\
        \MS{Id}   &:= \setOf{(x, x)}{}
      \end{alignat*}
      Reflexive transitive closure:
      $$\inferrule{ }{R^*~x~x} \qquad \inferrule{R~x~y \and R^*~y~z}{R^*~x~z}$$
    \end{column}
    \begin{column}{0.5\textwidth}
      Parametrises relations:
      \begin{alignat*}{2}
        \ignoreParam   R &:= \setMap{(x, (y, z))}{R ~ x ~ z} \\
        \hideParam R &:= \setMap{((x, y), z)}{R ~ x ~ z}
      \end{alignat*}
      Relational if:
      \begin{alignat*}{3}
        R_1 \rif R_2 :=  &\setMap{(x, (\true, y))&}{R_1~x~y} \\
        \cup\, &\setMap{(x, (\false, y))&}{R_2~x~y}
      \end{alignat*}
      Big union:
      $$\bigcup_{y:F}R(y) := \setMap{(x, z)}{\exists y:F,(R~y)~x~z}$$
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Combinators}
  \begin{itemize}
    \item Implement programming primitives as operators on Turing machines:
    \begin{itemize}
      \item match
      \item Sequential composition
      \item if then else
      \item do-while
    \end{itemize}
  \item Verify them using the relational approach
  \end{itemize}
  \pause
  \begin{thebibliography}{10}
    \beamertemplatearticlebibitems
    \bibitem{}
    Andrea Asperti and Wilmer Ricciotti
    \newblock{\em A formalization of multi-tape Turing machines}
    \newblock{Theoretical Computer Science, 2015}
  \end{thebibliography}
  \begin{itemize}
    \item if then else, sequential composition, and do-while
  \end{itemize}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{The idea}
  Given:
  \begin{itemize}
    \item Two finite types $F$ and $F'$,
    \item A machine $M$ and a partitioning function $p \from Q_M \to F$,
    \item For all $y:F$, a machine $M'_y$ with a partitioning function $p'_y \from Q_{M'_y} \to F'$
  \end{itemize}
  Do:
  \begin{enumerate}
    \item Execute a machine $M$.
    \item Depending on the state of termination $q_h$:
      \begin{itemize}
        \item Execute the machine $M'_{p(q_h)}$.
      \end{itemize}
  \end{enumerate}
\end{frame}


\begin{frame}{Match}
  \framesubtitle{Example for a match machine}
  \include{fig-match}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Definition}
  \footnotesize
  $$Q_{\MS{match}} := Q_M + \depPair{y:F}{Q_{ \left( M'_{y} \right) }}$$
  \begin{alignat*}{2}
    \gamma_{\MS{match}} & (\inl q, \MS{symbols}) &&:=
    \begin{cases}
      \gamma_{M}(q, \MS{symbols})                                & h_M(q) = \false \\
      \left( s_{\left(M'_{p(q)}\right)}, (\None, N)^n \right)  & h_M(q) = \true
    \end{cases} \\
    \gamma_{\MS{match}} & (\inr (y, q), \MS{symbols}) &&:= \gamma_{\left({M'_y}\right)}(q, \MS{symbols})
  \end{alignat*}
  \begin{alignat*}{3}
    h_{\MS{match}} &~ (\inl      q) &&:= \false \\
    h_{\MS{match}} &~ (\inr (y, q)) &&:= h_{\left( M'_y \right)}(q)
  \end{alignat*}
  \begin{alignat*}{3}
    p_{\MS{match}} &~ (\inl      q) &&:= \dots \\
    p_{\MS{match}} &~ (\inr (y, q)) &&:= p'_y(q)
  \end{alignat*}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Correctness}
  \begin{lemma}[Correctness of $\MS{match}$]
    If $M \VDash R$ and for each $y:F$, $M'_y \VDash R'_y$, then
    $$\MS{match} \VDash \bigcup_{y:F} \left( (R \at y) \circ R'_y \right)$$
  \end{lemma}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{Sequential composition is just an instances of match.}
  \begin{definition}[Sequential composition]
    For dependent pairs of machines and transition functions $M_1$ and $M_2$:
    $$M_1 \mseq M_2 := \mmatch~M_1~(\lam y M_2)$$
  \end{definition}

  \begin{corollary}[Correctness of sequential composition]
    If $M_1 \VDash R_1$ and $M_2 \VDash R_2$, then $M_1 \mseq M_2 \VDash R_1 \circ \hideParam R_2$.
  \end{corollary}
\end{frame}

\begin{frame}{Match}
  \framesubtitle{If then else is just an instances of match.}
  \begin{definition}[Boolean if]
    For dependent pairs of machines and transition functions $M_1$, $M_2$, and $M_3$,
    where $M_1$ is partitioned over $\Bool$:
    $$ \mif{M_1}{M_2}{M_3} := \MS{match}~(M_1) \left(\lam b \begin{cases} M_2 & b = \true \\ M_3 & b = \false \end{cases} \right) $$
  \end{definition}

  \begin{corollary}[Correctness of boolean if]
    If $M_1 \VDash R_1$ and $M_2 \VDash R_2$ and $M_3 \VDash R_3$, then
    $\mif{M_1}{M_2}{M_3} \VDash (R_1 \at \true) \circ R_2 \cup (R_1 \at \false) \circ R_3$.
  \end{corollary}
\end{frame}

\begin{frame}{While}
  \center
  \resizebox{3.0cm}{!}{%
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,bend angle=45]
      \begin{scope}
        % Machine M
        \node[state]          (M init)                                    {$q_0$};
        \node[state]          (M exit 1)  [right of=M init,yshift= 1.5cm] {$q_{h1}$};
        \node[state, double]  (M exit 2)  [right of=M init,yshift= 0.0cm] {$q_{h2}$};
        \node[state, double]  (M exit 3)  [right of=M init,yshift=-1.5cm] {$q_{h3}$};
        \path (M init)
        edge[dotted]          (M exit 1)
        edge[dotted]  (M exit 2)
        edge[dotted]  (M exit 3);
        \path (M init) ++(-1.0,0) edge (M init);
        \path (M exit 1) edge[bend right] node[anchor=south,yshift=0.2em] {$(\None, N)$} (M init);
      \end{scope}

      \begin{pgfonlayer}{background}
        \filldraw [line width=4mm,join=round,blue!10]
        (M   exit 1.north -| M   init.west) rectangle (M   exit 3.south -| M   exit 3.east);
      \end{pgfonlayer}
    \end{tikzpicture}
  }
  \begin{lemma}[Week correctness of $\MS{while}$]
    If $M \VDash R$, then
    $$ \MS{while} \VDash
    \left( \bigcup_{y:F} R\at{(\true, y)} \right)^* \circ
    \setMap{(t, (y, t'))}{R~t~((\false, y), t')}
    $$
  \end{lemma}
\end{frame}

\begin{frame}{Machine transformations}
  Three operations on machines:
  \begin{itemize}
    \item $n$-Lift: injection on the tapes
    \item $\Sigma$-Lift: injection on the alphabet
    \item Mirror: swap left and right movement
  \end{itemize}
\end{frame}

\begin{frame}{$n$-lift}
  \begin{figure}
    \center
    \begin{tikzpicture}
      \begin{scope}
        \node(a0)[yshift=-0 cm]  {$0$};
        \node(a1)[yshift=-1 cm]  {$1$};
        \node(a2)[yshift=-2 cm]  {$2$};
      \end{scope}
      \begin{scope}[xshift=4cm, yshift=0cm]
        \node(b0)[yshift=-0 cm] {$0$};
        \node(b1)[yshift=-1 cm] {$1$};
        \node(b2)[yshift=-2 cm] {$2$};
        \node(b3)[yshift=-3 cm] {$3$};
        \node(b4)[yshift=-4 cm] {$4$};
      \end{scope}
      \begin{scope}[xshift=5cm, yshift=-3cm]
        \node(none)             {$\None$};
      \end{scope}
      \path (a0) edge[<->] (b1);
      \path (a1) edge[<->] (b0);
      \path (a2) edge[<->] (b3);
      \path (b2) edge[-> ] (none);
      \path (b4) edge[-> ] (none);
    \end{tikzpicture}
    \caption{Tape retract encoded as the index-vector $[1, 0, 3]$.}
  \end{figure}
\end{frame}


\begin{frame}{$\Sigma$-lift}
  \begin{figure}
    \center
    \begin{tikzpicture}
      \begin{scope}
        \node(alpha)[yshift=-0 cm] {$\alpha$};
        \node(beta) [yshift=-1 cm] {$\beta$};
        \node(gamma)[yshift=-2 cm] {$\gamma$};
      \end{scope}
      \begin{scope}[xshift=4cm, yshift=1cm]
        % Symbols of $\Tau$
        \node(a)[yshift=-0 cm] {$a$};
        \node(b)[yshift=-1 cm] {$b$};
        \node(c)[yshift=-2 cm] {$c$};
        \node(d)[yshift=-3 cm] {$d$};
        \node(e)[yshift=-4 cm] {$e$};
      \end{scope}
      \path (alpha) edge[<->] (a);
      \path (beta)  edge[<->] (b);
      \path (gamma) edge[<->] (d);
      \path (gamma) edge[<-, dotted] (c);
      \path (gamma) edge[<-, dotted] (e);
    \end{tikzpicture}
    \caption{Example alphabet retract; $\gamma$ is the default symbol in $\Sigma$.}
  \end{figure}
\end{frame}

\begin{frame}{Basic machines}
  Classes of $1$-tape machines for each basic action \\(together with partitioning functions):
  \begin{itemize}
    \item Move head in the direction $D$
    \item Write one symbol
    \item Read one symbol
    \item nop
    \pause
    \item Write a list of symbols (defined per recursion over the string)
  \end{itemize}
\end{frame}

\begin{frame}{Encoding}
  \begin{definition}[Encodable types]
    A type $X$ is \emph{encodable} over $\Sigma$, if there exists a function $\MS{encode} \from X \to \List~\Sigma$, s.t.
    $\MS{encode}(x) \app r_1 = \MS{encode}(v_2) \app r_2$
    implies $v_1 = v_2$ and $r_1 = r_2$, for all $v_1,v_2 : X$ and $r_1,r_2: \List~\Sigma$.
  \end{definition}
  \pause
  \begin{definition}[Tape encodes value]
    We write $\Sigma^+$ instead of $\Sigma + \Bool$. \\
    For a $X$ encodable over $\Sigma$, a $\Sigma^+$-tape $t$ \textbf{encodes} a value $x:X$, if
    $$t = \midtape{(r_1 \app [\true])}{(\inl y)}{(\map~\inl~ys \app \false \cons r_2)} $$
    for $y \cons ys = \MS{encode}(x)$, and some $r_1, r_2 \in \List~\Sigma^+$.
  \end{definition}
\end{frame}

%% TODO
\begin{frame}{Calculate functions}
  \begin{definition}[Calculate function]
    A machine $M$ \emph{computes} a function $f \from X \to Y$ from $i < n$ to $j < n$, if
    \begin{multline*}
      $M \VDash \ignoreParam \setMap{(t_{in}, t_{out})}{\\
      \forall x:X,~ \MS{encodes}(t_{in}[i], x) \rightarrow \MS{encodes}(t_{out}[j], f(x))}.$$
    \end{multline*}
  \end{definition}
  \pause
  \begin{lemma}[Finite functions]
    All functions with finite range and domain are computable in one step.
  \end{lemma}
  \pause
  Extendable to multiple tapes.
\end{frame}


\begin{frame}{Conclusion}
  What we have
  \begin{itemize}
    \item Formal definition of turing machines and a framework of correctness predicates
    \item Construction and verification of combinators and transformations
    \item Formal definition of encoding and computation
    \item Implementation of some basic and compound machines
  \end{itemize}

  Future work
  \begin{itemize}
    \item Verify compound machines with $\MS{while}$, e.g.\ the projection functions for tuples and lists
    \item Build torwards an interpreter for the week CBV lambda calculus $L$
    \item Time and space analysis; proof strong invariant thesis for $L$
  \end{itemize}
\end{frame}

\appendix % appendix sections will not occur in the headline

\backupbegin % backup-slides will not be counted for the numbering

\begin{frame}{Backup Slides}
  This Are The Backup Slides!
  \vfill
  Thank you!
\end{frame}

\begin{frame}{coqwc}
  \tiny
  \verbatiminput{../wc.txt}
\end{frame}

\backupend

\end{document}
% vim: ts=2 sts=2 sw=2 expandtab textwidth=150
