\chapter{Lifting Machines}
\label{chap:lifting}

We observe that whenever we want to combine machines, the numbers of tapes and alphabets of all involved machines have to match.

For example, assume that we have a one-tape machine that moves the head to the right.  If we need a two-tape machine that moves both tapes to the
right, we would like to use sequential composition and move one tape after the other tape to right.  But we would need two two-tape machines: one that
moves the first tape to the right and one that moves the second tape to the right.  There are multiple ways to solve this problem.  For example, we
could define a class of $n$-tape machines that move the $i$th tape to the right and leave all other tapes unchanged.  However, it is in general easier
to build and prove correctness of small machines that operate on a minimal amount of tapes.  Asperti and Ricciotti~\cite{asperti2015} define an
injecting operator that translates an one-tape machine into a $(1+n)$-tape machine.  We generalise this approach and implement an operator that takes
an $m$-tape machine and yields an $n$-tape machine, where $m \le n$.

The second part of this problem is how to combine machines with different alphabets.  For example, if we have a machine $\MS{Add}$ that sums
(encodings of) natural numbers, we could want to build a machine $\MS{Sum}$ that sums numbers in a list of numbers.  Consider an alphabet
$\Sigma_\Nat$ where we could encode natural numbers on, and an alphabet $\Sigma_{\List(\Nat)}$ to encode lists of natural numbers.  If the alphabet
$\Sigma_\Nat$ is included in $\Sigma_{\List(\Nat)}$, we would like to lift $\MS{Add}$ to the alphabet $\Sigma_{\List(\Nat)}$, to define $\MS{Sum}$.

Asperti and Ricciotti~\cite{asperti2015} avoid the latter problem.  They consider a fixed alphabet to encode all needed data on, to implement a
universal Turing machine.  However, this approach does not scale.  When the alphabet has to be changed, for example because we have to add a new data
type, they also must change the definitions of all involved ``smaller'' machines.  That is why we also introduce an operator that lifts a machine to a
bigger alphabet.


\section{Tape-Lift}
\label{sec:n-Lift}
\setCoqFilename{FormalComplexity.TM.Lifting.LiftTapes}%

The tape-lift takes a machine $M:\TM_\Sigma^m(F)$ and a duplicate-free vector\footnote{ Note that instead of duplicate free index vectors
  $I:\Fin_n^m$, we could also use injective functions $f: \Fin_m \to \Fin_n$.  However, we choose index-vectors, because they are easier to define in
  Coq.}  $I: \Fin_n^m$, and yields a machine $\LiftTapes{M}{I} : \TM_\Sigma^n(F)$.  The tape of $\LiftTapes{M}{I}$ with the index $i = I[j]$ (with
$i:\Fin_n$, $j:\Fin_m$), behaves exactly as the tape $j$ of $M$. All other tapes of $\LiftTapes{M}{I}$ that are not in $I$, do not change.


The transition function of $\LiftTapes{M}{I}$ gets the $n$ read symbols and selects the $m$ relevant symbols.  Then it applies the transition function
$\delta_M$ with the selected symbols and the current state $q$.  $\delta_M$ yields an $m$-vector $act:\Act^m$ and the continuation state $q'$.  It
fills ``nop''-actions into $act$, to get an action vector $act':\Act^n$.

\begin{definition}[Vector selecting][select]
  \label{def:select}
  Let $X:\Type$, $m,n:\Nat$, $I : \Fin_n^m$, and $V : X^n$.
  \[ select~I~V := \map{\bigl(\lambda (j:\Fin_m).~V[j] \bigr)}{I}. \]
\end{definition}
\begin{lemma}[Correctness of $select$][select_nth]
  By definition, for $k:\Fin_m$, we have
  \[
    (select~I~V)[k]=V\bigl[I[k]\bigr].
  \]
\end{lemma}

\begin{definition}[Vector filling][fill]
  Let $X:\Type$, $m,n:\Nat$,$I:\Fin_n^m$, $init:X^n$, and $V:X^m$:
  \begin{alignat*}{3}
    & fill~(\nil      )&& ~init~V &~:=~& init \\
    & fill~(i \cons I')&& ~init~V &~:=~& replace~(fill~I'~(\tl V))~i~(\hd V)
  \end{alignat*}
  Where $replace : X^n \to \Fin_n \to X \to X^n$ replaces the $i$th element of a vector.
\end{definition}
\begin{lemma}[Correctness of $fill$]
  If $I$ is duplicate-free, then
  \begin{enumerate}
  \coqitem[fill_correct_nth] \label{lem:fill_correct_nth}
    If $I[j]=i$, then $(fill~I~init~V)[i] = V[j]$.
  \coqitem[fill_not_index] \label{lem:fill_not_index}
    If $i \notin I$, then $(fill~I~init~V)[i] = init[i]$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By induction on $I : \Fin_n^m$.
\end{proof}

\begin{definition}[$\LiftTapes{M}{I}$][LiftTapes]
  \label{def:LiftTapes}
  Let $M:\TM_\Sigma^m(F)$ and $I : \Fin_n^m$.  We define $\LiftTapes{M}{I} : \TM_\Sigma^n(F)$.  All components are the same as in $M$, except:
  \begin{alignat*}{2}
    &\delta(q,s) &~:=~& \Let{(q', act) := \delta_M(q, select~I~sym)}{\\%
    &            &~  ~& (q', fill~I~(\None,N)^n~act)}
  \end{alignat*}
\end{definition}

\begin{lemma}[Correctness of $\LiftTapes{M}{I}$][LiftTapes_Realise]
  \label{lem:LiftTapes_Realise}
  Let $M : \TM_\Sigma^m(F)$ and $I : \Fin_n^m$ a duplicate-free index-vector.  If $M \Realise R$, then $\LiftTapes{M}{I} \Realise \LiftTapes{R}{I}$ with
  \[
    \LiftTapes{R}{I} := \lambda t~(y,t').~ R~(select~I~t)~(y, select~I~t') \land \forall i:\Fin_n.~i \notin I \rightarrow t'[i]=t[i].
  \]
\end{lemma}

\begin{lemma}[Runtime of $\LiftTapes{M}{I}$][LiftTapes_TerminatesIn]
  \label{lem:LiftTapes_TerminatesIn}
  Let $M : \TM_\Sigma^m(F)$ and $I$ duplicate-free index-vector. If $M \TerminatesIn T$, then $\LiftTapes{M}{R} \TerminatesIn \LiftTapes{T}{I}$ with
  $
    \LiftTapes{T}{I} := \lambda t~k.~ T~(select~I~t)~k.
  $
\end{lemma}

The proofs are similar to the former proofs, i.e.\ using Lemma~\ref{lem:loop_lift} and Lemma~\ref{lem:loop_unlift} with the following configuration
lifting function:
\[
  selectConf(q,t) := (q, select~I~t).
\]

However, for the second part of the correctness, i.e.\ tapes that are not in $I$ do not change, we need another lemma about $loop$:

\begin{lemma}[Mapping loops][loop_map]
  \label{lem:loop_map}
  Let $A:\Type$, $f:A \to A$, $h:A \to\ Bool$.  Let $B:\Type$ and $g : A \to B$.  If $g(f~a)=g(a)$ for all $a:A$, then
  \begin{alignat*}{1}
    & \forall (k:\Nat)~(a_1~a_2 : A). \\
    & \quad loop~f~h~k~a_1 = \Some{a_2} \rightarrow \\
    & \quad g(a_1) = g(a_2).
  \end{alignat*}
\end{lemma}
\begin{proof}
  By induction on $k:\Nat$.
\end{proof}

We apply this lemma in the proof of Lemma~\ref{lem:LiftTapes_Realise} with $g := \lambda ((q,t):\Conf).~t[i]$.



\section{Alphabet-Lift}
\label{sec:sigma-Lift}
\setCoqFilename{FormalComplexity.TM.Lifting.LiftAlphabet}%

Let $M : \TM_\Sigma^n(F)$ be a machine over the alphabet $\Sigma$, and $f : \Sigma \hookrightarrow \Tau$ a retraction on another alphabet $\Tau$.
Note that then $\Tau$ has at least as many symbols as $\Sigma$.  We need a default symbol $def:\Sigma$.  In contrast to the default partition we
needed in the definition of $\While$, the choice of $def$ is semantically relevant.  This means that $def$ should be a symbol that $M$ does not expect
to read.  The alphabet-lift $\LiftAlphabet{M}{(f,def)} : \TM_\Tau^n$ is a machine over the bigger alphabet $\Tau$.

The transition function of the lifted machine $\LiftAlphabet{M}{(f,def)}$ reads the symbols \\$s :
(\Option(\Tape_\Tau))^n$.  It tries to translate these symbols to $s':(\Option(\Tape_\Sigma))^n$ using the partial inversion function $f^{-1} : \Tau
\to \Option(\Sigma)$.  However, if the symbol $\tau:\Tau$ has no corresponding symbol in $\Sigma$, it must be translated to
$def$ instead.  The transition function $\delta_M$ of $M$ yields the successor state $q'$ and a vector of actions $act: (\Option(\Sigma) \times
\MS{Move})^n$, which is translated using $f:\Sigma\to\Tau$ to $act' : (\Option(\Tau) \times \MS{Move})^n$.

\begin{definition}[$\LiftAlphabet{M}{(f,def)}$][LiftAlphabet]
  \label{def:LiftAlphabet}
  Let $f : \Sigma \Tau$, $def:\Sigma$, and $M : \TM_\Sigma^n(F)$.  We define the machine %
  $\LiftAlphabet{M}{(f,def)} : \TM_\Tau^n(F)$ with the same components as $M$, except:
  \begin{alignat*}{2}
    &\delta(q,s)    &~:=~& \Let{(q', act) := \delta_M(q, \map{(mapOpt~surject)}{s})}{\\%
    &               &~  ~& (q', \map{(mapAct~f)}{act})} \\
    & surject(\tau) &~:=~&
    \begin{cases}
      \sigma & f^{-1}(\tau) = \Some{\sigma} \\
      def & f^{-1}(\tau) = \None
    \end{cases}
  \end{alignat*}
  with the canonical functions $mapOpt: \forall (X~Y:\Type).~ (X \to Y) \to \Option(X) \to \Option(Y)$ and
  $mapAct : \forall (\Sigma~\Tau:\Type).~(\Sigma\to\Tau) \to \Act_\Sigma \to \Act_\Tau$.  All other components are the same as $M$.
\end{definition}

\setCoqFilename{FormalComplexity.TM.TM}%
For the correctness and runtime lemmas, we also need the canonical function
\[
  \coqlink[mapTape]{mapTape}:\forall (\Tau~\Sigma:\Type).~(\Tau\to\Sigma)\to\Tape_\Tau\to\Tape_\Sigma
\]
that maps every symbol on a tape.  We write $\coqlink[mapTapes]{mapTapes}$ for the respective tape-vector function.
\setCoqFilename{FormalComplexity.TM.Lifting.LiftAlphabet}%

\begin{lemma}[Correctness of $\LiftAlphabet{M}{(f,def)}$][LiftAlphabet_Realise]
  \label{lem:LiftAlphabet_Realise}
  If $M \Realise R$, then $\LiftAlphabet{M}{(f,def)} \Realise \LiftAlphabet{R}{(f,def)}$ with
  \[
    \LiftAlphabet{R}{(f,def)} := \lambda t~(y, t').~R~(mapTapes~surject~t)~(y, mapTapes~surject~t').
  \]
\end{lemma}

\begin{lemma}[Runtime of $\LiftAlphabet{M}{(f,def)}$][LiftAlphabet_TerminatesIn]
  \label{lem:LiftAlphabet_TerminatesIn}
  If $M \TerminatesIn T$, then $\LiftAlphabet{M}{(f,def)} \TerminatesIn \LiftAlphabet{T}{(f,def)}$ with
  \[
    \LiftAlphabet{T}{(f,def)} := \lambda t~k.~T~(mapTapes~surject~t)~k.
  \]
\end{lemma}

The proofs are analogous to the former proofs.  The configuration lifting is
\[
  \coqlink[surjectConf]{surjectConf} (q,t) := (q, mapTapes~surject~t).
\]



%%% Local Variables:
%%% TeX-master: "thesis"
%%% End: