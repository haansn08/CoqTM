\chapter{Implementation in Coq}
\label{chap:implementation}

\lstset{style=coq}

% A full chapter for the implementation might not be worse it.  I think it is more important which libraries/plugins we use and how many lines of code
% do we need.  Does it really matter how we implement, e.g. tapes or Turing machines in Coq, because all definitions can be translated
% straight-forwardly to Coq.  The reader of the thesis can click on the theorems to read the source code, if he is interested.

We outline some pearls of the implementation of the framework of this thesis in the theorem prover Coq.  We do not assume additional axioms.  The
implementation compiles with the Coq versions 8.7 and 8.8.  We use proof scripts to derive proof terms in Coq, using Coq's standard tactical language
\textit{ltac}.

\section{Used Libraries}
\label{sec:coq-libraries}

Throughout the development, we make use of the \textit{typeclass} mechanism built into Coq.  Typeclasses are first-citizen objects in Coq, that may be
parametrised over types and other typeclasses.  Coq uses proof-search to infer instances of typeclasses.  For that, the user has to declare
definitions as typeclass instances.  We refer to Cast{\'e}ran and Sozeau~\cite{casteran2012gentle}, for a more thoughtful description of this feature.

\paragraph{Base Library and Finite Types}

We use a modified version of the library for the lecture \textit{Introduction to Computational Logic} by Prof.\ Smolka.  This library extends the
standard library of Coq with additional functions and automation for lists and decidable predicates.  On top of this library, we use the library of
finite types that was developed by Jan Menz in his bachelor's thesis \cite{JanMenz}.  The following listing outlines the definition of decidable
predicates and finite types:

\begin{lstlisting}
Definition dec (P:Prop) := {P} + {~ P}.
Definition eq_dec (X:Type) := forall x y, dec (x=y).
Structure eqType := EqType {
  eqtype :> Type;
  decide_eq : eq_dec eqtype
}.
Canonical Structure eqType_CS X (A: eq_dec X) := EqType X.
Class finTypeC (type: eqType) : Type := FinTypeC {
  enum : list type;
  enum_ok : forall x : type, count enum x = 1
}.
Structure finType : Type := FinType {
  type :> eqType;
  class : finTypeC type
}.
Canonical Structure finType_CS (X:Type) {p : eq_dec X} {class : finTypeC (EqType X)} : finType := FinType (EqType X).
\end{lstlisting}%

The coercions (\lstinline!:>!) make it possible to use finite types \lstinline{F:finType} as types, i.e.\ we can write \lstinline!x:F!.  The canonical
structures enable automatic inference of the structure, for example we have a function \lstinline!index : forall F:finType, F -> nat! and we can write
\lstinline!index true!.

\paragraph{Retraction Library}

We implemented a library for retractions.  We use a typeclass for the existence of retractions between two types.
\begin{lstlisting}
Section Retract.
  Variable X Y : Type.
  Definition retract (f : X -> Y) (g : Y -> option X) :=
    forall x y, g y = Some x <-> y = f x.
  Class Retract := {
    Retr_f : X -> Y;
    Retr_g : Y -> option X;
    Retr_retr : retract Retr_f Retr_g;
  }.
End Retract.
Arguments Retr_f { _ _ _ }.
Arguments Retr_g { _ _ _ }.
\end{lstlisting}
The \textit{Vernacular} command \lstinline!Arguments! makes $X$, $Y$, and the instance contextual implicit.  This means that
\lstinline!Retr_f : X -> Y!, where \lstinline!X! and \lstinline!Y! are inferred from the context.  We define instances for the retractions in
Section~\ref{sec:retracts}.

The retraction composition operator is not defined as an instance, to avoid diverging proof search during the typeclass inference, because it can be
applied arbitrary many times.  Although it is not declared as an instance of the typeclass of retractions, \lstinline!ComposeRetract! can be applied
manually.
\begin{lstlisting}
ComposeRetract : forall A B C : Type, Retract A B -> Retract B C -> Retract A C
\end{lstlisting}
We embed composition of retraction into retraction operators.  For example, instead of defining a retraction $RetrLft : X \hookrightarrow X+Y$, we
define (and declare as an instance) an operator on retractions:
\begin{lstlisting}
Retract_inl : forall A B C : Type, Retract A B -> Retract A (B + C)
\end{lstlisting}


\paragraph{Inhabited Types}
We also have a library for inhabited types.  Whenever we need a semantically irrelevant value, we can just write \lstinline!default! and Coq infers
the type and inserts a value with the following typeclass:
\begin{lstlisting}
Class inhabitedC (X : Type) :=
  {
    default : X;
  }.
\end{lstlisting}

\paragraph{Vectors and $\Fin_k$}

We use the type constructors \lstinline!Vector.t! and \lstinline!Fin.t! from Coq's standard library.  However, many basic lemmas and functions are
missing for this type.  We have a small library that adds the missing functions and lemmas.  It also provides some tactics, for example to make case
distinctions over \lstinline!Fin.t (S n)!.  We also introduce a notation for elements of $\Fin_k$.

\paragraph{smpl}

We use Sigurd~Schneider's smpl plugin \cite{SMPL}.  I lets the user add tactics to a tactic database and provides a tactic that applies the first
applicable tactic from the database.  We use this plugin for proof automation, more on that below.


\section{Value-containing}
\label{sec:coq-values}

The Coq implementation of the definition of multi-tape Turing machines is straight-forward.  Therefore, we omit code-listings here.  The interested
reader of the PDF version of this thesis might click on the definitions, to get to the Coq definitions.

We also use typeclasses to implement the notion of encodable types and value-containing.

\begin{lstlisting}
Section Codable.
  Variable (sig: Type).
  Variable (X: Type).
  Class codable := mk_codable {
    encode :> X -> list sig
  }.
End Codable.
Arguments encode {sig} {X} {_}.
Coercion encode : codable >-> Funclass.
\end{lstlisting}

The \lstinline!Coercion! vernacular makes is possible to write \lstinline!cX x!, when \lstinline!cX! is an instance that witnesses that \lstinline!x!
is encodable over \lstinline!X!.  This applies the concrete \lstinline!encode! function, given by \lstinline!cX!.  We prefer this notation over
\lstinline!encode x!, due to the fact that encodability is ambiguous, as noted in Section~\ref{sec:value-containing}.  We define the alphabets in
Definition~\ref{lem:retracts-basic} inductively, and also declare their proofs of finiteness.

We realise the type of the extended alphabet $\Sigma^+$ with $boundary + \Sigma$, where
\[ boundary ::= \MS{START} ~|~ \MS{STOP} ~|~ \MS{UNKNOWN} \]%
is defined as an inductive type.


\section{Automation}
\label{sec:coq-automation}

The Coq proof scripts make use of the builtin feature of \textit{existentials}.  An existential $?X$ is a type (that may contain variables referring
to more existentials) and the environment in which this existential should be typed.  Existentials are refined during unification (e.g.\ using the
\lstinline!apply! tactic) in the proof script.  Before the proof script can be finished and saved with the \lstinline!Qed! command, all existential
variables must be bound to values.

The tactic \lstinline!TMSimp! destructs conjunctive assumptions in all hypothesises (i.e.\ logical conjunctions and logical existentials).  It also
names introduced tapes to \lstinline!tmid!, \lstinline!tmid0! etc.  Furthermore, it instantiates and rewrites with hypothesis of the form
$H: \forall j.~ j \notin I \rightarrow tmid0[j] = tmid[j]$, that come from the correctness Lemma~\ref{lem:LiftTapes_Realise} of the tapes-lift
operator.

The tactic \lstinline!modpon H! instantiates assumptions of the form $H: \forall x~\cdots.~P \rightarrow \cdots \rightarrow Q$.  For each premise that
the tactic could not solve automatically, it creates a new subgoal with existentials for the quantified variables.

The tactic \lstinline!repeat TM_Correct! instantiates the existential relation $?R'$ and proves $M \Realise ?R'$.  For that, it applies all
correctness lemmas of the combinators, lifts, value-constructors and deconstructors, and some other auxiliary machines.  It does not apply correctness
lemmas that are parametrised over an encoding function, e.g.\ the correctness Lemma~\ref{lem:CopyValue_Realise}, because the choice of the encoding
functions is semantically relevant.  The user can declare more correctness and runtime lemmas to be used by \lstinline!TM_Correct!.  We use the Coq
plugin \textit{smpl} (see~\cite{SMPL}).  For example, the following code declares the correctness and runtime lemmas of \lstinline!LiftTapes!:

\begin{lstlisting}
Ltac smpl_TM_LiftN :=
  lazymatch goal with
  | [ |- LiftTapes _ _ $\Realise$ _] =>
    apply LiftTapes_Realise; [ smpl_dupfree | ]
  | [ |- LiftTapes _ _ $\Realise$c(_) _] =>
    apply LiftTapes_RealiseIn; [ smpl_dupfree | ]
  | [ |- projT1 (LiftTapes _ _) $\TerminatesIn$ _] =>
    apply LiftTapes_Terminates; [ smpl_dupfree | ]
  end.
Smpl Add smpl_TM_LiftN : TM_Correct.
\end{lstlisting}
The tactic \lstinline!smpl_dupfree! automatically proves that a vector is duplicate-free.


\section{Example Correctness Proof in Coq}
\label{sec:coq-correctness}

We use the general approach how to prove correctness (or runtime) of a Turing machine, as described in Chapter~\ref{chap:compound}: We show
$M \Realise R'$ for some relation $R'$ and it remains to show $R' \subseteq R$.  The first step is done using the tactic
\lstinline!rrepeat TM_Correctr!  For example, consider the following goal (we use the user-defined Coq notation \lstinline!$\Realise$c(9)! to mean
$\RealiseIn{9}$).
\begin{lstlisting}
============================
Add_Step $\Realise$c(9) Add_Step_Rel
\end{lstlisting}
The outline of the proof script is:
\begin{lstlisting}
Proof.
  eapply RealiseIn_monotone.
  { unfold Add_Step. repeat TM_Correct. }
  { cbn. reflexivity. }
  { (* ... *) }
Qed.
\end{lstlisting}

The tactic \lstinline!eapply RealiseIn_monoton! applies Lemma~\ref{lem:Realise_monotone}, and creates \textit{existential} variables $?R'$ and $?k'$.
The tactic generates three goals:
\begin{lstlisting}
3 focused subgoals
(shelved: 2)
  
============================
Add_Step $\Realise$c(?k') ?R'

subgoal 2 is:
 ?k' <= 9
subgoal 3 is:
 ?R' <<=2 Add_Step_Rel
\end{lstlisting}

After focusing the first subgoal, we unfold the definition of \lstinline!Add_Step!:
\begin{lstlisting}
============================
If (LiftTapes MatchNat [|Fin1|])
   (Return (LiftTapes Constr_S [|Fin0|]) None)
   (Return Nop (Some tt)) $\Realise$(?k') ?R'
\end{lstlisting}

The tactic \lstinline!repeat TM_Correct! automatically applies the correctness lemmas of the conditional, tape-lifting, etc.  It instantiates
\lstinline!?R'! to the following relation:
\begin{lstlisting}
?R' := (LiftTapes_Rel [|Fin1|] MatchNat_Rel|_true $\circ$
        ($\bigcup_{f:\Unit}$ LiftTapes_Rel [|Fin0|] S_Rel|_f)||_None)
       $\cup$
       (LiftTapes_Rel [|Fin1|] MatchNat_Rel|_false $\circ$
        ($\bigcup_{f:\Unit}$ Nop_Rel|_f)||_(Some tt))
\end{lstlisting}
It also instantiates
\begin{lstlisting}
?k' := 1 + MatchNat_steps + Nat.max Constr_S_steps 0
\end{lstlisting}
where \lstinline!MatchNat_steps! is the constant number of steps required for $\MS{MatchNat}$ (i.e.\ $5$) and \lstinline!Constr_S_steps! is $3$.  By
simplification, the second goal reduces to \lstinline!9<=9!, which is solved by reflexivity of $\leq$.

The main part of the proof is the third goal.  We prove it with the following proof script:
\begin{lstlisting}
{
  intros tin (yout, tout) H. cbn. intros a b HEncA HEncB.
  cbn in *. destruct H; TMSimp.
  - modpon H. destruct b; auto.
  - modpon H. destruct b; auto.
}
\end{lstlisting}

After the introduction of the variables and hypothesises $tin[0] \simeq a$, $tin[1] \simeq b$, and \lstinline!H: R' tin (yout, tout)!, we make a
case-distinction over $H$ (note that the head-operator in the definition of $R'$ is $\cup$, so $H$ reduces to a disjunction).  This gives two
sub-goals.  In both subgoals, we use the automation tactic \lstinline!TMSimp!.

The first subgoal is:
\begin{lstlisting}
tin, tout, tmid : tapes (boundary + sigNat) 2
H : forall n : nat, tin[@Fin1] $\simeq$ n -> match n with
                               | 0 => False
                               | S n' => tmid[@Fin1] $\simeq$ n'
                               end
H0 : forall n : nat, tin[@Fin0] $\simeq$ n -> tout[@Fin0] $\simeq$ S n
a, b : nat
HEncA : tin[@Fin0] $\simeq$ a
HEncB : tin[@Fin1] $\simeq$ b
H0_0 : tmid[@Fin0] = tin[@Fin0]
H1_0 : tout[@Fin1] = tmid[@Fin1]
============================
match b with
| 0 => False
| S b' => tout[@Fin0] $\simeq$ S a /\ tmid[@Fin1] $\simeq$ b'
end
\end{lstlisting}

In this case, we know that $a$ must be equal to $S~a'$ for some $a'$.  The assumption $H$ is automatically instantiated with $n$ and the proof
$HEncA$.  We finish the goal by case-distinction over $a$.  The second goal is analogous.


Even for complex machines, the correctness proofs in Coq follow this pattern.  It is important to note that the structure of the proof always follows
the structure of the machine.  Runtime proofs are analogous.


\section{Lines of Code}
\label{sec:coq-lines}

In Table~\ref{tab:coq-lines}, we summarise the numbers of Coq code.  We used the tool \texttt{coqwc} to count the lines.%
\todo{This table is \textit{not} complete!}
% XXX: This table excludes:
% - TMTac, ProgrammingTools
\begin{table}[h]
  \centering
  \begin{tabular}{p{7cm}|r|r}
    Module                                    & Spec & Proof\\ \hline
    Libraries (incl. our code)                &  153 & 2638 \\
    Preliminary (incl. $\Loop$ and relations) &  228 &  197 \\
    Definition of Turing machines             &  448 &  180 \\
    Basic Machines                            &  122 &   34 \\
    Combinators                               &  422 &  383 \\
    Lifting                                   &  361 &  193 \\
    Compound Machines                         &  378 &  278 \\
    Value containing                          &  424 &  119 \\
    Copying and writing values                &  411 &  288 \\
    Alphabet-Lift with values                 &  134 &  269 \\
    Deconstructors and constructors           &  492 &  492 \\
    $\MS{MapSum}$                             &   47 &  298 \\
    Addition and Multiplication machines      &  181 &  298 \\
    List functions machines                   &  329 &  456 \\
    Heap Machine Simulator                    &  989 & 1057 \\ \hline\hline
    Total                                     & 7119 & 7180 \\
  \end{tabular}
  \caption{Lines of specification and proof code for the ``modules'' (with several source files)}
  \label{tab:coq-lines}
\end{table}



%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
