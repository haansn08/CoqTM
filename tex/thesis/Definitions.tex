\chapter{Definitions}
\label{chap:definitions}

In this chapter, we will formally define the notion of multi-tape Turing machines.  We take the Definitions of multi-tape Turing machines and their
tapes from Asperti and Ricciotti \cite{asperti2015}.  We introduce notions for specifying the semantics of machines, which are also based on Asperti
and Ricciotti \cite{asperti2015}.  We define basic machines and prove their correctness.


\section{Notational Conventions}
\label{sec:notational-conventions}

We use superscripts ($X^n$) to denote lists of fixed length (also called vectors).  Natural zero-based numbers are used as indexes for vector-access
($x[i]$).  We use the symbols $\Unit$, $\Bool$, $\Type$, $\Prop$, $\Nat$, $\Option(X)$, $X+Y$, and $\List(X)$ for the well-known standard types.
$\sum_{a:A} B$ denote sigma types, i.e.\ dependet pairs, with the projections $\pi_1$ and $\pi_2$.  We write $(a,b)$ for instances of sigma types. For
tuples $A = (a, b, c, \cdots)$, we use subscripts ($a_M$) for the projections.  We usually leave subscripts out if they are clear from the context.
We use the symbols $\None$ and $\Some x$ as instances of the type $\Option(X)$.


\section{Relations}
\label{sec:relations}

We define the semantics of concrete Turing machines in terms of relations.  We use the notation $R \subseteq A \times \cdots \times Z$ to declare a
relation $R \from A \to \cdots \to Z \to \Prop$.  We call relations of the form $R \subseteq A \times B \times A$ \emph{partitioned relations}.  We
use lambda-notation, i.e.\ $\lambda a~\cdots~z.~\cdots$, to define relations.  We write unit-partioned relations $R \subseteq A \times \Unit \times A$
simply as relations $R \subseteq A \times A$.

We use the following standard relational operators:

\begin{definition}[Relational operators]
  Let $R, S \subseteq A \times B$ and $T \subseteq B \times C$.
  \begin{align*}
    R \cap S &:= \lam{x~y}{R~x~y \land S~x~y} \\
    R \cup S &:= \lam{x~y}{R~x~y \lor S~x~y} \\
    R \circ T &:= \lam{x~z}{\exists y.~R~x~y \land S~y~z}
  \end{align*}
\end{definition}

We also have the reflexive transitive closure of binary relations:

\begin{definition}[Kleene star]
  Let $R \subseteq A \times A$.  The relation $R^*$ is defined inductively:
  \[
    \inferrule{ }{R^*~x~x}
    \qquad
    \inferrule{R~x~y \and R^*~y~z}{R^*~x~z}
  \]
\end{definition}

We also have an operator that restricts the partition part of a partitioned relation and yields a binary relation:

\begin{definition}[Relational restriction]
  Let $R \subseteq A \times B \times A$ and $y:B$.
  \[
    R \at b := \lam{x~y}{R~x~y~z}
  \]
\end{definition}



\section{Machines and Tapes}
\label{sec:machine-tapes}

We use the definition of \emph{multi-tape Turing machines} and their semantics from Asperti and Ricciotti~\cite{asperti2015}.

\begin{definition}[Movement]
  \label{def:movement}
  There are three possible movements:
  $$\MS{Move} ::= L ~|~ R ~|~ N.$$
\end{definition}


\begin{definition}[Multi-tape Turing machine]
  \label{def:mTM}
  An \emph{$n$-tape Turing machine} over a finite alphabet $\Sigma$ is a tuple $M = (Q, \delta, start, halt)$ where
  \begin{itemize}
  \item $Q$ is a finite type
  \item $\delta \from Q \times (\Option~\Sigma)^n \to Q \times (\Option~\Sigma \times \MS{Move})^n$
  \item $start:Q$
  \item $halt \from Q \to \Bool$ 
  \end{itemize}
\end{definition}

We write $\MS{TM}_\Sigma^n$ for the type of $n$-tape Turing machines over the alphabet $\Sigma$.

While we parametrised Definition~\ref{def:mTM} over the alphabet $\Sigma$ and the number of tapes $n$, we hide the finite type $Q$ of \emph{states}.
The transition function $\delta$ yields for every state and vector of $n$ read symbols the new state and a vector of $n$ (optional) symbols to write,
and a direction to move.  The read symbols are optional, since it can be the case that there is no symbol under the head of a tape.  $start$ is the
start state of the machine and $halt$ represents the subset of halting states.  Tuples of the type $\Option(\Sigma) \times \Move$ are called
\emph{actions}.  They are refered to with the symbol $\MS{Act}_\Sigma$ or $\MS{Act}$ if $\Sigma$ is clear.  Our machines behave deterministically,
because $\delta$ is a function.

When we want to verify complex machines, we do not want to reason about internal states.  We rather want to reason about partitions of states, e.g.\
positive or negative states.  In general, if $F$ is a finite type, then $M = (M', part)$ is a \emph{partitioned} machine, where $M'$ is an
unpartitioned machine and $part \from Q_M \to F$ the partitioning function.  We write $\MS{TM}_\Sigma^n(F)$ for the type of partioned machines over
$F$\footnote{Formally, it is defined as a sigma type: $\MS{TM}_\Sigma^n(F) := \sum_{M:\MS{TM}_\Sigma^n}\bigl(Q_M \to F\bigr)$}.  We overload the
notation $\MS{TM}_\Sigma^n := \MS{TM}_\Sigma^n(\Unit)$ for machines partitioned over the unit type.  We use the symbol $M$ for both partioned and
unpartitioned machines.  It should however be always clear from the context, whether $M$ is a partitioned or unpartitioned machine.

On a \emph{tape}, arbitrary much memory can be allocated.  However every tape has only finitely many symbols, i.e.\ there is a left-most and a
right-most symbol.  A tape essentially is a triple $(ls,m,rs)$, where the symbol $m$ is the symbol on which the (read/write) head of tape is.  It is
essential that the symbol lists are ordered such that the head of the list is the symbol next to the symbol $m$.  With other words, $ls$ is stored in
reversed order.

There are three cases where there is no current symbol: the tape can be completely empty, or the head can be to the left (or right) outermost of the
non-empty tape.  Formally, tapes are defined inductively:

\begin{definition}[Tape]
  \label{def:tape}
  Let $\Sigma$ be a finite alphabet.  Then $\Tape_\Sigma$ is defined as the inductive type:
  \begin{align*}
    & \Tape_\Sigma := \\
    & \quad | \quad \MS{niltape} \\
    & \quad | \quad \MS{leftof}  ~ (r:\Sigma) ~ (rs:\List(\Sigma)) \\
    & \quad | \quad \MS{midtape} ~ (ls:\List(\Sigma)) ~ (m:\Sigma) ~ (rs:\List(\Sigma)) \\
    & \quad | \quad \MS{rightof} ~ (l:\Sigma) ~ (ls:\List(\Sigma)).
  \end{align*}
\end{definition}

As usual, we leave the subscript $\Sigma$ out, if it is clear from the context.

% We introduce a informal notation of tapes, where the symbols are represented from left to right, hence we have to reverse the lists $ls$.  The
% position of the head is marked by the arrow:
% \begin{align*}
%   \niltape &:= \MS{niltape}\\
%   \leftof{r}{rs} &:= \MS{leftof}~r~rs\\
%   \midtape{ls}{m}{rs} &:= \MS{midtape}~(\rev~rs)~m~rs\\
%   \rightof{ls}{l} &:= \MS{rightof}~(\rev~ls)~l
% \end{align*}

Now we can define the \emph{configuration} of a multi-tape Turing machine.  It is captured by the current state and the vector of the $n$ tapes:
\begin{definition}[Configuration]
  \label{def:config}
  A \emph{configuration} of $M: \TM_\Sigma^n$ is a tuple $c = (q, t)$, where $q: Q_M$ and $t: \Tape_\Sigma^n$.
\end{definition}

% \begin{alignat*}{2}
%   \MS{mv}_R&~(\leftof{r}{R}               &&:= \midtape{\nil}{r}{R} \\
%   \MS{mv}_R&~(\midtape{L}{m}{\nil})       &&:= \rightof{L}{m} \\
%   \MS{mv}_R&~(\midtape{L}{m}{r \cons R)}) &&:= \midtape{L \app [m]}{r}{R} \\
%   \MS{mv}_N&~(t)                          &&:= t
% \end{alignat*}
% The function $\MS{mv}_L$ is defined analogously.
The function $\MS{mv} \from \Move \to \Tape_\Sigma \to \Tape_\Sigma$ moves a tape in a direction.
\begin{definition}[Tape movement]
  \begin{alignat*}{2}
    & \MS{mv}~L~(\MS{leftof}~r~rs)              &&:= \MS{leftof}~r~rs \\
    & \MS{mv}~L~(\MS{midtape}~\nil~m~rs         &&:= \MS{leftof}~m~rs \\
    & \MS{mv}~L~(\MS{midtape}~(l \cons ls)~m~rs &&:= \MS{midtape}~ls~l~(m \cons rs) \\
    & \MS{mv}~L~(\MS{rightof}~l~ls)             &&:= \MS{midtape}~ls~l~\nil \\
    & \MS{mv}~L~(\MS{niltape})                  &&:= \MS{niltape} \\
    & \MS{mv}~R~(\MS{leftof}~r~rs)              &&:= \MS{midtape}~\nil~r~rs \\
    & \MS{mv}~R~(\MS{midtape}~ls~m~\nil         &&:= \MS{rightof}~m~ls \\
    & \MS{mv}~R~(\MS{midtape}~ls~m~(r \cons rs) &&:= \MS{midtape}~(m \cons ls)~r~rs \\
    & \MS{mv}~R~(\MS{rightof}~l~ls)             &&:= \MS{rightof}~l~ls \\
    & \MS{mv}~R~(\MS{niltape})                  &&:= \MS{niltape} \\
    & \MS{mv}~N~t                               &&:= t
  \end{alignat*}
\end{definition}
Note that moving further right (or left) when that tape already is to the right (or left) of the symbols, does not change the tape.

\begin{definition}[$\MS{left}$ and $\MS{right}$]
  The functions $\MS{left},~\MS{right} \from \Tape \to \List(\Sigma)$ return the symbols to the left (or right) side of the pointer.
  \begin{alignat*}{4}
    \MS{left} &~(\MS{niltape})                 &&:= \nil
    \quad\quad\quad\quad
    & \MS{right}&~(\MS{niltape})               &&:= \nil \\
    \MS{left} &~(\MS{leftof}~{r}~{rs})         &&:= \nil
    & \MS{right}&~(\MS{leftof}~{r}~{rs})       &&:= r \cons rs \\
    \MS{left} &~(\MS{midtape}~{ls}~{m}~{rs})   &&:= ls
    & \MS{right}&~(\MS{midtape}~{ls}~{m}~{rs}) &&:= rs \\
    \MS{left} &~(\MS{rightof}~{l}~{ls})        &&:= l \cons ls
    & \MS{right}&~(\MS{rightof}~{l}~{ls})      &&:= \nil
  \end{alignat*}
\end{definition}

% Note that as a consequence of the informal notation, we have
% $$\MS{left}(\midtape{ls}{m}{rs}) = \MS{left}(\MS{midtape}~(\rev{ls})~{m}~{rs}) = \rev{ls}.$$

Now we can define the function $\MS{wr} \from \Tape \to \Option(\Move) \to \Tape$, that writes an optional symbol to a tape.  When we write $\None$,
the tape remains unchanged.  But if we write $\Some a$, we get a $\MS{midtape}$, where the left and right symbols remain unchanged and $a$ is now in
the middle.

\begin{definition}[$\MS{wr}$]
  \begin{alignat*}{3}
    \MS{wr}~t &~ \None   &&:= t \\
    \MS{wr}~t &~ \Some a &&:= \MS{midtape}~(\MS{left}~t)~{a}~(\MS{right}~t)
  \end{alignat*}
\end{definition}

To define the function $\MS{step} \from \MS{Conf} \to \MS{Conf}$, we need to know the symbols on the tapes.
Therefore we define a function $\MS{current} \from Tape \to \Option(\Sigma)$.
It returns $\None$ if the pointer is not under a symbol, and $\Some a$ if the pointer is under the symbol $a$.

\begin{definition}[$\MS{current}$]
  \begin{alignat*}{2}
    \MS{current}&~(\MS{midtape}~{ls}~{m}~{rs})&&:= \Some m \\
    \MS{current}&~\_                          &&:= \None
  \end{alignat*}
\end{definition}

We can state a correctness Lemma of the function $\MS{wr}$:

\begin{lemma}[Correctness of $\MS{wr}$]
  \label{lem:write}
  For all tapes $t$ and symbols $\sigma:\Sigma$:
  % TODO: Align it, for example like in https://tex.stackexchange.com/questions/12771/mix-align-and-enumerate
  \begin{enumerate}
  \item $\MS{right}   (\MS{wr}~t~\Some\sigma) = \MS{right}(t)$
  \item $\MS{left}    (\MS{wr}~t~\Some\sigma) = \MS{left} (t)$
  \item $\MS{current} (\MS{wr}~t~\Some\sigma) = \Some\sigma$
  \end{enumerate}
\end{lemma}
\begin{proof}
  All claims follow by case analysis over $t$.
\end{proof}

We can now define the function $\MS{step} \from \MS{Conf} \to \MS{Conf}$.  First, the machine reads all the currents symbols from the tapes.  It
inserts this vector and the current state into the transition function $\delta$.  Then, each tape writes the symbol and moves its head into the
direction which $\delta$ yielded for it.  The machine ends up in a new step $q'$.

\begin{definition}[$\MS{step}$]
  \label{def:step}
  \begin{alignat*}{2}
    \MS{doAct} &~t~(s, d) &~:=~& \MS{mv}~d~(\MS{wr}~t~s) \\
    \MS{step}  &~(q, t)   &~:=~& \Let{(q', \MS{actions}) := \delta(q, \map{\MS{current}}{t})}{ \\
               &          &~  ~& (q', \maptwo{\MS{doAct}}{\MS{tapes}}{\MS{actions}})}
  \end{alignat*}
\end{definition}

To define the execution of a machine, we first define an abstract recursive \emph{loop} function of the type
$\MS{loop} \from \Nat \to (A \to A) \to (A \to \Bool) \to A \to \Option(A)$, for every $A:\Type$:

\begin{definition}[$\MS{loop}$]
  \begin{align*}
    \MS{loop}~n~f~h~s :=
    \begin{cases}
      \Some{s}                   & h(s) \\
      \None                      & \lnot h(s) \land n = 0 \\
      \MS{loop}~(n-1)~f~h~(f~s)  & \lnot h(s) \land n > 0
    \end{cases}
  \end{align*}
\end{definition}

We can show some basic facts about $\MS{loop}$.
\begin{lemma}[Basic facts about $\MS{loop}$]
  \label{lem:loop}
  Let $f \from A \to A$, $h \from A \to \Bool$, $s:A$, and $k, l:\Nat$.  Then:
  \begin{enumerate}
  \item If $k \le l$ and $\MS{loop}~k~f~h~s = \Some x$, then $\MS{loop}~l~f~h~s = \Some x$.
  \item If $\MS{loop}~k~f~h~s = \Some x$ and $\MS{loop}~l~f~h~s = \Some y$, then $x = y$.
  \item If $\MS{loop}~k~f~h~s = \Some{x}$, then $h(x) = \true$.
  \item If $h~s = \true$, then $\MS{loop}~l~f~h~s = \Some{s}$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Claims 1-3 follow by induction on $k:\Nat$.  Claim 4 follows by Definition.
\end{proof}


We instanciate the abstract $\MS{loop}$ function and get a function $\MS{exec} \from \Tape^n \to \Nat \to \Option(\MS{Conf})$ that executes $k$ steps
of the machine, given initial tapes $t: \Tape_\Sigma^n$:

\begin{definition}[Machine execution]
  \begin{alignat*}{3}
    \MS{initConf}   &~t               &&:= (t, start) \\
    \MS{haltConf}   &~(t, q)          &&:= halt(q) \\
    \MS{loopM}      &~\MS{initc}~k    &&:= \MS{loop}~k~\MS{step}~\MS{haltConf}~\MS{initc} \\
    \MS{exec}       &~\MS{t}~k        &&:= \MS{loopM}~(\MS{initConf}~t)~k
  \end{alignat*}
\end{definition}

We write $M(t) \terminates^k c$ for $\MS{exec}~t~k = \Some{c}$.

All definitions, except partioned machines are from Asperti and Ricciotti \cite{asperti2015}, with similiar names.  However, the $\MS{loop}$ function
was slightly changed for convenience, so that it needs zero steps when the (abstract) state is a halting state.

\section{Specification of Semantics}
\label{sec:spec_semantics}

We have defined big-step semantics for (partitioned) mulit-tape Turing machines.  Now we want to define predicates to specify the semantics of a
concrete (partitioned) machine $M: \TM_\Sigma^n(F)$.  It consists consists of two parts: \emph{correctness} and \emph{runtime}.

The correctness part is captured by \emph{realisation} of a (partitioned) relation $R$:

\begin{definition}[Realisation]
  \label{def:realisation}
  Let $M:\TM_\Sigma^n(F)$ and $R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$.
  \[
    M \vDash R :=
    \forall t~k~q~t'.~M(t) \terminates^k (q, t') \rightarrow
    R~t~(\MS{part}_M~q)~t'
  \]
  Where $\MS{part}_M \from Q_M \to F$ is the partitioning function of $M$.
\end{definition}

If $M \vDash R$, we say that $M$ realises the relation $R$.  Informally, this means that the output of the machine is correct (i.e.\ is in the
relation), if the machine terminates.

The runtime part of the semantics implies termination of the machine on certain inputs.  It also links the input $t:\Tape_\Sigma^n$ to the number of
steps the machine needs for the computation.

\begin{definition}[Termination on a runtime relation]
  \label{def:termination}
  Let $T \subseteq \Tape_\Sigma^n \times \Nat$.
  \[
    M \downarrow T :=
    \forall t~k.~T~t~k \rightarrow
    \exists c.~M \terminates^k c.
  \]
\end{definition}


\begin{lemma}[Monotonicity of $M \vDash R$]
  \label{lem:Realise_monotone}
  If $M \vDash R$ and $R \subseteq R'$, then $M \vDash R'$.
\end{lemma}

\begin{lemma}[Monotonicity of $M \downarrow T$]
  \label{lem:TerminatesIn_monotone}
  If $M \downarrow T$ and $T' \subseteq T$, then $M \downarrow T'$.
\end{lemma}


For machines that always terminate in a constant number of steps, it is useful to combine both predicates:
\begin{definition}[Realisation in constant time]
  \label{def:RealiseIn}
  ~
  \[
    M \vDash^k R :=
    \forall t'.~
    \exists q~t'.~
    M(t) \terminates^k(q, t') \land R~t~(\MS{part}~q)~t'
  \]
\end{definition}

\begin{lemma}[Specification of realisation in constant time]
  \label{lem:Realise_total}
  \[
    M \vDash^k R
    \quad\iff\quad
    M \vDash R ~\land~
    M \downarrow (\lambda \_~i.~k \le i)
  \]
\end{lemma}

\begin{lemma}[Monotonicity of $M \vDash^k R$]
  \label{lem:Realise_monotone}
  If $M \vDash^k R$, $k \leq k'$, and $R \subseteq R'$, then \\
  $M \vDash^{k'} R'$.
\end{lemma}

Asperti and Ricciotti \cite{asperti2015} make a distinction between weak and strong realisation, where the strong version implies termination for
every imput.  We use their weak realisation extended with the finite partition $F$.  They also have no notition of runtime.


\section{Basic Machines}
\label{sec:basic_machines}


We define several classes of \emph{basic} one-tape machines.  All complex machines we will build later, will be based on these basic machines.  In the
next chapter, I will show how to combine these basic machines and build complex machines.


\subsection{Nop}
\label{sec:basic_machines-Nop}

A very simple class of (partitioned) machine is the one-tape $\MS{Nop}$ machine.  It terminates immediately, i.e.\ after 0 steps.  For convenience, We
define $\MS{Nop}$ over a partition $f:F$, i.e.\ all states of $\MS{Nop}$ are mapped into the same partition.  We do this for all basic machines, except
$\MS{Read}$, but there is no real need to do this, since we will introduce a simple operator on partitioned machines that simply changes the partition
in Chapter~\ref{chap:combining}.
\begin{definition}[Nop]
  \label{def:Nop}
  Let $f:F$ be a partition.  $\MS{Nop}~f: \TM_\Sigma^1(F)$ is defined as follows:
  \begin{align*}
    Q          &:= \Unit \\
    start      &:= \unit \\
    \delta ~\_ &:= (\unit, \Vector{(\None, N)}) \\
    halt   ~\_ &:= \true \\
    part   ~\_ &:= f
  \end{align*}
\end{definition}
The correctness relation says exactly that the tapes don't change and that the machine terminates in $f$:
\[
  \MS{NopRel}~f := \lambda~t~y~t'.~ t' = t \land y = f.
\]
\begin{lemma}[Correctness of $\MS{Nop}$]
  \label{lem:Nop_Sem}
  ~
  \[
    \MS{Nop}~f \vDash^0 \MS{NopRel}~f.
  \]
\end{lemma}
\begin{proof}
  By execution.
\end{proof}

\subsection{DoAct}
\label{sec:DoAct}

The next class of machines, $\MS{DoAct}~a~f : \TM_\Sigma^1(F)$, do only one action $a$ and terminates in $f$ after one step.
\begin{definition}[$\MS{DoAct}~a~f$]
  \label{def:DoAct}
  Let $a:\MS{Act}$ and $f:F$.
  \begin{align*}
    Q          &:= \Bool \\
    start      &:= \false \\
    \delta ~\_ &:= (\true, \Vector{a}) \\
    halt   ~ b &:= b \\
    part   ~\_ &:= f
  \end{align*}
\end{definition}
The semantics of $\MS{DoAct}$ is easily expressed using $\MS{doAct}$ (see Definition \ref{def:step}):
\[
  \MS{DoActRel}~a~f := \lambda~t~y~t'.~ t' = \MS{doAct}~t~a \land y = f.
\]

\begin{lemma}[Correctness of $\MS{DoAct}$]
  \label{lem:tam}
  ~
  \[
    \MS{DoAct}~a~f \vDash^1 \MS{DoActRel}~a~f.
  \]

\end{lemma}
\begin{proof}
  By execution.
\end{proof}


We define some abbreviations:

\begin{definition}[Machine classes derived from $\MS{DoAct}$]
 \label{def:DoAct-derived} 

 \begin{align*}
   \MS{Move}       ~d &:= \MS{DoAct} (\None, d) \\
   \MS{Write}    ~s   &:= \MS{DoAct} (\Some{s}, N) \\
   \MS{WriteMove}~s~d &:= \MS{DoAct} (\Some{s}, d)
 \end{align*}
 
\end{definition}



\subsection{Read}
\label{sec:basic_machines-Read}

$Read : \TM_\Sigma^1(\Option(\Sigma))$ is an interesting class of machines.  They have a state for each character of the alphabet.  They read one
symbol and terminate in the state that corresponds to this symbol.  They have a distinct state for the case that the current symbol is $\None$.


\begin{definition}[$\MS{Read}$]
  \begin{align*}
    F          &:= \Option(\Sigma) \\
    Q          &:= \Bool+\Sigma \\
    start      &:= \inl \false \\
    \delta (\_, s) &:=
                     \begin{cases}
                       (\inl \true, \Vector{(\None, N)}) & s[0] = \None \\
                       (\inr c, \Vector{(\None, N)})     & s[0] = \Some c
                     \end{cases} \\
    halt   ~ (\inl  b) &:= b \\
    halt   ~ (\inr \_) &:= \true \\
    part   ~ (\inl  q) &:= \None \\
    part   ~ (\inr  s) &:= \Some s
  \end{align*}
\end{definition}


\[
  \MS{ReadRel} := \lambda~t~y~t'.~ y = \MS{current}~t[0] \land t' = t
\]
\begin{lemma}[Correctness of $\MS{Read}$]
  \label{lem:Read_Sem}
  ~
  \[
    \MS{Read}~f \vDash^0 \MS{NopRel}~f.
  \]
\end{lemma}
\begin{proof}
  Case distinction over $\MS{current t[0]}$.  Both cases by executing the machine one step.
\end{proof}



%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
