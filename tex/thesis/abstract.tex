Turing machines build the traditional foundation of the theory of computation and complexity.  However, concrete Turing machines are often only
scratched out.  Even if authors define the complete Turing machine, they leave the formal invariants to figure out for the reader.  Moreover, it is
common to employ the \textit{Church-Turing thesis}, to (informally) conclude that a function is Turing-computable.  Reasons for that are manifold.
Turing machines are very low-level, because the operations on the tape(s) are primitive.  There are also non-compositional; control-flow operators
like sequential composition and loops are not available.  Reasoning about invariants and concrete machine states is tedious, because the execution of
the machine could continue from one state of the machine to any other state; the set of states may also be huge for complex machines.  It is also a
burden to formally specify tape contents, maybe due to the infinite nature of tapes.  Thus, the formal definition and specification of a machine, its
correctness statement and invariants, are tedious.

In this thesis, we fill these gaps.  We present a framework developed in the theorem prover Coq, in that we can define, specify, and formally verify
multi-tape Turing machines.  Programming Turing machines is not any more tedious in this framework, because it provides abstractions like values and
control-flow operators.  We showcase the power of this framework, by programming and certifying a multi-tape Turing machine that simulates a two-stack
machine for the $\lambda$-calculus.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "thesis"
%%% End:
