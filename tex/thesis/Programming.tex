\chapter{Programming Turing Machines}
\label{chap:programming}

We can define machines using primitive operations like $\MS{DoAct}$, and can combine machines in an imperative programming style.  Furthermore, we can
reuse machines in bigger contexts.  However, our imperative ``language'' still has no notion of values or data cells.  We want to use each tape as a
data cell to store one value.  Therefore, we have to define what it means that a tape contains a value.  When we ``program'' Turing machines, instead
of using basic machines, we only use machines that directly change the value of a tape.  We use the combinators introduced in
Chapter~\ref{chap:combining} to simulate control flow of imperative programming languages.  Using the definition of value-containing, we specify a
``callee-saving'' convention for function computation.  We present a generic pattern how to program and verify Turing machines, and present more
complex case studies.


\section{Value-Containing}
\label{sec:value-containing}

We first want to define what it means that a tape $t$ \emph{contains} a value $x$, written as $t \simeq x$.  Tapes, as defined in
Definition~\ref{def:tape}, are essentially a list of symbols, so we have to linearise values to strings.

\setCoqFilename{FormalComplexity.TM.Code.Code}%
\begin{definition}[Encodable types][codable]
  \label{def:encodable}
  We say that a type $X$ is encodable over a finite alphabet $\Sigma_X$, if there is a function $encode : X \to \List(\Sigma_X)$.
\end{definition}

Morally, the encoding function should be injective.  There should also be a decoding function, such that the pair $(encode, decode)$ is a retraction
on $\List(\Sigma)$.  As we do not need any of these facts, we leave them out of this definition.
% Implementation detail: We implement encodable types as a type class.  We do not include proofs in the type class that the alphabet is finite.  Thus,
% we have to be careful when we define new type class instances.

We can map encodings with retractions:
\begin{definition}[Map encodings][Encode_map]
  \label{def:Encode_map}
  Let $X$ be encodable over $\Sigma$ and $f : \Sigma \hookrightarrow \Tau$ be a retraction.  Then $X$ is also encodable over $\Tau$ with the following
  encoding function:
  \[ encode_\Tau(x) := encodeMap~encode_\Sigma~f~(x) := \map{f}{(encode_\Sigma(x))}. \]
\end{definition}

Mapping of encodings are compatible with composition of retractions.  This means that if we map the encoding twice, this is the same as mapping the
encoding with the composition of both retractions:
\begin{lemma}[Composition and encoding mapping][Encode_map_comp]
  \label{lem:Encode_map_comp}
  Let $f : \Sigma \hookrightarrow \Tau$ and $g : \Tau \hookrightarrow \Delta$ be retractions and $X$ be encodable over $\Sigma$.  Then there is only
  one way how $X$ can be encoded over $\Delta$, i.e.:
  \[ encodeMap~(encodeMap~f~encode)~g~(x) = encodeMap~encode~(f \circ g)~x. \]
\end{lemma}

For each type and type constructor, we have a distinct alphabet.  We define basic encodings:
\begin{definition}[Basic encodings]
  \label{def:basic-encodings}
  ~
  \begin{enumerate}
  \coqitem[Encode_unit] We encode $\Unit$ over the empty alphabet $\False$: $encode~\unit := \nil$
  \coqitem[Encode_fin] The types $\Bool$ and $\Fin_k$ are encoded over themself, i.e.\ $encode(x):=[x]$.
  \coqitem[Encode_option] Let $X$ be encodable over $\Sigma_X$.  Then $\Option(X)$ is encodable over
    \[ \Sigma_{\Option(X)} ::= \MS{NONE} ~|~ \MS{SOME} ~|~ (x:\Sigma_X) \]
    With the retraction $RetrOpt : \Sigma_X \hookrightarrow \Sigma_{\Option(X)}$ and
    \begin{alignat*}{3}
      &encode~&&\None  &~:=~& [\MS{NONE}] \\
      &encode~&&\Some x&~:=~& \MS{SOME} \cons encode(x)
    \end{alignat*}
  \coqitem[Encode_sum] Let $X$ be encodable over $\Sigma_X$ and $Y$ over $\Sigma_Y$.  Then $X+Y$ is encodable over
    \[ \Sigma_{X+Y} ::= \MS{INL} ~|~ \MS{INR} ~|~ (x:\Sigma_X) ~|~ (y:\Sigma_Y) \] With the retractions
    $RetrInl : \Sigma_X \hookrightarrow \Sigma_{X+Y}$, $RetrLft : \Sigma_X \hookrightarrow \Sigma_{X+Y}$ and
    \begin{alignat*}{3}
      &encode~&&(\inl x)&~:=~& \MS{INL} \cons encode(x) \\
      &encode~&&(\inr y)&~:=~& \MS{INR} \cons encode(y)
    \end{alignat*}
  \coqitem[Encode_prod] Let $X$ be encodable over $\Sigma_X$ and $Y$ over $\Sigma_Y$.  Then $X \times Y$ is encodable over
    \[ \Sigma_{X \times Y} ::= (x:\Sigma_X) ~|~ (y:\Sigma_Y) \] With the retractions
    $RetrFst : \Sigma_X \hookrightarrow \Sigma_{X \times Y}$, $RetrSnd : \Sigma_Y \hookrightarrow \Sigma_{X \times Y}$ and
    \[
      encode(x,y) := encode(x) \app encode(y)
    \]
  \coqitem[Encode_list] Let $X$ be encodable over $\Sigma_X$.  Then $\List(X)$ is encodable over
    \[ \Sigma_{\List(X)} ::= \MS{NIL} ~|~ \MS{CONS} ~|~ (x:\Sigma_X) \]
    With the retraction $RetrList : \Sigma_X \hookrightarrow \Sigma_{\List(X)}$ and
    \begin{alignat*}{3}
      &encode~&&(\nil      ) &~:=~& [\MS{NIL}] \\
      &encode~&&(l \cons ls) &~:=~& \MS{CONS} \cons encode(x) \app encode(ls)
    \end{alignat*}
  \coqitem[Encode_nat] Natural numbers $\Nat$ are encodable over $\Sigma_\Nat ::= \MS{S} ~|~ \MS{0} $ with
    \begin{alignat*}{3}
      &encode~&&(0  ) &~:=~& [\MS{O}] \\
      &encode~&&(S~n) &~:=~& \MS{S} \cons encode(n)
    \end{alignat*}
  \end{enumerate}
  Note that we implicitly map the encoding functions in this definition.
\end{definition}

This are all encodings we need.  We say that $X$ is \textit{minimally encodable} over $\Sigma_X$, if $X$ is encodable over $\Sigma_X$ according to
Definition~\ref{def:basic-encodings}.  Mapping of encodings introduces ambiguity: It is not only possible to encode multiple types on the same
alphabet, but there may be several ways how to encode the same type on the same alphabet.  For example, the minimal alphabet of the type $X+X$ is
$\Sigma_{X+X}$.  Now there are two possibilities how to encode $X$ on $\Sigma_{X+X}$: using the retraction $RetrSigX$ and $RetrSigY$.  We must deal
with this problem, when we program and verify Turing machines, by explicitly specifying the right retractions.

If $X$ is encodable over $\Sigma$, we encode values of $x$ on tapes with an extended alphabet $\Sigma^+$ that has an additional start and stop symbol.
\setCoqFilename{FormalComplexity.TM.Code.CodeTM}%
\begin{definition}[$\Sigma^+$][boundary]
  Let $\Sigma$ be an alphabet.
  \[
    \Sigma^+ ::= \MS{START} ~|~ \MS{STOP} ~|~ \MS{UNKNOWN} ~|~ (s: \Sigma)
  \]
  Also, we define the retraction $RetrPlus : \Sigma \hookrightarrow \Sigma^+$.
\end{definition}
The $\MS{UNKNOWN}$ symbol is important later. We define what $t \simeq x$ means:
\begin{definition}[$t \simeq x$][tape_contains]
  \label{def:tape_contains}
  Let $X$ be encodable over $\Sigma$ and $t : \Tape_{\Sigma^+}$.
  \[
    t \simeq x := \exists~ls.~
    t = \MS{midtape}~ls~(\MS{START})~(encode(x) \app [\MS{STOP}])
  \]
  In case the encoding is not clear, we write $t \simeq_f x$ with $t:\Tape_{\Tau^+}$ and $x:X$, when $X$ is minimal encodable on $\Sigma_X$ and
  $f: \Sigma_X \hookrightarrow \Tau$.
\end{definition}

Note that in Definition~\ref{def:tape_contains}, we have to map the encoding of $x$ to the extended alphabet $\Sigma^+$, using $RetrPlus$.  If
$t \simeq x$, the head of $t$ stands on the start symbol.  To the right, there is the encoding terminated by the stop-symbol.  To the left of the
head, there may be arbitrary many ``rest'' symbols.

We find the convention useful, that there are no further symbols beyond the stop symbol.  In future work we also want to reason about space usage of
machines.  If a tape contains a value, the size of the tape (i.e.\ the number of symbols on it), only depends on the length of the encoding and the
number of rest symbols $ls$ to the left.  To avoid data leaks, we have the convention to only add symbols on the left side.  We also only write on
tapes, if the head of the tape is on the right-most symbol.

\begin{definition}[Right tape][isRight]
  \label{def:isRght}
  $isRight(t) := \exists m~rs.~t=\MS{midtape}~ls~m~\nil$.
  With other words, a tape $t$ is right, if and only if $\MS{current}(t) \neq \None \land \MS{right}(t) = \nil$.
\end{definition}

\section{Alphabet-Lifting}
\label{sec:LiftAlphabet-UNKNOWN}

In Section~\ref{sec:sigma-Lift}, we defined the alphabet-lift operator.  However, we noted that we need a semantically \textit{relevant} default
symbol in the smaller alphabet $\Sigma$.  All ``programmed'' Turing machines are defined over an extended alphabet $\Sigma^+$.  It seems therefore
useful, to introduce a uniform default symbol $\MS{UNKNOWN}$ to $\Sigma^+$.  Intuitively, nothing can go wrong, because, by definition, $\MS{UNKNOWN}$
is not part of any encoding.  This intuition is confirmed by the following lemma:
\setCoqFilename{FormalComplexity.TM.Code.ChangeAlphabet}%
\begin{lemma}[$surject$ and value-containing][contains_translate_tau]
  \label{lem:contains_translate_tau}
  Let $f: \Sigma \hookrightarrow \Tau$ be a retraction between two alphabets.  Let $x:X$, where $X$ is encodable over $\Sigma$. Then, for
  $t:\Tape_{\Tau^+}$
  \[
     mapTape~(surject~f)~t \simeq x ~\iff~ t \simeq_f x
  \]
\end{lemma}
Note that the encoding on the right side is mapped with the retraction $f$.

We write $\LiftAlphabet{M}{f}$ for $\LiftAlphabet{M}{(f, \MS{UNKNOWN})}$.  Note that we also use the $\Uparrow$ notation for the tapes-lift.  However,
it is always clear whether we mean the tape-lift or alphabet-lift.  We use the notation $\LiftBoth{M}{f}{I} := \LiftTapes{(\LiftAlphabet{M}{f})}{I}$,
for first applying the alphabet-lift, and after that the tapes-lift.

\section{Value-Manipulating Machines}
\label{sec:value-manipulate}

We have defined what it means that a tape contains a value.  Now we want to define machines that manipulate values, e.g.\ increase or increase a
number.  An also very useful operation is to copy a value from one tape to another tape.

\subsection{Write Value}
\label{sec:WriteValue}

We define a wrapper around the machine class $\MS{WriteString}$ from Section~\ref{sec:WriteString}.  Instead of a string $str : \Sigma^+$, the machine
$\MS{WriteValue}~str : \TM_{\Sigma^+}^1$ gets an encoding $str:\List(\Sigma)$ of a value as parameter%
\footnote{The reason why $\MS{WriteValue}$ is not parametrised over values $x:X$ is, that we would also need to parametrise $\MS{WriteString}$ over
  the encoding function of $X$.  With this approach, only the correctness Lemma~\ref{lem:WriteValue_Sem} is parametrised over the encoding.}%
.
\setCoqFilename{FormalComplexity.TM.Code.WriteValue}%
\begin{definition}[$\MS{WriteValue}$][WriteValue]
  \label{def:WriteValue}
  Let $str:\List(\Sigma)$
  \[
    \MS{WriteValue}(str) := \MS{WriteString}~L~\left(\rev{\left(\MS{START} \cons \map{RetrPlus}{str} \app [\MS{STOP}]\right)}\right).
  \]
\end{definition}
The machine writes the stop symbol, the encoding $str$, and the start symbol in reversed order from right to left.  If it started with a right tape,
then after the execution the tape contains the value $x$ that has the encoding $str$.
\begin{lemma}[Correctness of $\MS{WriteValue}$][WriteValue_Sem]
  \label{lem:WriteValue_Sem}
  Let $X$ be encodable over $\Sigma$ and $str : \List(\Sigma)$.
  \[
    \MS{WriteValue}(str) \RealiseIn{3 + 2 \cdot \length{str}} WriteValueRel(str)
  \]
  \[
    WriteValueRel(str) := \lambda t~t'.~\forall (x:X).~encode(x) = str \rightarrow isRight~t[0] \rightarrow t'[0] \simeq x.
  \]
\end{lemma}


\subsection{Constructors and Deconstructors}
\label{sec:constructors-deconstructors}


For each encodable type $X$, there is a set of machines: constructor and a deconstructor/matching machines.  These are machines over the minimal
alphabet $\Sigma_X^+$.  Constructor machines, informally, ``apply'' a constructor of the inductive type $X$ to the value on the tape $t[0]$.  For
example, considering the inductive type $\Nat$, the constructor machine $\MS{ConstrO}$ writes the number $0$ on a right tape.  The constructor machine
$\MS{ConstrS}$ assumes that $t[0]$ contains a number $n$, and increases that number.  The deconstructor for $\Nat$ reads a number of $t[0]$.  If it is
$0$, it terminates in $\false$.  Else, it decreases the number and terminates in $\true$.  In general, we have a constructor machine for each
constructor of the inductive type.  If the constructor has additional arguments, these are encoded on more input tapes $t[1], t[2], \cdots$.  On the
other side, a deconstructor machine has a partition for each constructor and may have additional tapes for storing additional arguments.

\subsubsection{Natural numbers}
\label{sec:match-nat}

This is the correctness relation for $\MS{MatchNat}$:
\setCoqFilename{FormalComplexity.TM.Code.MatchNat}%
\begin{definition}[Correctness relation of $\MS{MatchNat}$][MatchNat_Rel]
  \label{def:MatchNat_Rel}
  ~
\begin{lstlisting}[style=semicoqstyle]
$MatchNatRel :=$
  $\lambda t~(y, t').~\forall (n:\Nat).~t[0] \simeq n \rightarrow$
    match $y$, $n$
    [$\false$, $O$ => $t'[0] \simeq 0$
    |$\true$, $S~n'$ => $t'[0] \simeq n'$
    | _, _ => $\False$
    ].
\end{lstlisting}
\end{definition}

Note that in the case that $n$ is $0$, we could also write $t'=t$.  However we have the convention, when the tapes not change, to use the weaker
proposition that the tape $t'$ still contains the same values, and that the same tapes are right.  We have to write more, however, when we apply the
alphabet-lift with the retraction $f$, we would otherwise get assumptions like $mapTape~(surject~f)~t' = mapTape~(surject~f)~t$.  This means that we
would have to apply a lemma to show that $t'[0]$ still contains $0$, which we get for free using this convention.

Initially, the tape $t[0]$ contains some number $n$.  So the head of $t[0]$ must be on the start symbol.  The machine moves one step right and reads
the first symbol of the encoding.  This symbol either is $\MS{S}$ or $\MS{O}$.  If the machine reads $\MS{O}$, this means that the number $n$ is $0$,
so the machine moves back to the start symbol and terminates in the partition $\false$, indicating that the number was $0$.  On the other side, if the
machine reads $\MS{S}$, this means the number $n$ is the successor of some number $n'$.  To decrement $n$, it overwrites the current $\MS{S}$ with a
new start symbol and terminates on this symbol in the partition $\true$.

\begin{definition}[$\MS{MatchNat}$][MatchNat]
  \label{def:MatchNat}
  ~
\begin{lstlisting}[style=semicoqstyle]
$\MS{MatchNat} :=$
  $\MS{Move}~R$; 
  Match($\MS{ReadChar}$) 
       ($\lambda(o:\Option(sigNat)).$ match $o$
          [$\Some {\MS{S}}$=>$\Return{(\MS{Write}~\MS{START})}{\true}$
          |$\Some {\MS{O}}$=>$\Return{(\MS{Move}~L)}{\false}$
          |_=>_ 
          ]).
\end{lstlisting}
\end{definition}

Note, that the placeholder $\_$ stands for some unspecified machine, e.g.\ in this case $\Return{\Nop}{b}$ where $b:\Bool$ is arbitrary.  This part of
the machine is not explicitly given, because the premise of the correctness relation of $\MS{MatchNat}$ guaranties that there must be a symbol under
the head that is either $\MS{S}$ or $\MS{O}$, so this part of the machine must never execute.

\begin{lemma}[Correctness of $\MS{MatchNat}$][MatchNat_Sem]
  $\MS{MatchNat} \RealiseIn{5} MatchNatRel$.
\end{lemma}
\begin{proof}
  We know that $t[0] \simeq n$.  This means $t[0] = \MS{midtape}~ls~\MS{START}~(\MS{S}^n \app \MS{O} \cons \MS{STOP})$ for some $ls$.  The proof is
  mechanical, like the above correctness proofs.
\end{proof}

We define the $O$-constructor with $\MS{WriteValue}$:
\begin{definition}[$\MS{ConstrO}$][Constr_O]
  \label{def:Constr_O}
  $\MS{ConstrO} := \MS{WriteValue}~[\MS{O}]$.
\end{definition}
\begin{lemma}[Correctness of $\MS{ConstrO}$][Constr_O_Sem]
  \label{lem:Constr_O_Sem}
  $\MS{ConstrO} \RealiseIn{5} ConstrORel$ with
  \[
    ConstrORel := \lambda t~t'.~isRight~t[0] \rightarrow t'[0] \simeq 0.
  \]
\end{lemma}
\begin{proof}
  With Lemma~\ref{lem:RealiseIn_monotone} and~\ref{lem:WriteValue_Sem}.
\end{proof}

The $S$ constructor overwrites the current symbol (which is the start symbol) with $\MS{S}$ and writes a new start symbol.
\begin{definition}[$\MS{ConstrS}$][Constr_S]
  $\MS{ConstrS} := \MS{WriteMove}~\MS{S}~L \Seq \MS{Write}~\MS{START}$
\end{definition}
\begin{lemma}[Correctness of $\MS{ConstrS}$][Constr_S_Sem]
  $\MS{ConstrS} \RealiseIn{3} ConstrSRel$ with
  \[
    ConstrSRel := \lambda t~t'.~\forall n.~ t[0] \simeq n \rightarrow t'[0] \simeq S~n.
  \]
\end{lemma}


\subsubsection{Sum Types}
\label{sec:match-sum}

Let $X$ be encodable over $\Sigma_X$ and $Y$ over $\Sigma_Y$.  $\MS{MatchSum} : \TM_{\Sigma_{X+Y}^+}^1(\Bool)$ reads a value $s:X+Y$.  If it is
$\inl x$ (or $\inr~y$), it replaces the $\MS{INL}$ (or $\MS{INR}$) symbol with a new start symbol and terminates in $\true$ (or $\false$).

\setCoqFilename{FormalComplexity.TM.Code.MatchSum}%
\begin{definition}[$\MS{MatchSum}$][MatchSum]
  \label{def:MatchSum}
  ~
  \small
\begin{lstlisting}[style=semicoqstyle]
$\MS{MatchSum} :=$
  $\MS{Move}~R$;
  $\Match~\MS{ReadChar}$
       ($\lambda(o:\Option(sigSum~\Sigma_X~\Sigma_Y)).$ match $o$
         [$\Some {\MS{INL}}$=>$\Return{(\MS{Write}~\MS{START})}{\true}$
         |$\Some {\MS{INR}}$=>$\Return{(\MS{Write}~\MS{START})}{\false}$
         |_=>_
         ]).
\end{lstlisting}
\end{definition}

\begin{lemma}[Correctness of $\MS{MatchSum}$][MatchSum_Sem]
  \label{lem:MatchSum_Realise}
  $\MS{MatchSum} \RealiseIn{5} MatchSumRel$ with
\begin{lstlisting}[style=semicoqstyle]
$MatchSumRel :=$
  $\lambda t~(y, t').$ $\forall (s:X+Y).$ $t[0] \simeq s \rightarrow \MS{match}~y,s$
    [$\false$, $\inl x$=>$t'[0] \simeq x$
    |$\true$, $\inr y$=>$t'[0] \simeq y$
    |_,_=>$\False$
    ].
\end{lstlisting}
\end{lemma}

We have one constructor machine for $\inl$ and $\inr$.  They are both analogous.  They overwrite the start symbol with $\MS{INL}$ or $\MS{INR}$ and
write a new start symbol one step further left.
\begin{definition}[$\MS{ConstrInl}$][Constr_inl]
  \label{def:Constr_inl}
  $\MS{ConstrInl} := \MS{WriteMove}~\MS{INL}~L \Seq \MS{Write}~\MS{START}$.
\end{definition}
\begin{lemma}[Correctness of $\MS{ConstrInl}$][Constr_inl_Sem]
  \label{lem:Constr_inl_Sem}
  $\MS{ConstrInl} \RealiseIn{3} ConstrInlRel$ with
  \[
    ConstrInlRel := \lambda t~t'.~\forall(x:X).~t[0] \simeq x \rightarrow t'[0] \simeq \inl x
  \]
\end{lemma}

\subsubsection{Option Types}
\label{sec:match-option}

The types $\Option(X)$ and $X+\Unit$ are isomorphic.  Furthermore, the alphabets to encode these types on, $\Sigma_{\Option(X)}$ and $\Sigma_{X+1}$,
are also isomorphic.  We can use this fact to derive a match machine and constructor machines for the type $\Option(X)$.  Let
$f : \Sigma_{X+\Unit} \hookrightarrow \Sigma_{\Option(X)}$ be the canonical retraction.  Then, we can define $\MS{MatchOption}$ as
$\LiftAlphabet{\MS{MatchSum}}{f}$.  However, in the case that $o=\None$, the surjected output tape $t'$ contains $\unit$.  Thus, the tape has form
$t' = \MS{midtape}~ls~\MS{START}~[\MS{STOP}]$ (for some $ls$).  However, we want that the tape is right in this case.  That is, because $\Option(X)$
is not a recursive data type and the information that $o=\None$ is already encoded in the partition in which $\MS{MatchOption}$ terminates.  So in
this case, the tape moves one step to the right:
\begin{definition}[$\MS{MatchOption}$][MatchOption]
  \label{def:MatchOption}
  ~
  \[
    \MS{MatchOption} := \If{\LiftAlphabet{\MS{MatchSum}}{f}}{\Return{\Nop}{\true}}{\Return{(\MS{Move}~R)}{\false}}.
  \]
\end{definition}

\begin{lemma}[Correctness of $\MS{MatchOption}$][MatchOption_Sem]
  \label{lem:MatchSum_Realise}
  $\MS{MatchOption} \RealiseIn{7} MatchOptionRel$ with
\begin{lstlisting}[style=semicoqstyle]
$MatchOptionRel :=$
  $\lambda t~(y, t').$ $\forall (o:\Option(X)).$ $t[0] \simeq o \rightarrow \MS{match}~y, o$
    [$\false$, $\None$     =>$isRight(t'[0])$
    |$\true$, $\Some x$=>$t'[0] \simeq x$
    |_,_=>$\False$
    ].
\end{lstlisting}
\end{lemma}
Note that we have to add $2$ extra steps: one for the conditional and one for the $\MS{Move}$ in the $\None$-case.

We can also derive the $\Some{\cdot}$ constructor of $\Option(X)$ from the $\inl$ constructor of $X+\Unit$.
\begin{definition}[$\MS{ConstrSome}$][Constr_Some]
  \label{def:Constr_Some}
  $\MS{ConstrSome} := \LiftAlphabet{\MS{ConstrInl}}{f}$.
\end{definition}
\begin{lemma}[Correctness of $\MS{ConstrSome}$][Constr_Some_Sem]
  \label{lem:Constr_Some_Sem}
  $\MS{ConstrSome} \RealiseIn{3} ConstrSomeRel$ with
  \[
    ConstrSomeRel := \lambda t~t'.~\forall(x:X).~t[0] \simeq x \rightarrow t'[0] \simeq \Some{x}
  \]
\end{lemma}
For the $\None$ constructor, we simply use $\MS{WriteValue}$
\begin{definition}[$\MS{ConstrNone}$][Constr_None]
  \label{def:Constr_None}
  $\MS{ConstrNone} := \MS{WriteValue}~[\MS{NONE}]$.
\end{definition}
\begin{lemma}[Correctness of $\MS{ConstrNone}$][Constr_None_Sem]
  \label{lem:Constr_None_Sem}
  $\MS{ConstrNone} \RealiseIn{3} ConstrNoneRel$ with
  \[
    ConstrNoneRel := \lambda t~t'.~isRight~t[0] \rightarrow t'[0] \simeq \None
  \]
\end{lemma}


\subsubsection{Product Types}
\label{sec:MatchPair}

The deconstructor and constructor machines for product types have to explicitly copy parts of values.  Thus, their runtime depends on the value.  We
use the machines $\MS{MoveToSymbol}$ and $\MS{CopySymbols}$.

Let $X$ and $Y$ be encodable on $\Sigma_X$ and $\Sigma_Y$.  The deconstructor $\MS{MatchPair} : \TM_{\Sigma_{X \times Y}^+}^2$ copies the first
component of the pair $p:X \times Y$ to tape~$1$, the second component remains on tape~$0$.  The machine works as follows: first it writes the stop
symbol on tape~$1$.  Then, it seeks the last character of the encoding of $\pi_1(p)$, writes a stop symbol on tape~$1$, copies this (including the
start symbol) from right to left to tape~$1$.  Then it moves again to the last symbol of the original encoding of $\pi_1(p)$ on tape~$0$, and
overwrites it with a new start symbol.

\setCoqFilename{FormalComplexity.TM.Code.MatchPair}%
\begin{definition}[$\MS{MatchPair}$][MatchPair]
  \label{def:MatchPair}
  ~
  \begin{alignat*}{2}
    &\MS{MatchPair}&~:=~& \LiftTapes{(\MS{WriteMove}~\MS{STOP}~L)}{\Vector{1}} \Seq \\
    &              &    & \LiftTapes{(\MS{MoveToSymbol}~f~id \Seq \MS{Move}~L)}{\Vector{0}} \Seq \\
    &              &    & \MS{CopySymbolsL}~g\Seq \\
    &              &    & \LiftTapes{(\MS{MoveToSymbol}~f~id \Seq \MS{Move}~L \Seq \MS{Write}~\MS{START})}{\Vector{0}}
  \end{alignat*}
  Where $f : \Sigma_{X \times Y}^+ \to \Bool$ is true for symbols that are mapped from the alphabet $\Sigma_Y$.  $g(s)$ is $\true$ if and only if
  $s=\MS{START}$.
\end{definition}

The correctness and termination proofs of $\MS{MatchPair}$ are quite technical.  We have lemmas about the tape-functions of $\MS{CopyValueL}$,
$\MS{MoveToSymbol}$, and the respective runtime functions.  However, it is interesting to note that we have to do a case-distinction, whether
$\pi_2(p)$ is empty.  If it is empty, then the first $\MS{MoveToSymbol}~f~id$ moves to the stop symbol.  If it is not empty, it moves to the first
symbol of the encoding of $\pi_2(p)$.  In both cases, $\MS{Move}~L$ moves to the last symbol of $\pi_1(p)$ (or to the start symbol, if $\pi_1(p)$ is
empty).

\begin{lemma}[Correctness of $\MS{MatchPair}$][MatchPair_Realise]
  \label{lem:MatchPair_Realise}
  $\MS{MatchPair} \Realise MatchPairRel$ with
  \small
  \[
    MatchPairRel := \lambda t~t'.~\forall (p: X \times Y).~t[0] \simeq p \rightarrow isRight~t[1] \rightarrow t'[0] \simeq \pi_2(p) \land t'[1] \simeq \pi_1(p).
  \]
\end{lemma}
\begin{lemma}[Runtime of $\MS{MatchPair}$][MatchPair_Terminates]
  \label{lem:MatchPair_TerminatesIn}
  $\MS{MatchPair} \TerminatesIn MatchPairT$ with
  \[
    MatchPairT := \lambda t~k.~\exists (p: X \times Y).~t[0] \simeq p \land 34 + 16 \cdot \size{\pi_1(p)} \leq k.
  \]
\end{lemma}

The constructor copies the first component $x$ from tape $0$ to tape $1$, which initially contains the second component $y$, from right to left.  By
that, it overwrites the start symbol on tape $1$ with the last symbol of the encoding of $x$.

\begin{definition}[$\MS{ConstrPair}$][Constr_pair]
  \label{def:Constr_pair}
  ~
  \[
    \MS{ConstrPair} := \LiftTapes{(\MS{MoveToSymbol})}{\Vector{0}}~h~id \Seq \MS{CopySymbolsL}~g
  \]
  Where $g$ is the same function as in Definition~\ref{def:MatchPair}.  $h(s)$ is $\true$ if and only if $s=\MS{STOP}$.
\end{definition}

\begin{lemma}[Correctness of $\MS{ConstrPair}$][Constr_pair_Realise]
  \label{lem:Constr_pair_Realise}
  \small
  $\MS{ConstrPair} \Realise ConstrPairRel$ with
  \[
    ConstrPairRel := \lambda t~t'.~\forall (x:X)~(y:Y).~t[0] \simeq x \rightarrow t[1] \simeq y \rightarrow t'[0] \simeq x \land t'[1] (x,y).
  \]
\end{lemma}
\begin{lemma}[Runtime of $\MS{ConstrPair}$][Constr_pair_Terminates]
  \label{lem:Constr_pair_TerminatesIn}
  $\MS{ConstrPair} \TerminatesIn ConstrPairT$ with
  \[
    ConstrPairT := \lambda t~k.~\exists (x: X).~t[0] \simeq x \land 19 + 12 \cdot \size{x} \leq k.
  \]
\end{lemma}

\subsubsection{List Types}
\label{sec:MatchList}
\setCoqFilename{FormalComplexity.TM.Code.MatchList}%

The definition of $\MS{MatchList}$ is quite complex.  For brevity we only state the correctness statements of the match-machine here.  The machine
$\MS{MatchList} : \TM_{\Sigma_{\List(X)}^+}^2(\Bool)$ expects a list on tape $0$.  If it is $\nil$, it terminates in the partition $\false$ and leaves
the tapes unchanged.  If the list is $x \cons xs$, it copies $x$ to tape $1$ and removes $x$ from tape $0$, and terminates in the partition $\true$.

\begin{lemma}[Correctness of $\MS{MatchList}$][MatchList_Realise]
  \label{lem:MatchList_Realise}
  $\MS{MatchList} \Realise MatchListRel$ with
\begin{lstlisting}[style=semicoqstyle]
$MatchListRel :=$
  $\lambda t~(y, t').~\forall (l:\List(X)).~t[0] \simeq l \rightarrow isRight~t[1] \rightarrow \MS{match}~y, l$
    [$\false, \nil$ => $t'[0] \simeq \nil \land isRight~t'[1]$
    |$\true, x \cons xs$ => $t'[0] \simeq xs \land t'[1] \simeq x$
    |_,_ => $\False$
    ].
\end{lstlisting}
\end{lemma}

The $\nil$ constructor is defined using $\MS{WriteValue}$.
\begin{definition}[$\MS{ConstrNil}$][Constr_nil]
  $\MS{ConstrNil} := \MS{WriteValue}~[\MS{NIL}]$.
\end{definition}
\begin{lemma}[Correctness of $\MS{ConstrNil}$][Constr_nil_Sem]
  $\MS{ConstrNil} \RealiseIn{5} ConstrNilRel$ with
  \[
    ConstrNilRel := \lambda t~t.~isRight~t[0] \rightarrow t'[0] \simeq \nil
  \]
\end{lemma}

The $\cons$ constructor machine $\MS{ConstrCons}$ expects a list on tape $0$ and a value $x:X$ on tape $1$.  It moves the head of tape $1$ to the last
symbol of the encoding of $x$ and copies them on tape $0$ from right to left.  Thereby, it overwrites the current start symbol on tape $1$, but also
copies the start symbol from tape $1$ to tape $0$.  After that, the machine overwrites this start symbol with $\MS{CONS}$ and writes a new start
symbol on tape $0$.

\begin{definition}[$\MS{ConstrCons}$][Constr_cons]
  \label{def:Constr_cons}
  \begin{alignat*}{2}
    &\MS{ConstrCons}&~:=~& \LiftTapes{(\MS{MoveToSymbol}~h~id \Seq \MS{Move}~L)}{\Vector{1}} \Seq \\
    &               &    & \LiftTapes{(\MS{CopySymbolsL~h'})}{\Vector{1;0}} \Seq \\
    &               &    & \LiftTapes{(\MS{WriteMove}~\MS{CONS}~L \Seq \MS{Write}~\MS{START})}{\Vector{0}}
  \end{alignat*}
  With $h, h' : \Sigma_{List(X)}^+ \to \Bool$ such that $h(s)=\true$ if and only if $s=\MS{STOP}$, and $h'(s)=\false$ if and only if $s$ is mapped
  from the alphabet $\Sigma_X$.
\end{definition}

\begin{lemma}[Correctness of $\MS{ConstrCons}$][Constr_cons_Realise]
  \label{lem:Constr_cons_Realise}
  $\MS{ConstrCons} \Realise ConstrConsRel$ with
  \begin{align*}
    & ConstrConRel := \\
    & \quad \lambda t~t'.~\forall (xs:\List(X))~(x:X).~t[0] \simeq xs \rightarrow t[1] \simeq x \rightarrow t'[0] \simeq x \cons xs \land t'[1] \simeq x.
  \end{align*}
\end{lemma}


\subsubsection{Finite Types}

All finite types $\Sigma$ can be encoded on themself, i.e.\ $encode(x)=[x]$ for $x:\Sigma$.  The deconstructor machine for finite types moves the head
from the starting symbol to the symbol and reads it.  After that, it moves the head one further so that the tape is right and terminates in the
partition corresponding to the read symbol.

\setCoqFilename{FormalComplexity.TM.Code.MatchFin}%
\begin{definition}[$\MS{MatchFin}$][MatchFin]
  \label{def:MatchFin}
  Let $def:\Sigma$.
  \small
\begin{lstlisting}[style=semicoqstyle]
$\MS{MatchFin} := \Match~\MS{ReadChar}~(\lambda s.$ $\MS{match}~s$[$\Some{x} \Rightarrow \Return{(\MS{Move}~R)}{x}$|_$\Rightarrow\Return{\Nop}{def}$].
\end{lstlisting}
\end{definition}

\begin{lemma}[Correctness of $\MS{MatchFin}$][MatchFin_Sem]
  \label{lem:MatchFin_Sem}
  $\MS{MatchFin} \RealiseIn{5} MatchFinRel$ with
  \[
    MatchFinRel := \lambda t~(y,t').~\forall(x:\Sigma).~t[0] \simeq x \rightarrow isRight~t'[0] ~\land~ y=x.
  \]
\end{lemma}




\subsection{Copy Values}
\label{sec:copy}

In Section~\ref{sec:CopySymbols}, we defined a machine that copies symbols until a certain symbol from one tape to another tape.  In
Section~\ref{sec:MoveToSymbol}, we also defined a machine that moves the head to a certain symbol.  We want to use these machines to define a machine
that copies a value from tape $t[0]$ on tape $t[1]$.  By the convention we set up in Section~\ref{sec:value-containing}), if we write new symbols on a
tape, this tape must be right.  With other words, the machine $\MS{CopySymbols}$ can assume that the ``target'' tape is right.  Formally, the
correctness relation is defined as:
\setCoqFilename{FormalComplexity.TM.Code.Copy}%
\begin{definition}[Correctness relation of $\MS{CopyValue}$][CopyValue_Rel]
  \label{def:CopyValue_Rel}
  ~
  \[
    CopyValueRel := \lambda t~t'.~\forall (x:X).~t[0] \simeq x \rightarrow isRight~t[1] \rightarrow t'[0] \simeq x \land t'[1] \simeq x.
  \]
% \begin{lstlisting}[style=semicoqstyle]
% CopyValueRel :=
%   $\lambda t~t.\forall (x:X).$
%     $t[0] \simeq x \rightarrow$
%     $isRight t[1] \rightarrow$
%     $t'[0] \simeq x \land$
%     $t'[1] \simeq x.$
% \end{lstlisting}
\end{definition}

The algorithm of $\MS{CopyValue}$ works as follows.  First, the machine moves the head of tape $0$ right, from the start symbol to the stop symbol.
Then it copies the symbols, from the stop symbol to the start symbol, to tape $1$.

\begin{definition}[$\MS{CopyValue}$][CopyValue]
  \label{def:CopyValue}
  ~
  \small
  \[
    \MS{CopyValue} := \LiftTapes{(\MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~~id)}{\Vector{0}} \Seq \MS{CopySymbolsL}~(\lambda x.~x=\MS{START})
  \]
\end{definition}

Note that the second parameter of $\MS{MoveToSymbol}$ is the a translation function.  In this case, it should simply move around leave the symbols
unchanged.

\begin{lemma}[Correctness of $\MS{CopyValue}$][CopyValue_Realise]
  \label{lem:CopyValue_Realise}
  $\MS{CopyValue} \Realise CopyValueRel$.
\end{lemma}

The runtime of $\MS{CopyValue}$ is linear in size of the encoding of $x$.
\begin{lemma}[Runtime of $\MS{CopyValue}$][CopyValue_TerminatesIn]
  \label{lem:CopyValue_TerminatesIn}
  ~
  \[
    \MS{CopyValue} \TerminatesIn (\lambda t~k.~\exists(x:X).~t[0] \simeq x \land 25 + 12 \cdot \size{x} \leq k).
  \]
\end{lemma}

Although $\MS{CopyValue}$ terminates for all tapes, we restricted runtime relations to reasonable tapes, i.e.\ in this case tape vectors $t$ that
actually have a symbol on $t[0]$.  The reason for that is, that we want to relate the value to the runtime.

\subsection{Translate Values}
\label{sec:Translate}

In Section~\ref{sec:value-containing}, we observed, that the containing relation is ambiguous: if $X$ is minimally encodable over $\Sigma$, there may
be two retractions $f_1, f_2 : \Sigma \hookrightarrow \Tau$ on the alphabet $\Tau$.  In Section~\ref{sec:MoveToSymbol}, we gave the
$\MS{MoveToSymbol}$ machine the feature to translate the symbols it read.  Using this feature, we define a machine that translates between the two
possibilities of the encoding of $X$ on $\Tau$.  Therefore we have to define a function $tanslate : \Tau^+ \to \Tau^+$.

\begin{definition}[Translation between two encodings][translate]
  \label{def:translate}
  Let $f_1, f_2 : \Sigma \hookrightarrow \Tau$ be two retractions on $\Tau$.
  \begin{alignat*}{2}
    & translate~f_1~f_2~(\tau) &~:=~& \tau \qquad\text{(if $\tau \in \{\MS{UNKNOWN}, \MS{START}, \MS{STOP}\}$)} \\
    & translate~f_1~f_2~(\tau) &~:=~&
    \begin{cases}
      f_2(\sigma)  & f_1^{-1}(\tau) = \Some{\sigma} \\
      \MS{UNKNOWN} & f_1^{-1}(\tau) = \None
    \end{cases}
  \end{alignat*}
\end{definition}

This function translates a symbol of $\Tau$ to $\Sigma$, using the partial inversion function $f_1^{-1}$ and afterwards applies the injection $f_2$
from $\Sigma$ to $\Tau$ and the (implicit) injection from $\Tau$ to $\Tau^+$.

\begin{definition}[$\MS{Translate}$][Translate]
  ~
  \begin{alignat*}{2}
    & \MS{Translate}~f_1~f_2 &~:=~& \MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~(translate~f_1~f_2) \Seq \\
    &                        &~  ~& \MS{MoveToSymbolL}~(\lambda x.~x=\MS{START})~id.
  \end{alignat*}
\end{definition}

\begin{lemma}[Correctness of $\MS{Translate}$][Translate_Realise]
  $\MS{Translate}~f_1~f_2 \Realise TranslateRel~f_1~f_2$ with
  \[
    TranslateRel~f_1~f_2 := \lambda t~t'.~\forall(x:X).~t[0] \simeq_{f_1} x \rightarrow t[0] \simeq_{f_2} x.
  \]
\end{lemma}


\subsection{Reset Tapes}
\label{sec:reset-tape}

The aforementioned machine $\MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~id$ can also be used to ``reset'' a tape.  This means that if the tape contains
a value, after the execution of this machine, the tape is right.  This is especially important to prevent memory leaks in loops, where we may want to
write on a tape multiple times.  We must reset each ``used'' tape before writing on it again.

\begin{definition}[$\MS{ResetTape}$][Reset]
  \label{def:Reset}
  $\MS{ResetTape} := \MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~id$
\end{definition}

\begin{lemma}[Correctness of $\MS{ResetTape}$][Reset_Realise]
  \label{lem:Reset_Realise}
  $\MS{ResetTape} \Realise ResetTapeRel$ with
  \[
    ResetTapeRel := \lambda t~t'.~\forall(x:X).~t[0] \simeq x \rightarrow isRight(t'[0]).
  \]
\end{lemma}


\section{Extending Alphabets}
\label{sec:extend-alphabet}

Consider that we have machines $M_1 : \TM_{\Sigma_X^+}^n, M_2 : \TM_{\Sigma_Y^+}^n$ that operate on values of type $X$ and $Y$, where $X$ is encodable
over $\Sigma_X$ and $Y$ over $\Sigma_Y$.  Then, we could combine this machines using sequential composition and the alphabet-lift and tapes-lift, to a
machine $M : \TM_{\Sigma^+}^n$.  However, the choice of $\Sigma$ is relevant.  For example, we could choose $\Sigma := \Sigma_X + \Sigma_Y$.
If another machine $M' : \TM_{\Sigma'^+}^n$ uses $M$, it has to give a retraction $f : \Sigma_X+\Sigma_Y \hookrightarrow \Sigma'$.  However, there is
a problem of generality:
\begin{fact}
  There exists types $X,Y,Z:\Type$ with retractions $f_1 : X \hookrightarrow Z$ and $f_2 : Y \hookrightarrow Z$, such that there is no retraction
  $(f_1+f_2) : X+Y \hookrightarrow Z$.
\end{fact}
\begin{proof}
  There is no injective function $\Unit+\Unit\to\Unit$.
\end{proof}

That means that we would have to show a precondition to combine two retractions $f_1 : \Sigma_X \hookrightarrow \Sigma'$ and
$f_2 : \Sigma_Y \hookrightarrow \Sigma'$ and get a retraction $f_1+f_2 : \Sigma_X + \Sigma_Y \hookrightarrow \Sigma'$:
\begin{fact}
  If the retractions $f_1 : X \hookrightarrow Z$ and $f_2 : Y \hookrightarrow Z$ have disjoint images, then we can define a retraction
  $f_1+f_2 : X+Y \hookrightarrow Z$.
\end{fact}

We could live with the restriction that we have to show that the retractions have disjoint images.  However, this approach does not scale good when we
have to add more alphabets and retractions, we have to show that all retractions have disjoint images.  It seems to be easier and more general, to
define a class of machines $M$ parametrised over the alphabet $\Sigma'$ and the two retractions $f_1$ and $f_2$.  In the definition of $M$, we apply
the tapes-lift on $M_1$ and $M_2$ with the retractions $f_1$ and $f_2$.



\section{Designing Machines}
\label{sec:programming-design}

As noted above, when we speak of ``programming'' Turing machines, we mean that we use tapes as registers, and use the combinators and lifting
operators to compose machines.  Moreover, we only use machines that directly change the values of registers (tapes).  We have machines that do a
case-distinction on values, and machines that apply constructors to the value that a tape contains.

Our $\While$ operator corresponds to ``do-while'' in imperative languages, i.e.\ the machine $M$ has to decide at the end of its execution whether to
continue or break out of the loop.  Tail-recursive functions can easily be transformed into ``do-while'' loops.  Therefore, when we translate
functions to Turing machines, we first have to implement the function as a tail-recursive function, which is then translated to a Turing machine in
``programming style''.

The ``matching'' machines do a case-distinction over the value on a tape.  They may alter the content of the tape.  Therefore, if we use ``matching''
machines inside a loop, we can not restore the value of the tape before the loop.  We have to copy the value of the tape and only work on the copy.
After that, the ``internal tape'' is reseted, so we can use the tape again without a memory leak.

% When we define and prove the semantical properties machines, we break the machine down to parts and verify each part independently.  For example, if
% we have a machine $\While~\MS{Step}$, then we first have to encode the loop-invariant into the relation $StepRel$.

We make an informal distinction between input, output, and internal tapes.  Each kind of tapes have an invariant, which is encoded in the correctness
relations of machines.  For input tapes, we have the invariant that they contain a value, and this value does not change during the execution.  Output
tapes are initially right, and contain an output value after the execution.  Internal tapes are right before and after the execution.  With this
distinction of input, output, and internal tapes, we can formalise a convention for functional computation of binary functions: Tapes $t[0]$ and
$t[1]$ are input tapes for $x$ and $y$, $t[2]$ is the output tape for $f~x~y$, and all other tapes are internal tapes.
\setCoqFilename{FormalComplexity.TM.Code.CodeTM}%
\begin{definition}[Functional computation correctness relation][Computes2_Rel]
  \label{def:Computes2_Rel}
  Let $f : X \to Y \to Z$, where $X$ and $Y$ are encodable on $\Sigma$.  Then
  $FunRel(f) \subseteq \Tape_{\Sigma^+}^{3+n} \times \Tape_{\Sigma^+}^{3+n}$ is defined as:
  \begin{alignat*}{2}
     FunRel(f) &:= \lambda t~t'.~\forall (x:X)~(y:Y). \\
    &\qquad t[0] \simeq x \rightarrow t[1] \simeq y \rightarrow \\
    &\qquad isRight~t[2] \rightarrow \\
    &\qquad \left(\forall (i:\Fin_n).~isRight~t[3+i] \right) \rightarrow \\
    &\qquad t[0] \simeq x ~\land~ t[1] \simeq y ~\land~ \\
    &\qquad t[2] \simeq f~x~y ~\land~ \\
    &\qquad \left(\forall (i:\Fin_n).~isRight~t'[3+i] \right).
  \end{alignat*}
  We say that a machine $M$ computes the function $f$, if $M \Realise FunRel~f$.
\end{definition}

Similarly, we can define the runtime function of such a machine.
\begin{definition}[Functional computation runtime relation][Computes2_T]
  \label{def:Computes2_T}
  Let $steps : X \to Y \to \Nat$ , where $X$ and $Y$ are encodable on $\Sigma$.  Then $FunT(h) \subseteq \Tape_{\Sigma^+} \times \Nat$ is defined as:
  \begin{alignat*}{2}
     FunT(steps) &:= \lambda t~k.~\exists (x:X)~(y:Y). \\
    &\qquad t[0] \simeq x ~\land~ t[1] \simeq y ~\land~ \\
    &\qquad isRight~t[2] ~\land~ \\
    &\qquad \left(\forall (i:\Fin_n).~isRight~t[3+i] \right) ~\land~ \\
    &\qquad steps~x~y \leq k
  \end{alignat*}
\end{definition}

Note that these definitions can be generalised to unary functions or functions with higher arity.  Also note that the preconditions encoded within
$FunRel(f)$ and \\
$FunT(steps)$ coincide, however, with swapped quantifiers.

Internal tapes may be used to copy input-values on, if their value changes in the loop.  The general design for implementing a machine $M$ that
computes a binary function $f$, is the following:
\begin{align*}
  M := & \LiftTapes{\MS{CopyValue}}{\Vector{0; 3}} \Seq \LiftTapes{\MS{CopyValue}}{\Vector{1; 4}} \Seq \\
       & \LiftTapes{\MS{WriteValue}~\cdots}{\Vector{\cdots}} \Seq \\
       & \LiftTapes{\MS{Loop}}{\Vector{3; 4; 2; 5; 6; 7; \cdots}} \Seq \\
       & \LiftTapes{\MS{Reset}}{\Vector{3}} \Seq \LiftTapes{\MS{Reset}}{\Vector{4}} \Seq \LiftTapes{\MS{Reset}}{\Vector{5}} \Seq \cdots
\end{align*}
with $\MS{Loop} := \While(\MS{Step})$.  $\MS{Step}$ is partitioned over $\Option(\Unit)$, $\Some\unit$ means to break out of the loop and $\None$ to
continue.  Note that $\MS{Step}$ and $\MS{Loop}$ have only ``access'' to the copies of $x$ and $y$, but not to the ``original'' on $t[0]$ and $t[1]$
of $M$.  This also means that $\MS{Step}$ has two tapes less than $M$.  The copy of $x$ and $y$ is on the $0$st and $1$st tape of $\MS{Step}$, the
output is on tape $2$, all further tapes are internal tapes.  Before the loop, some tapes may be initialised with values.  After the loop, all tapes
that $\MS{Step}$ did not reset, including the tapes to contain the copies of $x$ and $y$ and additional tapes, are reseted by $M$.

Before we can define the machine $M$, we first have to decide on which alphabet $M$ is defined.  If the machine operates on only one data type, then
we define $M$ over the smallest alphabet to encode this type on.  On the other hand, if $M$ operates on more alphabets, we use the technique in
Section~\ref{sec:extend-alphabet}.

For the verification of $M$, we first have to give the correctness relation of $\MS{Step}$.  It should encode the loop invariant as general as
possible.  Then we can define the correctness relation $LoopRel$ of $\MS{Loop}$ and prove $\MS{Loop} \Realise LoopRel$.  After that, we define runtime
relations $StepT$ and $LoopT$, and show $\MS{Step} \TerminatesIn StepT$, and after that $\MS{Loop} \TerminatesIn LoopT$.  Finally, we prove
$M \Realise FunRel(f)$ and $M \TerminatesIn FunT(steps)$, where $f:X \to Y \to Z$ is the function that $M$ computes and $steps:X \to Y \to \Nat$ the
runtime function.


\section{Case Studies}
\label{sec:case-studies}

We implement the general design of the previous section for concrete functions.

\subsection{Addition}
\label{sec:Add}
\setCoqFilename{FormalComplexity.TM.Code.NatTM}%

We want to implement the functions $add,mult:\Nat\to\Nat\to\Nat$, according to Definition~\ref{def:Computes2_Rel}.  First we define the machine
$\MS{Add}$ that computes the addition function.  We reuse this machine to implement a machine $\MS{Mult}$ that computes the multiplication function.

The algorithm that our machine implements can be described with in the following pseudocode:
{
  \small
\begin{lstlisting}[style=pseudocode]
a := n
b := m
While (b--) {
  a++
}
Reset b
\end{lstlisting}
}%
The output tape is the tape that is represented by the variable $a$.  First, we copy the input $n$ to this tape, and the number $m$ to an internal
tape.  In the loop, as long as we can decrease the copy of $m$, we increment $a$.  After the loop, we reset the copy $b$ and the machine terminates.
The first step in the design of the machine is to specify, which tape contains which variable.  This is visualised in Table~\ref{tab:tapes-Add}.

\begin{table}[h]
  \centering
  \begin{tabular}{l|l|l|l}
     Tape of $\MS{Add}$ & Variable & Role      & Tape in $\MS{AddStep}$ \\ \hline
     $0$                & $m$      & Input     & --                     \\
     $1$                & $n$      & Input     & --                     \\
     $2$                & $a$      & Output    & $0$                    \\
     $3$                & $b$      & Internal  & $1$                    \\
  \end{tabular}
  \caption{Tape assignment for $\MS{Add}$ and $\MS{AddStep}$}
  \label{tab:tapes-Add}
\end{table}

Because the machine only works on natural numbers, we choose $\Sigma_\Nat$ as the alphabet of $\MS{Add}$ and all its sub-machines.

The next step is to implement the step machine.  $\MS{AddStep}$ has only access to the variables $a$ and $b$, that are stored on tape $0$ and $1$, as
also visualised in Table~\ref{tab:tapes-Add}.  The decrement operation and test whether $b$ was $0$ is implemented using the deconstructor machine
$\MS{MatchNat}$.  In the case that $b$ is $0$, the step machine terminates in $\Some\unit$, so that the loop brakes.  In case $b$ is greater then $0$,
$\MS{MatchNat}$ decreases $b$ and the step machine increases $a$.  Then it terminates in $\None$, so that the loop continues.
\begin{definition}[$\MS{AddStep}$][Add_Step]
  \label{def:Add_Step}
  \[
    \MS{AddStep} := \If{\LiftTapes{\MS{MatchNat}}{\Vector{1}}}{\Return{(\LiftTapes{\MS{ConstrS}}{\Vector{0}})}{\None}}{\Return{\Nop}{\Some\unit}}.
  \]
\end{definition}

Because all parts of $\MS{AddStep}$ terminate in constant time, we get the constant runtime part of the semantics of $\MS{AddStep}$ for free.
\begin{lemma}[Correctness of $\MS{AddStep}$][Add_Step_Sem]
  \label{lem:Add_Step_Sem}
  $\MS{AddStep} \RealiseIn{9} AddStepRel$ with
\begin{lstlisting}[style=semicoqstyle]
$AddStepRel$ :=
  $\lambda~t~(y, t').~ \forall (a~b:\Nat).$
    $t[0] \simeq a \rightarrow t[1] \simeq b \rightarrow$
    $\MS{match}~y, b$
    [$\Some\unit, O$=>$t'[0] \simeq a ~\land~ t'[1] \simeq b$
    |$\None, S~b'$=>$t'[0] \simeq S~a ~\land~ t'[1] \simeq b'$
    |_,_=>$\False$
    ].
\end{lstlisting}
\end{lemma}

According to the general design plan, we define $\MS{AddLoop} := \While~\MS{AddStep}$.  The correctness relation of $\MS{AddLoop}$ now says, that
after the execution of the loop, $t'[0]$ contains $a+b$ and $t'[1]$ contains $0$:
\begin{lemma}[Correctness of $\MS{AddLoop}$][Add_Loop_Realise]
  \label{lem:Add_Loop_Realise}
  $\MS{AddLoop} \Realise AddLoopRel$ with
  \[
    AddLoopRel := \lambda t~t'.~\forall (a~b:\Nat).~t[0] \simeq a \rightarrow t[1] \simeq b \rightarrow t'[0] \simeq a+b \land t'[1] \simeq 0.
  \]
\end{lemma}
\begin{proof}
  Using the $\While$-induction Lemma~\ref{lem:WhileInduction}.  In case the loop terminated, $b$ must have been $0$ and $t'[0] \simeq a$, therefore
  $t'[0]$ contains $a=a+0=a+b$.  In the induction/loop case, we know that $b=1+b'$ and that $t'[0] \simeq S~a$ and $t'[1] \simeq b'$.  By the
  inductive hypothesis, we know that $t''[0]$ contains $b' + S~a = a+b$ and $t''[1] \simeq 0$.
\end{proof}

The runtime of $\MS{AddLoop}$ must be shown separately.  We know that the loop is executed $b+1$ times, each iteration takes $9$ steps.  We have to
add $1$ step for each re-iteration of the loop.  So, the total step number is $9+10 \cdot b$.
\begin{lemma}[Runtime of $\MS{AddLoop}$][Add_Loop_Terminates]
  \label{lem:Add_Loop_TerminatesIn}
  $\MS{AddLoop} \downarrow AddLoopT$ with
  \[
    AddLoopT := \lambda t~k.~\exists (a~b:\Nat).~t[0] \simeq a \land t[1] \simeq b \land 9+10 \cdot b \leq k.
  \]
\end{lemma}

Now we can define the full machine $\MS{Add}$:
\begin{definition}[$\MS{Add}$][Add]
  \label{def:Add}
  ~
  \[
    \MS{Add} :=
    \LiftTapes{\MS{CopyValue}}{\Vector{1;2}} \Seq
    \LiftTapes{\MS{CopyValue}}{\Vector{0;3}} \Seq
    \LiftTapes{\MS{AddLoop}}{\Vector{2;3}} \Seq
    \LiftTapes{\MS{Reset}}{\Vector{3}}.
  \]
\end{definition}

At this point, we introduce a graphical notation of execution protocols that show the value of each tape after the execution of each sub-machine.  In
the left column we have the input values for each tape, or $\dashv$ if the tape is initially right.  Each further column denotes the executions of the
(tape-lifted) sub-machines.  We write entries $j: x$ in each cell that is in the index-vector of the sub-machine.  $j$ is the tape-index of the lifted
machine and $x$ is the value after the execution of the sub-machine on this tape.  We use the symbol $\dashv$ to denote that the tape is right.  If a
cell of the table is empty, the tape has not changed, read further left in the same row.  In Table~\ref{tab:exec-Add}, we have an example of an
execution protocol for $\MS{Add}$.

\begin{table}[h]
  \centering
  \begin{tabular}{l||l|l|l|l}
    Input       & $\MS{CopyValue}$ & $\MS{CopyValue}$ & $\MS{AddLoop}$ & $\MS{Reset}$ \\ \hline
    $0: m$      &                  & $0 : m$          &                &              \\
    $1: n$      & $0 : n$          &                  &                &              \\
    $2:~\dashv$ & $1 : n$          &                  & $0: m+n$       &              \\
    $3:~\dashv$ &                  & $1 : m$          & $1: 0$         & $0:~ \dashv$ \\
  \end{tabular}
  \caption{Execution protocol of $\MS{Add}$}
  \label{tab:exec-Add}
\end{table}

From the execution protocol in Table~\ref{tab:exec-Add}, we can see that after the execution of all four sub-machines, the tapes $0$ and $1$ still
contain the values $m$ and $n$, tape $2$ contains $m+n$, and tape $3$ is right.  Execution protocols serve as outlines of the formal correctness
proofs.  We conclude the correctness of $\MS{Add}$.
\begin{lemma}[Correctness of $\MS{Add}$][Add_Computes]
  \label{lem:Add_Computes}
  $\MS{Add} \Realise FunRel(add)$.
\end{lemma}

For the runtime function, we have to add linear components for the copying of $m$ and $n$.
\begin{lemma}[Runtime of $\MS{Add}$][Add_Terminates]
  $\MS{Add} \downarrow FunT(stepsAdd)$ with
  \[
    stepsAdd~m~n := 98 + 22 \cdot m + 12 \cdot n.
  \]
\end{lemma}

\begin{table}[h]
  \centering
  \begin{tabular}{l|l|l}
    Sub-Machine & Runtime & Accumulated runtime \\ \hline
    $\LiftTapes{\MS{CopyValue}}{\Vector{1;2}}$  & $37 + 12 \cdot n$ & $98 + 22 \cdot m + 12 \cdot n$ \\
    $\LiftTapes{\MS{CopyValue}}{\Vector{0;3}}$  & $37 + 12 \cdot m$ & $60 + 22 \cdot m$ \\
    $\LiftTapes{\MS{AddLoop}}{\Vector{2;3}}$    & $9 + 10 \cdot m$  & $22 + 10 \cdot m$ \\
    $\LiftTapes{\MS{Reset}}{\Vector{3}}$        & $12$              & $12$ \\
  \end{tabular}
  \caption{Accumulated sub-runtimes of $\MS{Add}$}
  \label{tab:runtime-Add}
\end{table}

When we prove the runtime of sequences of multiple machines, we have to give runtime functions for all suffixes of the sequence in terms of the
sequence operator.  We accumulate the runtimes from down to top and have to add one additional step for each sequence operator.  This is visualised in
Table~\ref{tab:runtime-Add}.


\subsection{Multiplication}
\label{sec:Mult}

We use the machine $\MS{Add}$ to implement a machine $\MS{Mult}$ that computes the multiplication function $mult : \Nat\to\Nat\to\Nat$.  The machine
$\MS{Mult}$ ``calls'' the machine $\MS{Add}$ $m$-times to add $n$ to a counter $c$ that is initiated with $0$.  The following pseudo code presents the
algorithm that we implement: { \small
\begin{lstlisting}[style=pseudocode]
c := 0
m' := m
While (m'--) {
  c' := Add(n, c)
  Reset c
  c := c'
  Reset c'
}
Reset m'
\end{lstlisting}
}%
Note that we do not have to copy $n$, since we do not write on $n$ and the machine $\MS{Add}$ does not change
$n$.  Also note that we can not simply add $n$ to $c$, since input and output tapes are distinct.  Therefore, we have to store the result of the
addition to an intermediate variable (i.e.\ internal tape), which has to be reseted afterwards.

\begin{table}[t]
  \centering
  \begin{tabular}{l|l|l|l|l}
    Tape of $\MS{Mult}$ & Variable & Role & Tape in $\MS{MultStep}$ & Tape in $\MS{Add}$ \\ \hline
    $0$ & $m$  & Input    & --  & --  \\
    $1$ & $n$  & Input    & $1$ & $0$ \\
    $2$ & $c$  & Output   & $2$ & $1$ \\
    $3$ & $c'$ & Internal & $3$ & $2$ \\
    $4$ & --   & Internal & $4$ & $3$ \\
    $5$ & $m'$ & Internal & $0$ & --  \\
  \end{tabular}
  \caption{Tape assignment for $\MS{Mult}$}
  \label{tab:tapes-Mult}
\end{table}
\begin{table}[t]
  \centering
  \begin{tabular}{l||l|l|l|l|l}
    Input       & $\MS{MatchNat}$ & $\MS{Add}$  & $\MS{Reset}$ & $\MS{CopyValue}$ & $\MS{Reset}$   \\ \hline
    $0: m$      & $0 : m'$        &             &              &                  &                \\
    $1: n$      &                 & $0: n$      &              &                  &                \\
    $2: c$      &                 & $1: c$      & $0:~\dashv$  & $1: n+c$         &                \\
    $3:~\dashv$ &                 & $2: n+c$    &              & $0: n+c$         & $0:~\dashv$    \\
    $4:~\dashv$ &                 & $3:~\dashv$ &              &                  &                \\
  \end{tabular}
  \caption{Execution protocol of $\MS{MultStep}$ for $m=S~m'$}
  \label{tab:exec-MultStep}
\end{table}

The tape-assignment is depicted in Table~\ref{tab:tapes-Mult}.  Note that not for all tapes is explicitly named in the algorithm, e.g.\ tape $4$ is
used as the internal tape for $\MS{Add}$ to save the first parameter, which is called $n$ in this case.  The step machine, $\MS{MultStep}$, has only
access to the copy of $m$, which is mapped to tape $0$ of $\MS{MultStep}$.  In the following, we use also use the name $m$ for its copy in the context
of $\MS{MultStep}$.
\begin{definition}[$\MS{MultStep}$][Mult_Step]
  \label{def:Mult_Step}
  \begin{alignat*}{2}
    &\MS{MultStep} &~:=~&
           \MS{If}~\LiftTapes{\MS{MatchNat}}{\Vector{0}} \\
    &&& \MS{Then}  ~\Return{\left( \LiftTapes{\MS{Add}}{\Vector{1;2;3;4}} \Seq
                                \LiftTapes{\MS{Reset}}{\Vector{2}} \Seq
                                \LiftTapes{\MS{CopyValue}}{\Vector{3;2}} \Seq
                                \LiftTapes{\MS{Reset}}{\Vector{3}} \right)}{\None} \\
    &&& \MS{Else}~~~\Return{\MS{Nop}}{\Some\unit}.
  \end{alignat*}
\end{definition}
An execution protocol of $\MS{MultStep}$ for the case $m=S~m'$ (where $m$ is the copy) is shown in Table~\ref{tab:exec-MultStep}.  The correctness
relation of $\MS{MultStep}$ is analogous to $\MS{AddStep}$.
\begin{lemma}[Correctness of $\MS{MultStep}$][Mult_Step_Realise]
  \label{lem:Mult_Step_Sem}
  $\MS{MultStep} \RealiseIn{9} MultStepRel$ with
  \small
\begin{lstlisting}[style=semicoqstyle]
$MultStepRel$ :=
  $\lambda~t~(y, t').~ \forall (c~m~n:\Nat).$
    $t[0] \simeq m \rightarrow t[1] \simeq n \rightarrow t[2] \simeq c \rightarrow isRight~t[3] \rightarrow isRight~t[4] \rightarrow$
    $\MS{match}~y, m$
    [$\Some\unit, O \Rightarrow t'[0] \simeq 0 ~\land~ t'[1] \simeq n ~\land~ t'[2] \simeq c ~\land~ isRight~t'[3] ~\land~ isRight~t'[4]$
    |$\None, S~m' \Rightarrow t'[0] \simeq m' ~\land~ t'[1] \simeq n ~\land~ t'[2] \simeq n+c ~\land~ isRight~t'[3] ~\land~ isRight~t'[4]$
    |_,_ => $\False$
    ].
\end{lstlisting}
\end{lemma}
Note that in the correctness Lemma~\ref{lem:Add_Step_Sem}, we also prove termination in constant runtime.  This is not true for $\MS{MultStep}$,
because it calls $\MS{Add}$, which has not constant runtime.

As usual, we define $\MS{MultLoop} := \While~\MS{MultStep}$.  The correctness statement of $\MS{MultLoop}$ says that if the first three tapes contain
$m$, $n$, $c$, and all other tapes are right, then after the execution of the loop, the tapes contain $0$, $n$, and $m \cdot n + c$ and the other
tapes are right.  Thus, when we instantiate the $c$-tape with the value $0$, the output tape contains $m \cdot n$.

\begin{lemma}[Correctness of $\MS{MultLoop}$][Mult_Loop_Realise]
  \label{lem:Mult_Loop_Realise}
  \label{lem:Mult_Loop_Realise}
  $\MS{MultLoop} \Realise MultLoopRel$ with
  \begin{alignat*}{2}
    & MultLoopRel ~&:=& \lambda t~t'.~\forall (c~m~n:\Nat). \\
    &&& t[0] \simeq m \rightarrow t[1] \simeq \rightarrow t[2] \simeq c \rightarrow isRigth~t[3] \rightarrow isRight~t[4] \rightarrow \\
    &&& t'[0] \simeq 0 \land t'[1] \simeq n \land t'[2] \simeq m \cdot n + c \land isRight~t'[3] \land isRight~t'[4]
  \end{alignat*}
\end{lemma}

It is now easy to define the rest of $\MS{Mult}$.
\begin{definition}[$\MS{Mult}$][Mult]
  \label{def:Mult}
  \[
    \MS{Mult} :=
    \LiftTapes{\MS{CopyValue}}{\Vector{0;5}} \Seq
    \LiftTapes{\MS{ConstrO}}{\Vector{2}} \Seq
    \LiftTapes{\MS{MultLoop}}{5;1;2;3;4} \Seq
    \LiftTapes{\MS{Reset}}{\Vector{5}}.
  \]
\end{definition}

It follows that $\MS{Mult}$ computes the function $mult$, w.r.t.\ Definition~\ref{def:Computes2_Rel}.
\begin{lemma}[Correctness of $\MS{Mult}$][Mult_Computes]
  \label{lem:Mult_Computes}
  $\MS{Mult} \Realise FunRel(mult)$.
\end{lemma}

For brevity,  we omit the concrete runtime function here.  
\begin{lemma}[Runtime of $\MS{Mult}$][Mult_Terminates]
  There is a function $multSteps : \Nat\to\Nat\to\Nat$, such that $multSteps \in \mathcal{O}(m \cdot n^2)$ and
  $\MS{Mult} \TerminatesIn FunT(multSteps)$.
\end{lemma}

\subsection{Mapping of Sum Functions}
\label{sec:SumTM}
\setCoqFilename{FormalComplexity.TM.Code.SumTM}%

Let $f : X \to Z$ and $g : Y \to Z$.  Then we can define the canonical function $(f+g) : X+Y \to Z$ by $(f+g)(\inl x):=f(x)$ and
$(f+g)(\inr y):=g(y)$.  We want to define an operator that takes machines $M_1, M_2$ that compute the unary functions $f$ and $g$, and yields a
machine $\MS{MapSum}$ that computes the function $(f+g)$.

First we have to define precisely, which machine has which alphabet.  Let $X, Y$ be encodable over $\Sigma_X, \Sigma_Y$.  We assume
$M_1, M_2 : \TM_{\Sigma_M}^{2+n}$, i.e.\ both machines have the same alphabet and they have at least two tapes (i.e.\ an input and output tape).  We
assume that $\Sigma_M$ includes $\Sigma_X$, $\Sigma_Y$, and $\Sigma_Z$.  Formally, this means that we assume retractions $f_X,f_Y,f_Z$ between
$\Sigma_X, \Sigma_Y, \Sigma_Z$ and $\Sigma_M$.  Let $\Sigma$ be the alphabet for $\MS{MapSum}$, with a retraction
$f_M : \Sigma_M \hookrightarrow \Sigma$.  Furthermore, it should be possible to encode $X+Y$ on $\Sigma$, so we assume a retraction
$f_{X+Y} : \Sigma_{X+Y} \hookrightarrow \Sigma$.  We notice that there are now two possibilities how to encode $X$ (and dually $Y$) on $\Sigma$: via
the retractions $f_X \circ f_M$ and $RetrInl \circ f_{X+Y}$.  These retractions might be extensionally equal for concrete choices of alphabets, but we
want to be as general as possible.  As a consequence, we need to translate between these representations, using the $\MS{Translate}$ machine of
Section~\ref{sec:Translate}.  Note that there is only one way to encode $Z$ on $\Sigma$, namely via $f_Z \circ f_M$.

The machine $\MS{MapSum}$ first makes a case-distinction on the value $s:X+Y$ on the input tape $0$.  If it is $x$ (on the alphabet $\Sigma_{X+Y}$),
it is translated to the alphabet of $M_1$.  Then we execute the alphabet-lifted machine $M_1$.  This writes the output $f_1(x)$ on the output tape $1$
and leaves $x$ unchanged.  After that, $\MS{MapSum}$ translates $x$ back to the alphabet $\Sigma_{X+Y}$ and applies the constructor $\inl$, so the
input tape contains $\inl x$ again.  The case when the input was $s=\inl y$ is symmetric.

\begin{definition}[$\MS{MapSum}$][MapSum]
  \label{def:MapSum}
  ~
  \begin{align*}
    & \MS{MapSum}~:= \\
    &\quad \MS{If}~{\LiftBoth{\MS{MatchSum}}{f_{X+Y}}{\Vector{0}}} \\
    &\quad \MS{Then}~ \LiftTapes{(\MS{Translate}~(RetrInl \circ f_{X+Y})~(f_X \circ f_M))}{\Vector{0}} \Seq \\
    &\quad \phantom{\MS{Then}}~ \LiftAlphabet{M_1}{f_M} \Seq \\
    &\quad \phantom{\MS{Then}}~ \LiftTapes{(\MS{Translate}~(f_X \circ f_M)~(RetrInl \circ f_{X+Y}))}{\Vector{0}} \Seq \\
    &\quad \phantom{\MS{Then}}~ \LiftBoth{\MS{ConstrInl}}{f_{X+Y}}{\Vector{0}} \\
    &\quad \MS{Else}~~~ \LiftTapes{(\MS{Translate}~(RetrInr \circ f_{X+Y})~(f_Y \circ f_M))}{\Vector{0}} \Seq \\
    &\quad \phantom{\MS{Then}}~ \LiftAlphabet{M_2}{f_M} \Seq \\
    &\quad \phantom{\MS{Then}}~ \LiftTapes{(\MS{Translate}~(f_Y \circ f_M)~(RetrInr \circ f_{X+Y}))}{\Vector{0}} \Seq \\
    &\quad \phantom{\MS{Then}}~ \LiftBoth{\MS{ConstrInr}}{f_{X+Y}}{\Vector{0}}.
  \end{align*}

% \begin{lstlisting}[style=semicoqstyle]
% $\MS{MapSum} :=$
%   $\MS{If}$ $\LiftBoth{\MS{MatchSum}}{f_{X+Y}}{\Vector{0}}$
%   $\MS{Then}$     $\LiftTapes{(\MS{Translate}~(RetrInl \circ f_{X+Y})~(f_X \circ f_M))}{\Vector{0}} \Seq \LiftAlphabet{M_1}{f_M} \Seq$
%        $\LiftTapes{(\MS{Translate}~(f_X \circ f_M)~(RetrInl \circ f_{X+Y}))}{\Vector{0}} \Seq$
%        $\LiftBoth{\MS{ConstrInl}}{f_{X+Y}}{\Vector{0}}$
%   $\MS{Else}$     $\LiftTapes{(\MS{Translate}~(RetrInr \circ f_{X+Y})~(f_Y \circ f_M))}{\Vector{0}} \Seq \LiftAlphabet{M_2}{f_M} \Seq$
%        $\LiftTapes{(\MS{Translate}~(f_Y \circ f_M)~(RetrInr \circ f_{X+Y}))}{\Vector{0}} \Seq$
%        $\LiftBoth{\MS{ConstrInr}}{f_{X+Y}}{\Vector{0}}.$
% \end{lstlisting}
\end{definition}

\begin{lemma}[Correctness of $\MS{MapSum}$][Mult_Sum_Computes]
  \label{lem:MapSum_Computes}
  If $M_1 \Realise FunRel(f_1)$ and $M_2 \Realise FunRel(f_2)$, then $\MS{MapSum} \Realise FunRel(f_1+f_2)$.
\end{lemma}


\subsection{List Access}
\label{sec:Nth}
\setCoqFilename{FormalComplexity.TM.Code.ListTM}%

In this section, we show how to implement machines that compute the function $nth : \List(X) \to \Nat \to \Option(X)$.  Again, we use the technique
for extending alphabets of Section~\ref{sec:extend-alphabet}.  For brevity, we exclude most runtime relations and proofs, we refer to the Coq
development.

Let $X$ be encodable on $\Sigma_X$.  We implement a machine $\MS{Nth} : \TM_{\Sigma^+}^4$ that computes the function
$nth : \List(X) \to \Nat \to \Option(X)$.  We assume retractions $f_{\List(X)} : \Sigma_{\List(X)} \hookrightarrow \Sigma$,
$f_{\Option(X)} : \Sigma_{\Option(X)} \hookrightarrow \Sigma$, and $f_\Nat : \Sigma_\Nat \hookrightarrow \Sigma$.  Now there are two ways to encode
$X$ on $\Sigma$: via $RetrOpt \circ f_{\Option(X)}$ and $RetrList \circ f_{\List(X)}$.

The algorithm of the step can be expressed with the pseudocode in Figure~\ref{fig:pseudo-NthStep}.  Note that we do not use new variable names for the
copies of $l:\List(X)$ and $n:\Nat$.  The tape assignment is visualised in Figure~\ref{fig:tapes-Nth}.

\begin{figure}[!htb]
  \begin{minipage}{0.3\textwidth}
    \small
\begin{lstlisting}[style=pseudocode]
If $n--$ {
  If $\exists x~l'.~l = x \cons l'$ {
    $l$ := $l'$
    Reset $x$
    Continue
  } Else {
    $x$ := $\None$
    Break
  }
} Else {
  If $\exists x~l'.~l = x \cons l'$ {
    $l$ := $l'$
    $x$ := $\Some x$
    Break
  } Else {
    $x$ := $\None$
    Break
  }
}
\end{lstlisting}
    \caption{Pseudocode for $\MS{NthStep}$}
    \label{fig:pseudo-NthStep}
  \end{minipage}%
  \begin{minipage}{0.7\textwidth}
    \begin{tabular}{l|l|l|l}
      Tape of $\MS{Nth}$ & Variable & Role & Tape in $\MS{NthStep}$ \\ \hline
      $0$ & $l$        & Input    & --  \\
      $1$ & $n$        & Input    & --  \\
      $2$ & $x$        & Output   & $2$ \\
      $2$ & $l$ (copy) & Internal & $0$ \\
      $3$ & $n$ (copy) & Internal & $1$ \\
    \end{tabular}
    \caption{Tape assignment for $\MS{Nth}$ and $\MS{NthStep}$}
    \label{fig:tapes-Nth}
  \end{minipage}
\end{figure}


The step machine first destructs $n$.  If it was $0$ and the list is empty, it writes $\None$ to the output tape.  Else, it applies the $\Some{\cdot}$
constructor to the head.  Note that before we can apply the constructor, $x$ has first to be translated to the $\Sigma_{\Option(X)}$ alphabet.  In
case $n$ was non-zero, if the list is empty, the machine applies the $\None$ constructor to the output tape.  Else, it deletes the head (which was on
the output tape) and continues the loop.

\begin{definition}[$\MS{NthStep}$][Nth_Step]
  \label{def:Nth_Step}
  ~
  \begin{align*}
    & \MS{MapSum}~:= \\
    &\quad \MS{If}~\LiftBoth{\MS{MatchNat}}{f_\Nat}{\Vector{1}} \\
    &\quad \MS{Then}~ \MS{If}~\LiftBoth{\MS{MatchList}}{f_{\List(X)}}{\Vector{0;2}} \\
    &\quad \phantom{\MS{Then}}~\MS{Then}~   \Return{(\LiftTapes{\MS{Reset}}{\Vector{2}})}{\None} \\
    &\quad \phantom{\MS{Then}}~\MS{Else}~~~ \Return{(\LiftBoth{\MS{ConstrNone}}{f_{\Option(X)}}{\Vector{2}})}{\Some\unit} \\
    &\quad \MS{Else}~~~ \MS{If}~\LiftBoth{\MS{MatchList}}{f_{\List(X)}}{\Vector{0;2}} \\
    &\quad \phantom{\MS{Then}}~\MS{Then}~   \Return{(\LiftTapes{(\MS{Translate}~(RetrList \circ f_{\List(X)})~(RetrOpt \circ f_{\Option(X)}) \Seq \\
    &\quad \phantom{\phantom{\MS{Then}}~\MS{Then}~\MS{Return}}\quad\quad~~ \LiftAlphabet{\MS{ContrSome}}{f_{\Option(X)}})}{\Vector{2}})}{\Some\unit} \\
    &\quad \phantom{\MS{Then}}~\MS{Else}~~~ \Return{(\LiftBoth{\MS{ConstrNone}}{f_{\Option(X)}}{\Vector{2}})}{\Some\unit}
  \end{align*}
\end{definition}

The correctness relation of $\MS{NthStep}$ has to capture all four cases.

\begin{lemma}[Correctness of $\MS{NthStep}$][Nth_Step_Realise]
  \label{lem:Nth_Step_Realise}
  $\MS{NthStep} \Realise NthStepRel$ with
  \small
\begin{lstlisting}[style=semicoqstyle]
$NthStepRel :=$
  $\lambda t~(y, t').$
    $\forall (l : \List(X))~(n : \Nat).$
      $t[0] \simeq l \rightarrow t[1] \simeq n \rightarrow isRight~t[2]$ ->
      $\MS{match}~y, n, l$
      [$\None, S~n', x \cons l' \Rightarrow t'[0] \simeq l' \land t'[1] \simeq n' ~\land~ isRight~t'[2]$
      |$\Some\unit, S~n', \nil \Rightarrow t'[0] \simeq l~ \land t'[1] \simeq n' \land t'[2] \simeq \None$
      |$\Some\unit, 0, x \cons l' \Rightarrow t'[0] \simeq l' \land t'[1] \simeq 0 \land t'[2] \simeq \Some x$
      |$\Some\unit, 0, \nil \Rightarrow t'[0] \simeq l \land t'[1] \simeq n \land t'[2] \simeq \None$
      |_,_,_=>$\False$
      ].
\end{lstlisting}
\end{lemma}

Now, we can prove the correctness of the loop, $\MS{NthLoop} := \While~\MS{NthStep}$.  When the loop terminates, the value of the variable $n$ will be
$n - (1 + \length{l})$.  The new value of $l$ will be $skipn~(S~n)~l$, where $skipn : \Nat \to \List(X) \to \List(X)$ applies $\tl$ $n$-times.  Note
that if $n < \length{l}$, the new value of $n$ will be $0$ and the machine returns a $\Some\cdot$ value.

\begin{lemma}[Correctness of $\MS{NthLoop}$][Nth_Loop_Realise]
  \label{lem:Nth_Loop_Realise}
  $\MS{NthLoop} \Realise NthLoopRel$ with
  \begin{alignat*}{2}
    & NthLoopRel &~:=~& \lambda t~t'.~\forall (l:\List(X))~(n:\Nat).~t[0] \simeq l \rightarrow t[1] \simeq n \rightarrow isRight~t[2] \rightarrow \\
    &            &~  ~& \phantom{\lambda t~t'.}~t'[0] \simeq skipn~(S~n)~l \land t'[1] \simeq n-(1+\length{l}) \land t'[2] \simeq nth~l~n.
  \end{alignat*}
\end{lemma}

The full machine $\MS{Nth}$ makes copies of $n$ and $l$ and run $\MS{NthLoop}$ on the copies.  After that, it resets the internal tapes $2$ and $3$
with the copies of $n$ and $l$.  Note that for the correctness of $\MS{Reset}$ it is only important that there is a value on the tape.  The runtime
(which we omit here), does depend on the actual values.
\begin{definition}[$\MS{Nth}$][Nth]
  \[
    \MS{Nth} := \LiftTapes{\MS{CopyValue}}{\Vector{0;3}} \Seq
    \LiftTapes{\MS{CopyValue}}{\Vector{1;4}} \Seq
    \LiftTapes{\MS{NthLoop}}{\Vector{3;4;2}} \Seq
    \LiftTapes{\MS{Reset}}{\Vector{3}} \Seq
    \LiftTapes{\MS{Reset}}{\Vector{4}}
  \]
\end{definition}
Note that we copy and reset values of different types.  We have to insert this semantical information in the correctness proof, when we apply the
respective correctness lemmas, in this case, Lemma~\ref{lem:CopyValue_Realise} and Lemma~\ref{lem:Reset_Realise}.

It follows that $\MS{Nth}$ computes the function $nth$.
\begin{lemma}[Correctness of $\MS{Nth}$][Nth_Computes]
  \label{lem:Nth_Computes}
  $\MS{Nth} \Realise FunRel(nth)$.
\end{lemma}

% % This is not proven in Coq
% For brevity, we omit the concrete runtime function.
% \begin{lemma}[Runtime of $\MS{Nth}$][Nth_Terminates]
%   \label{lem:Nth_TerminatesIn}
%   There is a function $NthSteps:\List(X)\to\Nat\to\Nat$, such that $NthSteps \in \mathcal{O}(\size{ls})$ and $\MS{Nth} \TerminatesIn NthSteps$.
% \end{lemma}


%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
