\chapter{Programming Turing Machines}
\label{chap:programming}

We can define machines using primitive operations like $\MS{DoAct}$, and can combine machines in an imperative programming style.  Furthermore, we can
reuse machines in bigger contexts.  However, our imperative ``language'' still has no notion of values or data cells.  We want to use each tape as a
data cell to store one value.  Therefore, we have to define what it means that a tape contains a value.  When we ``program'' Turing machines, instead
of using basic machines, we only use machines that directly change the value of a tape.  We use the combinators introduced in
Chapter~\ref{chap:combining} to simulate control flow of imperative programming languages.  Using the definition of value-containing, we specify a
``callee-saving'' convention for function computation.  We present a generic pattern how to program and verify Turing machines, and present more
complex case studies.


\section{Value-Containing}
\label{sec:value-containing}

We first want to define what it means that a tape $t$ \emph{contains} a value $x$, written as $t \simeq x$.  Tapes, as defined in \ref{def:tape}, are
essentially a list of symbols, so we have to linearise values to strings.

\begin{definition}[Encodable types]
  We say that a type $X$ is \emph{encodable} over $\Sigma$, if there is a function $encode : X \to \List(\Sigma)$.
\end{definition}

Morally, the encoding functions should be injective and there also should be a decoding function, such that the encoding and decoding functions is a
retraction on $\List(\Sigma)$.  However, we do not need this strict definition.

We may encode a type $X$ on any alphabet $\Tau$, if $\Sigma$ is a retraction on $\Tau$:
\begin{definition}[Map encodings]
  \label{def:Encode_map}
  Let $X$ be encodable over $\Sigma$ and $f : \Sigma \hookrightarrow \Tau$ be a retraction.  Then $X$ is also encodable over $\Tau$ with the following
  encoding function:
  \[ encode_\Tau(x) := encodeMap~encode_\Sigma~f~(x) := \map{f}{(encode_\Sigma(x))}. \]
\end{definition}

Mapping of encodings are compatible with composition of retractions.  This means that if we map the encoding twice, this is the same as mapping the
encoding with the composition of both retractions:
\begin{lemma}[Composition and encoding mapping]
  \label{lem:Encode_map_comp}
  Let $f : \Sigma \hookrightarrow \Tau$ and $g : \Tau \hookrightarrow \Delta$ be retractions and $X$ be encodable over $\Sigma$.  Then there is only
  one way how $X$ can be encoded over $\Delta$, i.e.:
  \[ encodeMap~(encodeMap~f~encode)~g~(x) = encodeMap~encode~(f \circ g)~x. \]
\end{lemma}

For each type and type constructor, we have a distinct alphabet.  We define basic encodings:
\begin{definition}[Basic encodings]
  \label{def:basic-encodings}
  ~
  \begin{enumerate}
  \item We encode $\Unit$ over the empty alphabet $\False$:
  \[ encode(\unit) := \nil
  \]
  \item The types $\Bool$ and $\Fin_k$ are encoded over them-self, i.e.\ $encode(x):=[x]$.
  \item Let $X$ be encodable over $\Sigma$.  Then $\Option(X)$ is encodable over
    \[ SigOpt~\Sigma ::= \MS{NONE} ~|~ \MS{SOME} ~|~ (x:\Sigma) \]
    With the retraction $RetrOpt : \Sigma \hookrightarrow SigOpt~\Sigma$ and
    \[
      encode(o) :=
      \begin{cases}
        [\MS{NONE}] & o=\None \\
        \MS{SOME} \cons encode(x) & x=\Some{x}
      \end{cases}
    \]
  \item Let $X$ be encodable over $\Sigma$ and $Y$ over $\Tau$.  Then $X+Y$ is encodable over
    \[ SigSum~\Sigma~\Tau ::= \MS{INL} ~|~ \MS{INR} ~|~ (x:\Sigma) ~|~ (y:\Tau) \] With the retractions
    $RetrOptX : \Sigma \hookrightarrow SigOpt~\Sigma~\Tau$, $RetrOptY : \Tau \hookrightarrow SigOpt~\Sigma~\Tau$ and
    \[
      encode(s) :=
      \begin{cases}
        \MS{INL} \cons encode(x) & s=\inl x \\
        \MS{INR} \cons encode(y) & x=\inr y
      \end{cases}
    \]
  \item Let $X$ be encodable over $\Sigma$ and $Y$ over $\Tau$.  Then $X \times Y$ is encodable over
    \[ SigSum~\Sigma~\Tau ::= (x:\Sigma) ~|~ (y:\Tau) \] With the retractions
    $RetrSumX : \Sigma \hookrightarrow SigSum~\Sigma~\Tau$, $RetrSumY : \Tau \hookrightarrow SigSum~\Sigma~\Tau$ and
    \[
      encode(s) :=
      \begin{cases}
        \MS{INL} \cons encode(x) & s=\inl x \\
        \MS{INR} \cons encode(y) & s=\inr y
      \end{cases}
    \]
  \item Let $X$ be encodable over $\Sigma$.  Then $\List(X)$ is encodable over
    \[ SigList~\Sigma ::= \MS{NIL} ~|~ \MS{CONS} ~|~ (x:\Sigma) \]
    With the retraction $RetrList : \Sigma \hookrightarrow SigList~\Sigma$ and
    \begin{alignat*}{3}
      &encode~&&(\nil      ) &~:=~& [\MS{NIL}] \\
      &encode~&&(l \cons ls) &~:=~& \MS{CONS} \cons encode(x) \app encode(ls)
    \end{alignat*}
  \item Natural numbers $\Nat$ are encodable over $ SigNat ::= \MS{S} ~|~ \MS{0} $ with
    \begin{alignat*}{3}
      &encode~&&(0  ) &~:=~& [\MS{O}] \\
      &encode~&&(S~n) &~:=~& \MS{S} \cons encode(n)
    \end{alignat*}
  \end{enumerate}
\end{definition}

This are all encodings we need.  However, there is still a problem about ambiguity: Suppose $X$ is encodable over $\Sigma$.  Then the smallest
alphabet on which we can encode the type $X+X$ is $\Tau := SigSum~\Sigma~\Sigma$.  However, now there are two possibilities how to encode $X$ on
$\Tau$: using the retraction $RetrSigX$ and $RetrSigY$.  We must deal with this problem, when we program and prove Turing machines, by explicitely
giving the right retractions.

If $X$ is encodable over $\Sigma$, we encode values of $x$ on tapes with an extended alphabet $\Sigma^+$ that has an additional start and stop symbol.
\begin{definition}[$\Sigma^+$] Let $\Sigma$ be an alphabet.
  \[
    \Sigma^+ ::= \MS{START} ~|~ \MS{STOP} ~|~ \MS{UNKNOWN} ~|~ (s: \Sigma)
  \]
  Also, we define the retraction $RetrPlus : \Sigma \hookrightarrow \Sigma^+$.
\end{definition}
The $\MS{UNKNOWN}$ symbol is important later. We define what $t \simeq x$ means:
\begin{definition}[$t \simeq x$]
  \label{def:tape_contains}
  Let $X$ be encodable over $\Sigma$ and $t : \Tape_{\Sigma^+}$.
  \[
    t \simeq x := \exists~ls.~
    t = \MS{midtape}~ls~(\MS{START})~(encode(x) \app [\MS{STOP}])
  \]
  In case the encoding is not clear, we write $t \simeq_{f} x$ with $t:\Tape_{\Tau^+}$ and $x:X$, when $X$ is encodable on $\Sigma$ according to
  Definition~\ref{def:basic-encodings}, and we map this encoding to $\Tau$ using the retraction $f: \Sigma \hookrightarrow \Tau$.
\end{definition}

Note that in Definition~\ref{def:tape_contains}, we have to map the encoding of $x$ to the extended alphabet $\Sigma^+$.  If $t \simeq x$, the head of
$t$ stands on the start symbol.  To the right, there is the encoding terminated by the stop-symbol.  To the left of the head, there may be arbitrary
many ``rest'' symbols.

We find the convention useful, that there are no further symbols beyond the stop symbol.  In future work we also want to reason about space usage of
machines.  If a tape contains a value, the size of the tape (i.e.\ the number of symbols on it), only depends on the length of the encoding and the
number of rest symbols $ls$ to the left.  We have the convention to only add symbols to the left of a tape.  We also only write on tapes, if the head
of the tape is on the right-most symbol.

\begin{definition}[Right tape]
  \label{def:isRght}
  A tape $t$ is \emph{right}, if $\MS{current}(t) \neq \None$ and $\MS{left}~t=\nil$.  With other words, $t = \MS{midtape}~ls~m~\nil$ for some
  $m:\Sigma$ and $ls:\List(\Sigma)$.
\end{definition}

\section{Alphabet-Lifting}
\label{sec:LiftAlphabet-UNKNOWN}

In Section~\ref{sec:sigma-Lift}, we defined the alphabet-lift operator.  However, we noted that we need a semantically relevant default symbol in the
``smaller'' alphabet $\Sigma$.  All ``programmed'' Turing machines are defined over an extended alphabet $\Sigma^+$.  Therefore, we use the
$\MS{UNKNOWN}$ symbol as the default symbol.  Intuitively, nothing can go wrong, because, by definition, $\MS{UNKNOWN}$ is not part of any encoding.
This intuition is confirmed by the following lemma:
\begin{lemma}[$surject$ and value-containing]
  \label{lem:contains_translate_tau}
  Let $f: \Sigma \hookrightarrow \Tau$ be a retraction between two alphabets.  Let $x:X$, where $X$ is encodable over $\Sigma$. Then, for
  $t:\Tape_\Tau$
  \[
    t \simeq_f x \iff mapTape~(surject~f)~t \simeq x.
  \]
\end{lemma}
Note that the encoding on the left side is mapped with the retraction $f$.

We write $\LiftAlphabet{M}{f}$ for $\LiftAlphabet{M}{(f, \MS{UNKNOWN})}$.

\section{Value-Manipulating Machines}
\label{sec:value-manipulate}

\todo{Can I use a present tense when I refer to what is above in the text?}

We defined what it means that a tape contains a value.  Now we want to define machines that manipulate values, e.g.\ increase or increase a number.
Also, a very useful operation is to copy a value from one tape to another tape.

\subsection{Constructors and Deconstructors}
\label{sec:constructors-deconstructors}


For each encodable type $X:\Type$, there is a set of machines: constructors and a matching machine.  These are machines over the least alphabet
$\Sigma^+$ to encode $X$ on.  Constructor machines, informally, ``apply'' a constructor of the inductive type $X$ to the value on the tape $t[0]$.
For example, considering the inductive type $\Nat$, the constructor machine $\MS{O}$ writes the number $0$ to a right tape.  The constructor machine
$\MS{S}$ assumes that $t[0]$ contains a number $n$, and increases that number.  The deconstructor for $\Nat$ reads a number of $t[0]$.  If it is $0$,
it terminates in $\false$.  Else, it decreases the number and terminates in $\true$.  In general, we have a constructor machine for each constructor
of the inductive type.  If the constructor has additional parameters, these are encodes on more input tapes $t[1], t[2], \cdots$.  On the other side,
the deconstructor machine has a partition for each constructor and may have additional tapes for storing additional parameters.

\subsubsection{Natural numbers}
\label{sec:match-nat}

This is the correctness relation for $\MS{MatchNat}$:
\begin{definition}[Correctness relation of $\MS{MatchNat}$]
  \label{def:MatchNat_Rel}
  ~
\begin{lstlisting}[style=semicoqstyle]
$MatchNatRel :=$
  $\lambda t~(y, t').$
    $\forall (n:\Nat).$
      $t[0] \simeq n \rightarrow$
      match $y$, $n$
      [$\false$, $O$ => $t'[0] \simeq 0$
      |$\true$, $S~n'$ => $t'[0] \simeq n'$
      | _, _ => $\False$
      ].
\end{lstlisting}
\end{definition}

Initially, the tape $t[0]$ contains some number $n$.  So the head of $t[0]$ must be on the start symbol.  The machine moves one step right and reads
the first symbol of the encoding.  This symbol may either be $\MS{S}$ or $\MS{O}$.  If the machine reads $\MS{O}$, this means that the number $n$ is
$0$, so the machine moves back to the start symbol and terminates in the partition $\false$, indicating that the number was $0$.  On the other side,
if the machine reads $\MS{S}$, this means the number $n$ is the successor of some number $n'$.  To decrement $n$, it overwrites the current $\MS{S}$
with a new start symbol and terminates on this symbol in the partition $\true$.

\begin{definition}[$\MS{MatchNat}$]
  \label{def:MatchNat}
  ~
\begin{lstlisting}[style=semicoqstyle]
$\MS{MatchNat} :=$
  Move R; 
  MATCH ($\MS{ReadChar}$) 
        ($\lambda(o:\Option(sigNat)).$ match $o$
           [$\Some {\MS{S}}$ => $\Return{(\MS{Write}~\MS{START})}{\true}$
           |$\Some {\MS{O}}$ => $\Return{(\MS{Move}~L)}{\false}$
           | _ => _ 
           ]).
\end{lstlisting}
\end{definition}

Note, that the placeholder $\_$ stands for some unspecified machine, e.g.\ in this case $\Return{\Nop}{b}$ where $b:\Bool$ is arbitrary.  This part of
the machine is not explicitly given, because the premise of the correctness relation of $\MS{MatchNat}$ guaranties that there must be a symbol under
the head which is either $\MS{S}$ or $\MS{O}$, so this part of the machine must never execute.

\begin{lemma}[Correctness of $\MS{MatchNat}$]
  $\MS{MatchNat} \RealiseIn{5} MatchNatRel$.
\end{lemma}
\begin{proof}
  We know that $t[0] \simeq n$.  This means $t[0] = \MS{midtape}~ls~\MS{START}~(\MS{S}^n \app \MS{O} \cons \MS{STOP})$ for some $ls$.  The proof is
  mechanical, like the above correctness proofs.
\end{proof}

\todo{Constructors}

\subsubsection{Sum Types}
\label{sec:match-sum}

Let $X$ be encodable over $\Sigma_X$ and $Y$ over $\Sigma_Y$.  $\MS{MatchSum} : \TM_{\left(SigSum~\Sigma_X~\Sigma_Y\right)^+}^1(\Bool)$ reads a value
$s:X+Y$.  If it is $\inl x$ (or $\inr~y$), it replaces the $\MS{INL}$ (or $\MS{INR}$) symbol with a new start symbol and terminates in $\true$ (or
$\false$).

\begin{definition}[$\MS{MatchSum}$]
  \label{def:MatchSum}
  ~
  \small
\begin{lstlisting}[style=semicoqstyle]
$\MS{MatchSum} :=$
  Move R; 
  MATCH ($\MS{ReadChar}$) 
        ($\lambda(o:\Option(sigSum~\Sigma_X~\Sigma_Y)).$ match $o$
           [$\Some {\MS{INL}}$ => $\Return{(\MS{Write}~\MS{START})}{\true}$
           |$\Some {\MS{INR}}$ => $\Return{(\MS{Write}~\MS{START})}{\false}$
           | _ => _ 
           ]).
\end{lstlisting}
\end{definition}

\begin{lemma}[Correctness of $\MS{MatchSum}$]
  \label{lem:MatchSum_Realise}
  $\MS{MatchSum} \RealiseIn5 MatchSumRel$ with
\begin{lstlisting}[style=semicoqstyle]
$MatchSumRel :=$
  $\lambda t~(y, t').$ $\forall (s:X+Y).$ $t[0] \simeq s \rightarrow$ match $y$, $s$
      [$\false$, $\inl x$ => $t'[0] \simeq x$
      |$\true$, $\inr y$ => $t'[0] \simeq y$
      | _, _ => $\False$
      ].
\end{lstlisting}
\end{lemma}

\todo{Constructors}

The types $\Option(X)$ and $X+\Unit$ are isomorphic.  Furthermore, the alphabets to encode these types on, $SigOpt~\Sigma$ and $SigSum~\Sigma~\False$,
are also isomorphic.  We can use this fact to derive a match machine and constructor machines for the type $\Option(X)$.  Let
$f : SigSum~\Sigma~\False \hookrightarrow SigOpt~\Sigma$ be the canonical retraction.  Then, we can define $\MS{MatchOption}$ as
$\LiftAlphabet{\MS{MatchSum}}{f}$.  However, in the case that $o=\None$, the surjected output tape $t'$ contains $\unit$.  Thus, the tape has form
(for some $ls$)
\[ t' = \MS{midtape}~ls~\MS{START}~[\MS{STOP}]. \] However, we want that the tape is right in this case, so we make a small change on the machine:

\begin{definition}[$\MS{MatchOption}$]
  \label{def:MatchOption}
  ~
\begin{lstlisting}[style=semicoqstyle]
$\MS{MatchOption}$ := If ($\LiftAlphabet{\MS{MatchSum}}{f}$)
             Then Return Nop true
             Else Return (Move L) false.
\end{lstlisting}
\end{definition}

\begin{lemma}[Correctness of $\MS{MatchOption}$]
  \label{lem:MatchSum_Realise}
  $\MS{MatchOption} \RealiseIn7 MatchOptionRel$ with
\begin{lstlisting}[style=semicoqstyle]
$MatchOptionRel :=$
  $\lambda t~(y, t').$ $\forall (o:\Option(X)).$ $t[0] \simeq o \rightarrow$ match $y$, $o$
      [false, $\None$ => $isRight(t'[0])$
      |true, $\Some x$ => $t'[0] \simeq x$
      |_, _ => $\False$
      ].
\end{lstlisting}
\end{lemma}
Note that we had to add $2$ extra steps: one for the conditional and one for the $\MS{Move}$ in the $\None$-case.

\todo{Derive constructors}


\todo{More Matches and Constructors, e.g.\ lists, pairs}


\subsection{Copy Values}
\label{sec:copy}

In Section~\ref{sec:CopySymbols}, we defined a machine that copies symbols until a certain symbol from one tape to another tape.  In
Section~\ref{sec:MoveToSymbol}, we also defined a machine that moves the head to a certain symbol.  We want to use these machines to define a machine
that copies a value from tape $t[0]$ to tape $t[1]$.  By the convention we set up in Section~\ref{sec:value-containing}), if we write new symbols to a
tape, this tape must be right.  With other words, the machine $\MS{CopySymbols}$ can assume that the ``target'' tape is right.  Formally, the
correctness relation is defined as:
\begin{definition}[Correctness relation of $\MS{CopyValue}$]
  \label{def:CopyValue_Rel}
  ~
  \[
    CopyValueRel := \lambda t~t'. \forall (x:X).~t[0] \simeq x \rightarrow isRight~t[1] \rightarrow t'[0] \simeq x \land t'[1] \simeq x.
  \]
% \begin{lstlisting}[style=semicoqstyle]
% CopyValueRel :=
%   $\lambda t~t.\forall (x:X).$
%     $t[0] \simeq x \rightarrow$
%     $isRight t[1] \rightarrow$
%     $t'[0] \simeq x \land$
%     $t'[1] \simeq x.$
% \end{lstlisting}
\end{definition}

The algorithm of $\MS{CopyValue}$ works as follows.  First, the machine moves the head of tape $0$ to right, from the start symbol to the stop symbol.
Then it copies the symbols, from the stop symbol to the start symbol, to tape $1$.

\begin{definition}[$\MS{CopyValue}$]
  \label{def:CopyValue}
  ~
  \begin{multline*}
    \MS{CopyValue} := \\
    \LiftTapes{(\MS{MoveToSymbol}~(\lambda x. x=\MS{STOP})~~id)}{\Vector{0}}
    \Seq
    \MS{CopySymbolsL}~(\lambda x. x=\MS{START})
  \end{multline*}
\end{definition}

Note that the second parameter of $\MS{MoveToSymbol}$ is the a translation function.  In this case, it should simply move around leave the symbols
unchanged.

\begin{lemma}[Correctness of $\MS{CopyValue}$]
  \label{lem:CopyValue_Realise}
  $\MS{CopyValue} \Realise CopyValueRel$.
\end{lemma}

The proof of Lemma~\ref{lem:CopyValue_Realise} is technical.  We have several lemmas about the functions $CopySymbolFun$ and $MoveToSymbolFun$, and
the corresponding runtime functions.

The runtime of $\MS{CopyValue}$ is linear in size of the encoding of $x$.
\begin{lemma}[Runtime of $\MS{CopyValue}$]
  \label{lem:CopyValue_TerminatesIn}
  ~
  \[
    \MS{CopyValue} \TerminatesIn (\lambda t~k.~\exists(x:X).~t[0] \simeq x \land 25 + 12 \cdot \size{x} \leq k).
  \]
\end{lemma}

Although $\MS{CopyValue}$ terminates for all tapes, we restricted runtime relations to reasonable tapes, i.e.\ in this case tape vectors $t$ that
actually have a symbol on $t[0]$.  The reason for that is, that we want to relate the value to the runtime.

\subsection{Translate Values}
\label{sec:translate-value}

In Section~\ref{sec:value-containing}, we observed, that the containing relation is ambiguous: if $X$ is minimally encodable over $\Sigma$, there may
be two retractions $f_1, f_2 : \Sigma \hookrightarrow \Tau$ on the alphabet $\Tau$.  In Section~\ref{sec:MoveToSymbol}, we gave the
$\MS{MoveToSymbol}$ machine the feature to translate the symbols it read.  Using this feature, we define a machine that translates between the two
possibilities of the encoding of $X$ on $\Tau$.  Therefore we have to define a function $tanslate : \Tau^+ \to \Tau^+$.

\begin{definition}[Translation between two encodings]
  \label{def:translate}
  Let $f_1, f_2 : \Sigma \hookrightarrow \Tau$ be two retractions on $\Tau$.
  \begin{alignat*}{2}
    & translate~f_1~f_2~(\tau) &~:=~&
    \begin{cases}
      f_2(\sigma)  & f_1^{-1}(\tau) = \Some{\sigma} \\
      \MS{UNKNOWN} & f_1^{-1}(\tau) = \None
    \end{cases} \\
    & translate~f_1~f_2~(\tau) &~:=~& \tau \qquad\text{(if $\tau \in \{\MS{UNKNOWN}, \MS{START}, \MS{STOP}\}$)} 
  \end{alignat*}
\end{definition}

This function translates a symbol of $\Tau$ to $\Sigma$, using the partial inversion function $f_1^{-1}$ and afterwards applies the injection $f_2$
from $\Sigma$ to $\Tau$ and the (implicit) injection from $\Tau$ to $\Tau^+$.

\begin{definition}[$\MS{Translate}$]
  ~
  \begin{alignat*}{2}
    & \MS{Translate}~f_1~f_2 &~:=~& \MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~(translate~f_1~f_2) \Seq \\
    &                        &~  ~& \MS{MoveToSymbolL}~(\lambda x.~x=\MS{START})~id.
  \end{alignat*}
\end{definition}

\begin{lemma}[Correctness of $\MS{Translate}$]
  $\MS{Translate}~f_1~f_2 \Realise TranslateRel~f_1~f_2$ with
  \[
    TranslateRel~f_1~f_2 := \lambda t~t'.~\forall(x:X).~t[0] \simeq_{f_1} x \rightarrow t[0] \simeq_{f_2} x.
  \]
\end{lemma}


\subsection{Reset Tapes}
\label{sec:reset-tape}

The aforementioned machine $\MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~id$ can also be used to ``reset'' a tape.  This means that if the tape contains
a value, after the execution of this machine, the tape is right.  This is especially important to prevent memory leaks in loops, where we may want to
write on a tape multiple times.  We must reset each ``used'' tape before writing on it again.

\begin{definition}[$\MS{ResetTape}$]
  \label{def:Reset}
  $\MS{ResetTape} := \MS{MoveToSymbol}~(\lambda x.~x=\MS{STOP})~id$
\end{definition}

\begin{lemma}[Correctness of $\MS{ResetTape}$]
  $\MS{ResetTape} \Realise ResetTapeRel$ with
  \[
    ResetTapeRel := \lambda t~t'.~\forall(x:X).~t[0] \simeq x \rightarrow isRight(t'[0]).
  \]
\end{lemma}





%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
