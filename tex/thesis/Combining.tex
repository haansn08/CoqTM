\chapter{Combining Turing Machines}
\label{chap:combining}

We have defined the notion of multi-tape Turing machines and basic machines in Chapter \ref{chap:definitions}.  Now we want to construct bigger
machines, for example a single-tape machine that moves the head to the right or to a certain symbol.

\section{Control Flow Operators}
\label{sec:control}

We define control flow operators, like ``match'', ``if then else'', ``sequential composition'', and ``while''.
As a result, we get a shallow-embeded language for programming multi-tape Turing machines in an imperative way.

\subsection{Match}
\label{sec:match}

Asperti and Ricciotti \cite{asperti2015} also define the control flow operators sequential composition, conditional, and while.  However, for the
conditional they have to give one explicit ``else'' state.  Giving an explicit state is very tedious for complex machines.  That is why we use the
generalised notion of partioned machines.  For example, for the conditional $\If{M_1}{M_2}{M_3}$, $M_1$ is partitioned over $\Bool$.  If $M_1$
terminated in a ``positive'' state (i.e. a state beloning to the partition $\true$), $M_2$ is executed after $M_1$.  Else it executes $M_3$ after
$M_1$.  We observe that sequential composition and conditional can be defined as instances of a more general operator we call $\MS{Match}$.

Let $M : \TM_\Sigma^n(F)$ and $f \from F \to \TM_\Sigma^n(F')$ be a function from partitions to machines.  We define
$\MS{Match}~M~f : \TM_\Sigma^n(F')$.

\begin{definition}[$\MS{Match}~M~f$]
  \label{def:Match}
  \begin{alignat*}{3}
    & Q                  &~:=~& Q_M +  \sum_{y:F} Q_{f(y)} \\
    & start              &~:=~& \inl start_M \\
    \delta ~&(\inl q, s) &~:=~&
    \begin{cases}
      \bigl(\inr (part_M~q, start_{f (part_M~q)}), (\None, N)^n \bigr) & halt_M(q) \\
      \Let{(q', a) := \delta_M(q, s)}{\left(\inl q', a \right)} & \lnot halt_M(q)
    \end{cases} \\
    \delta ~&(\inr q, s) &~:=~& \Let{(q', a) := \delta_{f(\pi_1 q)} (\pi_2 q, s)}{\bigl( \inr (\pi_1 q, q'), a \bigr)} \\
    halt   ~&(\inl  q)   &~:=~& \false \\
    halt   ~&(\inr  q)   &~:=~& halt_{f(\pi_1~q)} (\pi_2~q) \\
    part   ~&(\inl  q)   &~:=~& \_ \\
    part   ~&(\inr  q)   &~:=~& part_{f(\pi_1~q)} (\pi_2~q)
  \end{alignat*}
\end{definition}

In Definition~\ref{def:Match}, the $part$ value for $\inl$ is unimportant, because the states of $M_1$ are not terminating states.  We just use a
canonical value.

\begin{figure}
  \center
  \input{fig-MatchExample}
  \caption{Example of a $\MS{Match}$.  The left box stands for the first machine $M_1:\TM_\Sigma^n(\Bool)$.  The states $q_1$ and $q_2$ are mapped to
    $\true$, $q_3$ is mapped to $\false$.  After the $\MS{Match}$ reaches one of the injections of the terminal states $q_1, \cdots, q_3$ of $M_1$, it
    continues its execution either in the top case machine $M_2$ or in the bottom case machine $M_3$.  The halting states of $\MS{Match}$ are exactly
    the injections of the halting states of the case-machines.}
  \label{fig:match}
\end{figure}

\subsubsection{Correctness of Match}
\label{sec:Match-correct}


$\MS{Match}~M~f$ first executes a copy of $M$.  When it reaches a final state $q$ of $M$, it does a ``$\MS{Nop}$'' action and changes to to the
injection of the start state of the machine $f(part~q)$.  When $\MS{Match}~M~f$ reaches a state that is the injection of a final state of a machine
$M'$, it terminates.  The correctness part of the semantics can be expressed using the following lemma:

\begin{lemma}[Correctness of $\MS{Match}~M~f$]
  \label{lem:Match_Realise}
  Let $R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$ and $R'~y \subseteq \Tape_\Sigma^n \times F' \times \Tape_\Sigma^n$ for all $y:F$.
  If $M \vDash R$ and $f~y \vDash R'~y$ for all $y:F$, then
  \[
    \MS{Match}~M~f \vDash \bigcup_{y:F} \bigl( R\at y \circ R'~y \bigr)
  \]
\end{lemma}



\todo{Proof correctness Match}


\section{Machine Transformations}
\label{sec:transformations}

There is a problem when we want to combine machines --- for example using sequential composition:
The number of tapes and the alphabets of both machines have to be exactly the same.
How can we re-use a single-tape Turing machine when we want to build a multi-tape machine?
How can we combine two machines with different alphabets?






\section{Examples}
\label{sec:combining-examples}




%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
