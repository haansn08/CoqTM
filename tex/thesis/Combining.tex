\chapter{Combining Turing Machines}
\label{chap:combining}

We have defined the notion of multi-tape Turing machines and basic machines in Chapter \ref{chap:definitions}.  Now we want to construct bigger
machines, for example a single-tape machine that moves the head to the right or to a certain symbol.

\section{Control Flow Operators}
\label{sec:control}

We define control flow operators, like ``match'', ``if then else'', ``sequential composition'', and ``while''.
As a result, we get a shallow-embeded language for programming multi-tape Turing machines in an imperative way.

\subsection{Match}
\label{sec:match}

Asperti and Ricciotti~\cite{asperti2015} also define the control flow operators sequential composition, conditional, and while.  However, for the
conditional they have to give one explicit ``else'' state.  Giving an explicit state is very tedious for complex machines.  That is why we use the
generalised notion of partioned machines.  For example, for the conditional $\If{M_1}{M_2}{M_3}$, $M_1$ is partitioned over $\Bool$.  If $M_1$
terminated in a ``positive'' state (i.e. a state beloning to the partition $\true$), $M_2$ is executed after $M_1$.  Else it executes $M_3$ after
$M_1$.  We observe that sequential composition and conditional can be defined as instances of a more general operator we call $\MS{Match}$.

Let $M : \TM_\Sigma^n(F)$ and $f \from F \to \TM_\Sigma^n(F')$ be a function from partitions to machines.  We define
$\MS{Match}~M~f : \TM_\Sigma^n(F')$.

\begin{definition}[$\MS{Match}~M~f$]
  \label{def:Match}
  \begin{alignat*}{3}
    & Q                  &~:=~& Q_M +  \sum_{y:F} Q_{f(y)} \\
    & start              &~:=~& \inl start_M \\
    \delta ~&(\inl q, s) &~:=~&
    \begin{cases}
      \bigl(\inr (part_M~q, start_{f (part_M~q)}), (\None, N)^n \bigr) & halt_M(q) \\
      \Let{(q', a) := \delta_M(q, s)}{\left(\inl q', a \right)} & \lnot halt_M(q)
    \end{cases} \\
    \delta ~&(\inr q, s) &~:=~& \Let{(q', a) := \delta_{f(\pi_1 q)} (\pi_2 q, s)}{\bigl( \inr (\pi_1 q, q'), a \bigr)} \\
    halt   ~&(\inl  q)   &~:=~& \false \\
    halt   ~&(\inr  q)   &~:=~& halt_{f(\pi_1~q)} (\pi_2~q) \\
    part   ~&(\inl  q)   &~:=~& \_ \\
    part   ~&(\inr  q)   &~:=~& part_{f(\pi_1~q)} (\pi_2~q)
  \end{alignat*}
\end{definition}

In Definition~\ref{def:Match}, the $part$ value for $\inl$ is unimportant, because the states of $M_1$ are not terminating states.  We just use a
canonical value.

\begin{figure}
  \center
  \input{fig-MatchExample}
  \caption{Example of a $\MS{Match}$.  The left box stands for the first machine $M_1:\TM_\Sigma^n(\Bool)$.  The states $q_1$ and $q_2$ are mapped to
    $\true$, $q_3$ is mapped to $\false$.  After the $\MS{Match}$ reaches one of the injections of the terminal states $q_1, \cdots, q_3$ of $M_1$, it
    continues its execution either in the top case machine $M_2$ or in the bottom case machine $M_3$.  The halting states of $\MS{Match}$ are exactly
    the injections of the halting states of the case-machines.}
  \label{fig:match}
\end{figure}

\subsubsection{Correctness of Match}
\label{sec:Match-correct}


$\MS{Match}~M~f$ first executes a copy of $M$.  When it reaches a final state $q$ of $M$, it does a ``$\MS{Nop}$'' action and changes to to the
injection of the start state of the machine $f(part~q)$.  When $\MS{Match}~M~f$ reaches a state that is the injection of a final state of a machine
$M'$, it terminates.  The correctness part of the semantics can be expressed using the following lemma:

\begin{lemma}[Correctness of $\MS{Match}~M~f$]
  \label{lem:Match_Realise}
  Let $R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$ and $R'~y \subseteq \Tape_\Sigma^n \times F' \times \Tape_\Sigma^n$ for all $y:F$.
  If $M \vDash R$ and $f~y \vDash R'~y$ for all $y:F$, then
  \[
    \MS{Match}~M~f \vDash \bigcup_{y:F} \bigl( R\at y \circ R'~y \bigr)
  \]
\end{lemma}


\todo{In the above relation, a unpartioned relation is composed with a partioned relation!}
\todo{Proof correctness of $\MS{Match}$}


\subsubsection{Runtime of Match}
\label{sec:match-runtime}

To specify the runtime of $\MS{Match}~M~f$, we need to know: first, the relation that $M$ realisis, second, the runtime relation in that $M$
terminates, and third, for each $y:F$ the runtime of $f~y$.


\begin{lemma}[Runtime of $\MS{Match}~M~f$]
  Let $R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$, $T \subseteq \Tape_\Sigma^n \times \Nat$, and
  $T'~y \subseteq \Tape_\Sigma^n \times \Nat$ for all $y:F$.  If $M \vDash R$, $M \downarrow T$, and $f~y \downarrow T'~y$ for all $y:F$, then
  $\MS{Match}~M~f \downarrow \MS{MatchT}~R~T~T'$, where
  \[
    \MS{MatchT}~R~T~T' :=
    \lambda~t~i.~ \exists~i_1~i_2.~T~t~i_1 \land 1+i_1+i_2 \le i \land
      \forall~y~t'.~ R~t~y~t' \rightarrow T'~y~t'~i_2
  \]
  % (fun tin i => exists i1 i2, T1 tin i1 /\ 1 + i1 + i2 <= i /\ forall tout yout, R1 tin (yout, tout) -> T2 yout tout i2)

\end{lemma}


\subsubsection{Derived Operators}
\label{sec:match-derived-operators}

As mentioned above, conditional and sequential composition can be defined as instances of the Match operator.  For the conditional
$\If{M_1}{M_2}{M_3}$ with $M_1 : \TM_\Sigma^n(\Bool)$, $M_2, M_3 : \TM_\Sigma^n(F')$, $f$ simply maps $\true$ to $M_2$ and $\false$ to $M_3$.  For the
sequential composition $M_1 \Seq M_2$ with $M_1 : \TM_\Sigma^n(F)$ and $M_2 : \TM_\Sigma^n(F')$, $f$ maps all partitions of $F$ to $M_2$.

\begin{definition}[Conditional]
  \label{def:If}
  Let $M_1 : \TM_\Sigma^n(\Bool)$, $M_2, M_3 : \TM_\Sigma^n(F')$.
  \[
    \If{M_1}{M_2}{M_3} := \MS{Match}~M_1~
    \Bigl(
    \lambda~b.~
    \begin{cases}
      M_1 & b \\\
      M_2 & \lnot b
    \end{cases}
    \Bigr)
  \]
\end{definition}

\begin{definition}[Sequencial composition]
  Let $M_1 : \TM_\Sigma^n(F)$ and $M_2 : \TM_\Sigma^n(F')$ .
  \[
    M_1 \Seq M_2 := \MS{Match}~M_1~
    \bigl(
    \lambda~\_.~M_2
    \bigr)
  \]
\end{definition}



\subsection{While}
\label{sec:While}


The machine $\While M$ essentially behaves like a ``do-while'' loop in imperative languages like C.  At the end of the execution of the loop body $M$,
$M$ decides either to continue or break out of the loop.  If $M$ terminated in the partiton $\None$, then the loop is continued, and if $M$ terminated
in $\Some{y}$, the loop brakes and $\While M$ terminates in $y$.  When $M : \TM_\Sigma^n(\Option(F))$, then $\While M : \TM_\Sigma^n(F)$.


\begin{definition}[$\MS{While}~M$]
  \label{def:While}
  Let $M : \TM_\Sigma^n(\Option(F))$ and $def:F$.
  \begin{alignat*}{3}
    & F              &~:=~& F \\
    & Q              &~:=~& Q_M \\
    & start          &~:=~& start_M \\
    \delta ~& (q, s) &~:=~&
    \begin{cases}
      (q,       (\None, N)^n) & halt_M(q) \land part_M(q) = \Some y \\
      (start_M, (\None, N)^n) & halt_M(q) \land part_M(q) = \None \\
      \delta_M (q,s)    & \lnot halt_M(q)
    \end{cases} \\
    halt ~& q      &~:=~& halt_M(q) \land \MS{isSome}(part_M(q)) \\
    part ~& q      &~:=~&
    \begin{cases}
      y   & part_M(q) = \Some y \\
      def & part_M(q) = \None
    \end{cases}
  \end{alignat*}
\end{definition}

In Definition~\ref{def:While}, we have to assume that $F$ is inhabited.  However, the choice of $def:F$ is semantically irrelevant, because $\While M$
only halts in states where $part_M(q)$ has a $\Some{.}$ value.

\subsubsection{Correctness of While}
\label{sec:While-correct}

\todo{}


\subsubsection{Runtime of While}
\label{sec:While-runtime}

We can not simply give a runtime relation in that $\While M$ terminates, because we do not know the number of iterations in general.

\todo{}




\section{Machine Transformations}
\label{sec:transformations}

We observe that whenever we want to combine machines, the numbers of tapes and alphabets of all involved machines have to match.

For example, assume that we have a one-tape machine that moves the head to the right.  If we need a two-tape machine that moves both tapes to the
rigth, we would like to use sequencial composition and move one tape after the other tape to right.  But we would need two two-tape machines: one that
moves the first tape to the right and one that moves the second tape to the right.  There are multiple ways to solve this problem.  For example, we
could define a class of $n$-tape machines that move the $i$th tape to the right and leave all other tapes unchanged.  However, it is in general easier
to build and prove correctness of small machines that operate on a minimal amount of tapes.  Asperti and Ricciotti~\cite{asperti2015} defined an
\emph{injecting} operator that translates an one-tape machine into a $1+n$-tape machine.  We generalised this approach and implemented an operator
that takes an $m$-tape machine and yields an $n$-tape machine, where $m \le n$.

The second part of this problem is how to combine machines with different alphabets.  For example, if we have a machine $\MS{Add}$ that sums
(encodings of) natural numbers, we could want to build a machine $\MS{Sum}$ that sums numbers in a list of numbers.  Consider an alphabet
$\Sigma_\Nat$ where we could ``encode'' natural numbers on, and an alphabet $\Sigma_{\List(\Nat)}$ to ``encode'' lists of natural numbers.  If the
alphabet $\Sigma_\Nat$ is ``included'' in $\Sigma_{\List(\Nat)}$, we would like to ``lift'' $\MS{Add}$ to the alphabet $\Sigma_{\List(\Nat)}$, to
define $\MS{Sum}$.

Asperti and Ricciotti~\cite{asperti2015} avoid the latter problem.  They consider a fixed alphabet to ``encode'' all needed data on, to implement an
universal Turing machine.  However, this approach does not scale.  When the you need to change the alphabet, for example because you have to add a new
``data type'', they must change the definitions of the involved smaller machines (which are combined using the injecting operation).  That is why we
also introduce an operator that \emph{lifts} a machine to a bigger alphabet.

\subsection{$n$-Lift}
\label{sec:n-Lift}

\todo{}


\subsection{$\Sigma$-Lift}
\label{sec:sigma-Lift}


\todo{}




\section{Examples}
\label{sec:combining-examples}




%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
