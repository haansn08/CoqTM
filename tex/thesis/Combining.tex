\chapter{Combining Turing Machines}
\label{chap:combining}

In Chapter \ref{chap:definitions}, we have defined the notion of multi-tape Turing machines and basic machines.  In this chapter, we want to construct
more complex machines, for example a single-tape machine that moves the head to the right or to a certain symbol.

\section{Control Flow Operators}
\label{sec:control}

We define control flow operators, like ``match'', ``if then else'', ``sequential composition'', and ``while''.
As a result, we get a shallow-embeded language for programming multi-tape Turing machines in an imperative way.

\subsection{Match}
\label{sec:match}

Asperti and Ricciotti~\cite{asperti2015} also define the control flow operators sequential composition, conditional, and while.  However, for the
conditional they have to give one explicit ``else'' state.  Giving an explicit state is very tedious for complex machines.  That is why we use the
generalised notion of partioned machines.  For example, for the conditional $\If{M_1}{M_2}{M_3}$, $M_1$ is partitioned over $\Bool$.  If $M_1$
terminated in a ``positive'' state (i.e. a state beloning to the partition $\true$), $M_2$ is executed after $M_1$.  Else it executes $M_3$ after
$M_1$.  We observe that sequential composition and conditional can be defined as instances of a more general operator we call $\MS{Match}$.  We give
proof scratches for the correctness and runtime in Subsection~\ref{sec:match-proofs}.

Let $M : \TM_\Sigma^n(F)$ and $M' \from F \to \TM_\Sigma^n(F')$ be a function from partitions to machines.  We define
$\MS{Match}~M~M' : \TM_\Sigma^n(F')$.

\begin{definition}[$\MS{Match}~M~M'$]
  \label{def:Match}
  \begin{alignat*}{3}
    & Q                  &~:=~& Q_M +  \sum_{y:F} Q_{M'(y)} \\
    & start              &~:=~& \inl start_M \\
    \delta ~&(\inl q, s) &~:=~&
    \begin{cases}
      \bigl(\inr (part_M~q, start_{M' (part_M~q)}), (\None, N)^n \bigr) & halt_M(q) \\
      \Let{(q', a) := \delta_M(q, s)}{\left(\inl q', a \right)} & \lnot halt_M(q)
    \end{cases} \\
    \delta ~&(\inr q, s) &~:=~& \Let{(q', a) := \delta_{M'(\pi_1 q)} (\pi_2 q, s)}{\bigl( \inr (\pi_1 q, q'), a \bigr)} \\
    halt   ~&(\inl  q)   &~:=~& \false \\
    halt   ~&(\inr  q)   &~:=~& halt_{M'(\pi_1~q)} (\pi_2~q) \\
    part   ~&(\inl  q)   &~:=~& \_ \\
    part   ~&(\inr  q)   &~:=~& part_{M'(\pi_1~q)} (\pi_2~q)
  \end{alignat*}
\end{definition}

In Definition~\ref{def:Match}, the $part$ value for $\inl$ is unimportant, because the states of $M_1$ are not terminating states.  We just use a
canonical value.

\begin{figure}
  \center
  \input{fig-MatchExample}
  \caption{Example of a $\MS{Match}$.  The left box stands for the first machine $M_1:\TM_\Sigma^n(\Bool)$.  The states $q_1$ and $q_2$ are mapped to
    $\true$, $q_3$ is mapped to $\false$.  After the $\MS{Match}$ reaches one of the injections of the terminal states $q_1, \cdots, q_3$ of $M_1$, it
    continues its execution either in the top case machine $M_2$ or in the bottom case machine $M_3$.  The halting states of $\MS{Match}$ are exactly
    the injections of the halting states of the case-machines.}
  \label{fig:match}
\end{figure}


$\MS{Match}~M~M'$ first executes a copy of $M$.  When it reaches a final state $q$ of $M$, it does a ``$\MS{Nop}$'' action (i.e.\ $(\None,N)^n$) and
changes to to the injection of the start state of the machine $M'(part~q)$.  When $\MS{Match}~M~M'$ reaches a state that is the injection of a final
state of a machine $M'~y$, it terminates.  The correctness part of the semantics can be expressed using the following lemma:

\begin{lemma}[Correctness of $\MS{Match}~M~M'$]
  \label{lem:Match_Realise}
  Let $R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$ and $R'~y \subseteq \Tape_\Sigma^n \times F' \times \Tape_\Sigma^n$ for all $y:F$.
  If $M \vDash R$ and $M'~y \vDash R'~y$ for all $y:F$, then
  \[
    \MS{Match}~M~M' \vDash \MS{MatchRel}~R~R'
  \]
  with
  \[
    \MS{MatchRel}~R~R' := \bigcup_{y:F} \bigl( R\at y \circ R'~y \bigr).
  \]
\end{lemma}

Note that in the relation $\MS{MatchRel}$, we compose the unpartioned relation $R \at y \subseteq \Tape_\Sigma^n \times \Tape_\Sigma^n$ with the partioned
relation $R'~y \subseteq \Tape_\Sigma^n \times F' \times \Tape_\Sigma^n$.

To specify the runtime of $\MS{Match}~M~M'$, we need to know the relation that $M$ realises, the runtime relation in that $M$ terminates, and for each
$y:F$ the runtime of $M'~y$.

\begin{lemma}[Runtime of $\MS{Match}~M~M'$]
  \label{lem:Match_Terminates}
  Let $R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$, $T \subseteq \Tape_\Sigma^n \times \Nat$, and
  $T'~y \subseteq \Tape_\Sigma^n \times \Nat$ for all $y:F$.  If $M \vDash R$, $M \downarrow T$, and $M'~y \downarrow T'~y$ for all $y:F$, then
  $\MS{Match}~M~M' \downarrow \MS{MatchT}~R~T~T'$, where
  \[
    \MS{MatchT}~R~T~T' :=
    \lambda~t~i.~ \exists~i_1~i_2.~T~t~i_1 \land 1+i_1+i_2 \le i \land
      \forall~y~t'.~ R~t~y~t' \rightarrow T'~y~t'~i_2
  \]
\end{lemma}


\subsubsection{Derived Operators}
\label{sec:match-derived-operators}

As mentioned above, conditional and sequential composition can be defined as instances of the Match operator.  For the conditional
$\If{M_1}{M_2}{M_3}$ with $M_1 : \TM_\Sigma^n(\Bool)$, $M_2, M_3 : \TM_\Sigma^n(F')$, $f$ simply maps $\true$ to $M_2$ and $\false$ to $M_3$.  For the
sequential composition $M_1 \Seq M_2$ with $M_1 : \TM_\Sigma^n(F)$ and $M_2 : \TM_\Sigma^n(F')$, $f$ maps all partitions of $F$ to $M_2$.

\begin{definition}[Conditional]
  \label{def:If}
  Let $M_1 : \TM_\Sigma^n(\Bool)$, $M_2, M_3 : \TM_\Sigma^n(F')$.
  \[
    \If{M_1}{M_2}{M_3} := \Match~M_1~
    \left(\lam{b}{\cond{b}{M_2}{M_3} \right})
  \]
\end{definition}

\begin{definition}[Sequencial composition]
  Let $M_1 : \TM_\Sigma^n(F)$ and $M_2 : \TM_\Sigma^n(F')$ .
  \[
    M_1 \Seq M_2 := \Match~M_1~
    \bigl(
    \lambda~\_.~M_2
    \bigr)
  \]
\end{definition}


\subsection{Proof of $\MS{Match}$}
\label{sec:match-proofs}

\todo{Did Asperti and Ricciotti do the same proof?}

The idea of the proofs of Lemma~\ref{lem:Match_Realise} and Lemma~\ref{lem:Match_Terminates} is to abstract two features of the machine: lifting of
configurations from one abstract machine to another abstract machines and sequence of two loops.  We formalise these two concepts for abstract
machines, i.e.\ we argue on the abstract $loop$ function.

For the first feature, \emph{lifting}, we assume two types $A$, $B$ for abstract configurations, an injective function $lift : A \to B$, two step
functions $f : A \to A$, $f' : B \to B$, and two halting function $h : A \to \Bool$, $h' : B \to \Bool$.  We assume that the step functions $f$ and
$f'$ is compatible with $lift$ in non-halting states of $A$.  Formally, this means
\[ \forall a:A.~\lnot h~x \rightarrow f' (lift~x) = lift (f~x). \]
The second assumptions is that $h'$ is compatible with $h$, w.r.t.\ $lift$, formally:
\[ \forall a:A.~h'(lift~x)=h~x. \]
Under these two assumptions we can show two lemmas that essentially say that the second abstract machine $B$ simulates the first machine $A$.
\begin{lemma}[Loop lifting]
  \label{lem:loop_lift}
  Under the two assumptions above:
  \begin{alignat*}{1}
    & \forall (k:\Nat)~(c_1~c_2 : A). \\
    & \quad loop~k~f ~h ~c_1 = \Some{c_2} \rightarrow \\
    & \quad loop~k~f'~h'~(lift~c_1) = \Some {lift~c_2}
  \end{alignat*}
\end{lemma}
\begin{proof}
  By induction over $k:\Nat$.
\end{proof}
\begin{lemma}[Loop unlifting]
  \label{lem:loop_unlift}
  Under the two assumptions above:
  \begin{alignat*}{1}
    & \forall (k:\Nat)~(a:A)~(b':B). \\
    & \quad loop~k~f'~h'~(lift~a) = \Some{b'} \rightarrow \\
    & \quad \exists (b:B).~loop~k~f~h~a = \Some b \land b'=lift~b
  \end{alignat*}
\end{lemma}
\begin{proof}
  By induction over $k:\Nat$.
\end{proof}

For the second feature, \emph{sequencing}, we assume a type $A$ with the step function $f \from A \to A$ and two halting functions
$h \from A \to \Bool$ and $h' \from A \to \Bool$.  We assume
\[
  \forall(a:A).~h~a = \false \rightarrow h'~a = \false,
\]
i.e.\ either $a$ is a halting state w.r.t.\ $h'$, or $a$ is a non-halting state w.r.t.\ $h$.
\begin{lemma}[Loop merging]
  \label{lem:loop_merge}
  Under the above assumption:
  \begin{align*}
    & \forall (k_1~k_2:\Nat)~(c_1~c_2~c_3 : A).\\
    & \quad loop~k_1~f~h ~c_1 = \Some{c_2} \rightarrow\\
    & \quad loop~k_2~f~h'~c_2 = \Some{c_3} \rightarrow\\
    & \quad loop (k_1+k_2)~f~h'~c_1 = \Some{c_3}.
  \end{align*}
\end{lemma}
\begin{proof}
  By induction over $k1:\Nat$, using Lemm~\ref{lem:loop}~(\ref{lem:loop_ge}).
\end{proof}
\begin{lemma}[Loop splitting]
  \label{lem:loop_split}
  Under the above assumption:
  \begin{align*}
    & \forall (k:\Nat)~(c_1~c_3 : A).\\
    & \quad loop~f~h'~c_1 = \Some{c_3} \rightarrow \\
    & \quad \exists (k_1~k_2:\Nat)~(c_2:A).\\
    & \quad \quad loop~f~h~c_1 = \Some{c_2} \land\\
    & \quad \quad loop~f~h~c_2 = \Some{c_3} \land\\
    & \quad \quad k \leq k_1 + k_2.
  \end{align*}
\end{lemma}
\begin{proof}
  By complete induction over $k:\Nat$.
\end{proof}


Back to the verification of $\Match~M~M'$.  In the following, we simply write $\Match$.  The executions of $\Match$ are essentially a sequence of a
lifted execution of $M$, a ``nop'' step, and steps of some machine $M'~y$.  We give the concrete lifting functions from $M$ to $\Match$ and from $M~y$
to $\Match$:
\begin{definition}[Liftings of $\Match$]
  We define the functions \\$liftL : \Conf_M \to \Conf_\Match$ and $liftR_y : \Conf_{M'~y} \to \Conf_\Match$:
  \begin{alignat*}{2}
    & liftL   & (q, t) &:= (\inl q,      t) \\
    & liftR_y & (q, t) &:= (\inr (y, q), t).
  \end{alignat*}
\end{definition}

For the sequential part, we also have to define the lifted halting function of \\$haltConfL : \Conf_\Match \to \Bool$:
\begin{definition}[Lifted halting function]
  \begin{alignat*}{2}
    & haltConfL & (\inl~q, t) &:= halt_M(q) \\
    & haltConfL & (\inr~q, t) &:= \true
  \end{alignat*}
\end{definition}

Using Lemma \ref{lem:loop_merge} and \ref{lem:loop_lift}, we can show the lemma we need for runtime:
\begin{lemma}[Merging parts of executions of $\Match$]
  \label{lem:Match_merge}
  Let $t : \Tape_\Sigma^n$, $k_1, k_2:\Nat$, $c_1=(q', t') : \Conf_M$ and $c_2=(q'', t'') : \Conf_{M'~y}$.
  \begin{itemize}
  \item If $M(t) \terminates^{k_1} c_1$ and
  \item $\bigl( M'~(part_M~q') \bigr) (t_1) \terminates^{k_2} c_2$, then
  \item $\Match(t) \terminates^{1+k_1+k_2} liftR(c_2)$.
  \end{itemize}
\end{lemma}
\begin{proof}
  We apply \ref{lem:loop_merge} and have to show:
  \begin{enumerate}
  \item $\forall a:\Conf_\Match.~ \lnot haltConfL~a \rightarrow \lnot \MS{haltConf}~a$.  This holds trivially by definition.
  \item $loop~k_1~step_\Match~haltConfL~(\MS{initConf}_\Match~t) =
    \Some{liftL~c1}$.  By definition, we have $\MS{initConf}_\Match~t=liftL(\MS{initConf}_M t)$.  The claim follows with Lemma~\ref{lem:loop_lift}.
  \item $loop~(1+k_2)~step_\Match~haltConf_\Match~(liftL~c1) =
    \Some{liftR(c_2)}$.  By definition, we know that the first step must be a ``nop'' transition from
    $liftL~c_1$ to $liftR~\bigl(\MS{initConf}_{M'(part_M~q')}~t' \bigr)$.
    It remains to show that
    $$ loop~k_2~step_\Match~haltConf_\Match~liftR \bigl(\MS{initConf}_{M'(part_M~q')}~t' \bigr) = liftR(c_2).$$
    This follows with Lemma~\ref{lem:loop_merge}.
  \end{enumerate}
\end{proof}

The runtime Lemma~\ref{lem:Match_Terminates} follows from Lemma~\ref{lem:Match_merge}.





\subsection{While}
\label{sec:While}


The machine $\While M$ essentially behaves like a ``do-while'' loop in imperative languages like C.  At the end of the execution of the loop body $M$,
$M$ decides either to continue or break out of the loop.  If $M$ terminated in the partiton $\None$, then the loop is continued, and if $M$ terminated
in $\Some{y}$, the loop brakes and $\While M$ terminates in $y$.  When $M : \TM_\Sigma^n(\Option(F))$, then $\While M : \TM_\Sigma^n(F)$.


\begin{definition}[$\MS{While}~M$]
  \label{def:While}
  Let $M : \TM_\Sigma^n(\Option(F))$ and $def:F$.
  \begin{alignat*}{3}
    & F              &~:=~& F \\
    & Q              &~:=~& Q_M \\
    & start          &~:=~& start_M \\
    \delta ~& (q, s) &~:=~&
    \begin{cases}
      (q,       (\None, N)^n) & halt_M(q) \land part_M(q) = \Some y \\
      (start_M, (\None, N)^n) & halt_M(q) \land part_M(q) = \None \\
      \delta_M (q,s)    & \lnot halt_M(q)
    \end{cases} \\
    halt ~& q      &~:=~& halt_M(q) \land \MS{isSome}(part_M(q)) \\
    part ~& q      &~:=~&
    \begin{cases}
      y   & part_M(q) = \Some y \\
      def & part_M(q) = \None
    \end{cases}
  \end{alignat*}
\end{definition}

In Definition~\ref{def:While}, we have to assume that $F$ is inhabited.  However, the choice of $def:F$ is semantically irrelevant, because $\While M$
only halts in states where $part_M(q)$ has a $\Some{.}$ value.

\subsubsection{Correctness of While}
\label{sec:While-correct}

The correctness of $\MS{While}$ can be easily expressed using the following relation:


\begin{definition}[$\MS{WhileRel}$]
  \label{def:While_Rel}
  Let $R \subseteq \Tape_\Sigma^n \times \Option(F) \times \Tape_\Sigma^n$.  $\MS{WhileRel}~R \subseteq \Tape_\Sigma^n \times F \times \Tape_\Sigma^n$
  is defined inductively by the following two rules:
  \[
    \inferrule{R~t~(\None, t') \and \MS{WhileRel}~t'~(y, t'')}{\MS{WhileRel}~t~(y, t'')}
    \quad
    \inferrule{R~t~(\Some y, t')}{\MS{WhileRel}~t~(y, t')}
  \]
\end{definition}


\begin{figure}
  \center
  \input{fig-WhileExample}
  \caption{Example for $\While M$ with $M:\TM_\Sigma^n(\Option(\Bool))$.  When the $M$ reaches the state $q_1$, the loop is continued, because $q_1$
    is in the partition $\None$ of $M$.  $q_2$ and $q_3$ are in the partition $\Some{\true}$ and $\Some{\false}$, therefore $\While M$ terminates in
    its partition $\true$ or $\false$, when the copy of $M$ terminated in $q_2$ or $q_3$.}
  \label{fig:while-example}
\end{figure}



We can also express this relation using the Kleene star:

\begin{lemma}[Alternative specification of $\While M$]
  ~
  \[
    \MS{WhileRel}~R \equiv (R \at \None)^* \circ \Bigl( \bigcup_{y:F} \bigl( R \at {\Some y} \bigr) \att y \Bigr)
  \]
\end{lemma}

Both definitions of $\MS{WhileRel}$ should really make clear what $\While~M$ does: It repeats the execution of $M$ as long as it terminated in
$\None$, and after it terminated in $\Some y$, it terminates in the partition $y$.  This is visualised in Figure~\ref{fig:while-example}.  However,
the inductive definition is more practical when we prove correctness of concrete $\MS{While}$ machines, because we can just do induction on the
inductive predicate.

\begin{lemma}[Correctness of $\MS{While}$]
  If $M \vDash R$, then $\While M \vDash \MS{WhileRel}~M$.
\end{lemma}


\todo{Proof scratch}


\subsubsection{Runtime of While}
\label{sec:While-runtime}

We can not simply give a runtime relation in that $\While M$ terminates, because we do not know the number of iterations in general.  However if we
know that $M$ realises $R$ and terminates in $T$, we can show $\While M \downarrow T'$ for another runtime relation $T'$, if $T'$ ``decreases'' in
terms of $R$ and $t$:

\begin{lemma}[Runtime of $\While M$]
  If $M \vDash R$, $M \downarrow T$.  We can show $\While M \downarrow T'$ under the following assumption:
  \begin{multline*}
    \forall~t~i.~
    T'~t~i \rightarrow
    \exists~i_1.~
    \forall~t'.~ \\
    \bigl(
    \forall~y.~ R~t~(\Some y, t') \rightarrow i_1 \le i
    \bigl) \quad\land\quad
    \bigl(
    R~t~(\None, t') \rightarrow
    \exists~i_2.~
    T'~t'~i_2 \land
    1 + i_1 + i_2 \le i
    \bigr)
  \end{multline*}
  % (forall (tin : tapes sig n) (i : nat),
  %        T' tin i ->
  %        exists i1,
  %          T tin i1 /\
  %          forall (ymid : option F) tmid,
  %            R tin (ymid, tmid) ->
  %            match ymid with
  %            | Some _ => i1 <= i
  %            | None => exists i2, T' tmid i2 /\ 1 + i1 + i2 <= i
  %            end)
\end{lemma}



\todo{Proof scratch}




\section{Machine Transformations}
\label{sec:transformations}

We observe that whenever we want to combine machines, the numbers of tapes and alphabets of all involved machines have to match.

For example, assume that we have a one-tape machine that moves the head to the right.  If we need a two-tape machine that moves both tapes to the
rigth, we would like to use sequencial composition and move one tape after the other tape to right.  But we would need two two-tape machines: one that
moves the first tape to the right and one that moves the second tape to the right.  There are multiple ways to solve this problem.  For example, we
could define a class of $n$-tape machines that move the $i$th tape to the right and leave all other tapes unchanged.  However, it is in general easier
to build and prove correctness of small machines that operate on a minimal amount of tapes.  Asperti and Ricciotti~\cite{asperti2015} defined an
\emph{injecting} operator that translates an one-tape machine into a $1+n$-tape machine.  We generalised this approach and implemented an operator
that takes an $m$-tape machine and yields an $n$-tape machine, where $m \le n$.

The second part of this problem is how to combine machines with different alphabets.  For example, if we have a machine $\MS{Add}$ that sums
(encodings of) natural numbers, we could want to build a machine $\MS{Sum}$ that sums numbers in a list of numbers.  Consider an alphabet
$\Sigma_\Nat$ where we could ``encode'' natural numbers on, and an alphabet $\Sigma_{\List(\Nat)}$ to ``encode'' lists of natural numbers.  If the
alphabet $\Sigma_\Nat$ is ``included'' in $\Sigma_{\List(\Nat)}$, we would like to ``lift'' $\MS{Add}$ to the alphabet $\Sigma_{\List(\Nat)}$, to
define $\MS{Sum}$.

Asperti and Ricciotti~\cite{asperti2015} avoid the latter problem.  They consider a fixed alphabet to ``encode'' all needed data on, to implement an
universal Turing machine.  However, this approach does not scale.  When the you need to change the alphabet, for example because you have to add a new
``data type'', they must change the definitions of the involved smaller machines (which are combined using the injecting operation).  That is why we
also introduce an operator that \emph{lifts} a machine to a bigger alphabet.

\subsection{$n$-Lift}
\label{sec:n-Lift}

\todo{}


\subsection{$\Sigma$-Lift}
\label{sec:sigma-Lift}


\todo{}




\section{Examples}
\label{sec:combining-examples}




%%% Local Variables:
%%% TeX-master: "thesis"
%%% End:
