\chapter{Simulating a Heap Machine}
\label{chap:heap}

\newcommand{\subst}[3]{{#1}^{#2}_{#3}}
\newcommand{\Ter}{\MS{Ter}}
\newcommand{\red}{\succ}


In this chapter, we use all our developed techniques to implement a multi-tape Turing machine that simulates another abstract machine.  First, we
define and motivate the semantics of this abstract machine.  After that, we implement the machine and prove its correctness and runtime.  We show that
this machine reduces the halting problem of the abstract machine to the halting problem of multi-tape Turing machines.

\section{Heap Machine}
\label{sec:heap}

The abstract machine we present here is a variant of the heap machine in Kunze et~al.~\cite{KunzeEtAl:2018:Formal}.  They show that states of their
abstract machine can be refined to terms of the weak call-by-value $\lambda$-calculus.  From that it follows that the halting problem of closed terms
of the weak $\lambda$-calculus reduces to the halting problem of their machine.  They also formalise their results in Coq.

\subsubsection{Weak Call-By-Value $\lambda$-Calculus}
\label{sec:L}

To motivate the heap machine, we briefly define the language $L$, which implements a subset of the $\lambda$-calculus called weak call-by-value
$\lambda$-calculus.  For more a more thoughtful treatment of this language, we refer to~\cite{ForsterSmolka17} and~\cite{KunzeEtAl:2018:Formal}.
Terms of this language are De~Bruijn terms, and are inductively defined by:
\begin{align*}
  s,t,u,v &~:~\Ter~::=~ (n:\Nat) ~|~ s~t ~|~ \lambda s
\end{align*}
The language $L$ uses simple substitution:
\begin{align*}
  \subst kku &~:=~u \\
  \subst nku &~:=~n &&\text{if}~n\neq k \\
  \subst{(st)}ku &~:=~(\subst sku)(\subst tku) \\
  \subst{(\lambda s)}ku &~:=~\lambda(\subst s{Sk}u)
\end{align*}
The reduction relation $s \red t$ is defined inductively on terms:
\begin{mathpar}
  \inferrule*{~}{(\lambda s) (\lambda t)\red\subst s0{\lambda t}} \and%
  \inferrule*{s\red s'} {st\red s't} \and%
  \inferrule* {t\red t'} {(\lambda s)t\red(\lambda s)t'}%
\end{mathpar}


\subsubsection{Heap Machine}
\label{sec:heap-def}

Instead of substituting expressions, the heap machine works with closures.  A closure is a program together with a variable binding.  Variable
bindings are implemented as pointers to a linked list, called \emph{heap}, of closures.  Programs are lists of tokens:
\begin{definition}[Program]
  \label{def:Tok}
  \begin{alignat*}{2}
    &Var  &~:=~& \Nat \\
    &Tok  &~::=~& \MS{VAR}(n:Var) ~|~ \MS{APP} ~|~ \MS{LAM} ~|~ \MS{RET} \\
    &Pro  &~:=~& \List(Tok)
  \end{alignat*}
\end{definition}

Programs essentially are linearised expressions of $L$.  The function $\gamma$ translates terms of $L$ to programs of the heap machine:
\begin{definition}[Compiling $L$ expressions]
  ~
  \begin{alignat*}{2}
    &\gamma&~n           &:= [\MS{VAR}~n] \\
    &\gamma&~(s~t)       &:= \gamma~s \app \gamma~t \app [\MS{APP}] \\
    &\gamma&~(\lambda s) &:= \MS{LAM} \cons \gamma~s
  \end{alignat*}
\end{definition}

The heap is implemented as a list of heap entries.  A heap entry may be empty or contain a closure and a pointer to the next heap entry.  Pointers are
implemented as list indices on the heap entry list.
\begin{definition}[Closures and heaps]
  \label{def:Heap}
  ~
  \begin{alignat*}{2}
    &Add  &~:=~& \Nat \\
    &Clos &~:=~& Add \times Pro \\
    &Entr &~:=~& \Option(Clos \times Add) \\
    &Heap &~:=~& \List(Entr)
  \end{alignat*}
\end{definition}
We use the letters $n:Var$, $t:Tok$, $P,Q:Pro$, $a,b:Var$, $g:Clos$, $e:Entr$, and $H:Heap$.

States of the abstract machine are triples of two closure lists and a heap:
\[
  (T, V, H) \quad:\quad \List(Clos) \times \List(Clos) \times Heap.
\]
$T$ is called the control stack.  It contains the closures that the machine has to process.  The second stack $V$ is called the argument stack.  The
$\MS{APP}$ command fetches the functions and arguments from that stack.


We first explain what each rule does, and then define the reduction predicate\\$(T,V,H) \succ (T',V',H')$ formally.


When the first closure on the control stack is $(a, \MS{\textbf{APP}} \cons P)$, the machine fetches two closures $g$ and
$(b,Q)$ from the argument stack.  The closure $g$ corresponds to the argument of the application.  The second closure
$(b,Q)$ corresponds to the called function, where $b$ is the pointer to environment in that the argument is free.  It binds the argument to
$g$, by putting a new heap entry $(g,b)$ on the heap.  The heap machine continues executing $(c,Q)$ and the ``rest closure'' $(a,P)$, where
$c$ is the pointer to the new heap entry.


If the head control closure is $(a, \MS{\mathbf{LAM}} \cons P)$, the machine splits the linearised program $P$ into body $Q$ of the
$\lambda$-expression and the rest program $P'$.  Then it pushes the closure of the rest program $(a,P')$ on the control stack, and the ``body
closure'' $(a,Q)$ on the argument stack.  The splitting is realised with the function $\phi : Pro \to \Option(Pro \times Pro)$.  For example, {\small
  \[
    \phi[\MS{VAR}(0); \MS{LAM}; \MS{APP}; \MS{RET}; \MS{RET}; \MS{VAR}(1)] = \Some{([\MS{VAR}(0); \MS{LAM}; \MS{APP}; \MS{RET}], [\MS{VAR}(1)])}.
  \]
}%
The first $\MS{RET}$ matches to the $\MS{LAM}$ in the program above, so it is part of the first partition.  $\phi$ is formally defined with a
tail-recursive auxiliary function:
\begin{definition}[$\phi$]
  \label{def:jumpTarget}
  We define $\phi~P :=~ \phi'~0~\nil~P$ with the auxiliary function $\phi' : \Nat \to Pro \to Pro \to \Option(Pro \times Pro)$, which is defined by
  recursion on $P:Pro$.
  \begin{alignat*}{4}
    &\phi'&~0~   &~Q&~(\MS{RET} \cons P) &&~:=~& \Some{(Q,P')} \\
    &\phi'&~(S~k)&~Q&~(\MS{RET} \cons P) &&~:=~& \phi'~k~(Q \app [\MS{RET}])~P \\
    &\phi'&~k    &~Q&~(\MS{LAM} \cons P) &&~:=~& \phi'~(S~k)~(Q \app [\MS{LAM}])~P \\
    &\phi'&~k    &~Q&~(t        \cons P) &&~:=~& \phi'~k~(Q \app [t])~P \\
    &\phi'&~k    &~Q&~              \nil &&~:=~& \None
  \end{alignat*}
\end{definition}


If the first token on the first closure of the control stack is $\MS{\mathbf{VAR}}(n)$, the machine looks up the
$n$th entry in the environment on the heap at the address $a$.  Then, it pushes this closure to the value stack.  The function $lookup : Heap \to Add
\to Var \to \Option(Clos)$ starts at the heap entry at the address $a$, and gets the $n$th entry. We write $H[a,n]$ for
$lookup~H~a~n$.  The function is defined by recursion on $n$:
\begin{definition}[$lookup$]
  \label{def:lookup}
  $H[a,n]$ is defined by recursion on $n$:
  \[
    H[a,n] :=
    \begin{cases}
      \Some{g} & H[a]=\Some{\Some{(g,b)}} \land n=0 \\
      H[b,n-1] & H[a]=\Some{\Some{(g,b)}} \land n>0 \\
      \None & \text{else}
    \end{cases}
  \]
  where $H[\cdot] : \Option(Entr)$ is the standard list lookup function.
\end{definition}



We formally define the reduction rules.  Note that there is no reduction rule for $\MS{RET}$, because the purpose of the token $\MS{RET}$ is solely to
mark the end of the encoding of the body of a $\lambda$-expression.
\begin{definition}[Semantics of the heap machine]
  {\small
    \begin{alignat*}{4}
      & \left((a, (\MS{APP} \cons P)) \cons T, g \cons (b, Q) \cons V, H\right) &~\red~& \left((c, Q) \cons (a,P) \cons_{tr} T, V, H'\right)
      \quad&& \text{if $put~H~\Some{(g,b)} = (c,H')$} \\
      & \left((a, (\MS{LAM} \cons P)) \cons T, V, H\right)                      &~\red~& \left((a, P') \cons_{tr} T, (a,Q) \cons V, H\right)
      \quad&& \text{if $\phi~P = \Some{(Q, P')}$} & \\
      & \left((a, (\MS{VAR}(n) \cons P)) \cons T, V, H\right)                   &~\red~& \left((a, P) \cons_{tr} T, g \cons V, H\right)
      \quad&& \text{if $H[a,n]=\Some{g}$} &
    \end{alignat*}
  }
  with $put~H~c := (\length{H}, H \app [c]) $.\\
  The tail-recursion optimised $\cons_{tr}$ is defined as follows:
  \begin{alignat*}{3}
    & (a, \nil) &~\cons_{tr}~& H &~:=~& H \\
    & (a, P   ) &~\cons_{tr}~& H &~:=~& (a, P) \cons H \qquad\text{if $P \neq \nil$}
  \end{alignat*}

  We write $\red^k$ for the relational power (cf.\ Definition~\ref{def:pow}) and $\red^*$ for the reflexive transitive closure of $\red$ (cf.\
  Definition~\ref{def:Kleene}).
\end{definition}

The tail-recursion optimised cons ($\cons_{tr}$) makes sure that no empty closures are\\ pushed on a closure stack.




\section{Implementation of a Simulator}
\label{sec:heap-implementation}

First, we notice that all types in Definition~\ref{def:Heap}, except program Tokens ($Tok$), are encodable over canonical alphabets, according to
Definition~\ref{def:basic-encodings}.
\begin{definition}[Encoding of heaps]
  \label{def:Heap-encode}
  The type of tokens ($Tok$) is isomorphic to the sum of $ATok := \MS{APP} ~|~ \MS{LAM} ~|~ \MS{RET}$ and $\Nat$.  $ATok$ is encodable on itself
  (since it is finite), and $Var = \Nat$ is encodable on $\Sigma_{Var} := \Sigma_\Nat$.  Then $Tok$ is encodable on
  $\Sigma_{Tok} := \Sigma_{ATok+\Nat}$.  All other types are encodable according to Definition~\ref{def:basic-encodings}.
  For completeness, the alphabets are:\\
  $\Sigma_{Pro} := \Sigma_{\List(Tok)}$, $\Sigma_{Add} := \Sigma_\Nat$, $\Sigma_{Clos}:=\Sigma_{Add \times Pro}$,
  $\Sigma_{Entr} := \Sigma_{\Option(Clos \times Add)}$, and $\Sigma_{Heap} := \Sigma_{\List(Entr)}$.
\end{definition}

For the functions $\phi$ and $lookup$, we define machines that compute these function in a lesser strict sense than
Definition~\ref{def:Computes2_Rel}.  The Turing machines only save the input-values that a caller machine needs again.  For example, we have a machine
$\MS{Nth'}$ that saves the list, but not the index.  The second change is that for functions with optional outputs, like $nth$, we do not extend the
alphabet with $\Sigma_{\Option(X)}$.  Instead, we encode whether the output is $\Some{\cdot}$ or $\None$ with the partition $\Bool$.  In case that the
output is $\None$, the machine terminates in $\false$ and the output tape stays right.

We define a machine $\MS{Step} : \TM(\Option(\Unit))$ (we specify the alphabet and the tape number later) that simulates steps of the heap machine.
The tapes $0$, $1$, and $2$ encode the control stack, the value stack, and the heap, respectively.  If the heap machine does a step $s \red s'$, then
if the tapes contain $s$, $\MS{Step}$ terminates in $\None$ and the resulting tapes contain $s'$.  Otherwise, if $s$ is a terminating state,
$\MS{Step}$ terminates in the partition $\Some\unit$.  For that, we implement auxiliary machines for each of the three step rules.  Lastly, we define
$\MS{Loop} := \While~\MS{Step}$.  This machine terminates if and only if the heap state that is encoded on the tape of $\MS{Loop}$ terminates.  We
include execution protocols but omit definitions of machines and correctness relations, as they can be derived from the execution protocols.  This
means that we prove that the halting problem of the heap machine reduces to the halting problem of $n$-tape Turing machines.


\subsection{$\MS{Lookup}$}
\label{sec:Lookup}

The machine $\MS{Lookup} : \TM_\Sigma^5(\Bool)$ realises the heap $lookup$ function.  Note, that the heap is just a linked list of closures, where the
pointers in this linked lists are indices.  It uses that machine $\MS{Nth}' : \TM_\Sigma^4(\Bool)$, which is $\MS{Nth}$ from Section~\ref{sec:Nth}
with the two changes mentioned above.

First we consider the alphabet of $\MS{Lookup}$.  We can encode closures on the heap alphabet $\Sigma_{Heap}$, but when $\MS{Step}$ calls $H[a,n]$,
$a$ is the current heap address from the first closure on the control stack, and $n$ is the variable the first variable token of the program of that
closure.  Thus, $a$ and $n$ are encoded on a different closure alphabet, than the closures on the heap.  We define $\MS{Lookup}$ on an alphabet
$\Sigma$, with retractions $f_{Heap} : \Sigma_{Heap} \hookrightarrow \Sigma$ and $f_{Clos} : \Sigma_{Clos} \hookrightarrow \Sigma$.  The second
retraction correspond to the encoding of $a$ and $n$.  The retraction
\[ f_{Clos'} : \Sigma_{Clos} \hookrightarrow \Sigma := RetrFst \circ RetrOpt \circ RetrList \circ f_{Heap} \]%
is the canonical retraction of closures from the heap.

There are three relevant retractions $\Sigma_\Nat \hookrightarrow \Sigma$, depending on whether the number is an heap pointer in the heap alphabet,
or a variable or heap pointer from the stack alphabet.
\begin{enumerate}
\item Address of the pointer of an heap on the stack alphabet:
  \[
    f_{add} := RetrFst \circ f_{Clos'}
  \]
\item Variable in a token of a closure on the stack alphabet:
  \[
    f_{var} := RetrRgt \circ RetrList \circ RetrSnd \circ f_{Clos'}
  \]
  Note that $RetrRgt : \Sigma_\Nat \hookrightarrow \Sigma_{Tok}$.
\item Pointer to the next heap entry:
  \[
    f_{next} := RetrSnd \circ RetrOpt \circ RetrList \circ f_{Heap}
  \]
\end{enumerate}

Since the function $lookup$ is tail-recursive, we define the step machine with the type $LookupStep : \TM_\Sigma^5(\Option(\Bool))$.  It first calls
the list lookup machine ($\MS{Nth'}$).  If it failed, $\MS{Lookup}$ immediately terminates $\false$.  Else, it makes a case-distinction on the heap
entry $e : \Option(Clos \times Add)$.  In case it is $\None$, $\MS{Lookup}$ terminates in $\false$.  Else it destructs the closure $g = (g,b)$ and
makes a case-distinction over $n$.  If $n=0$, $\MS{LookupStep}$ resets the tapes for $b$ and $n$, translates $g$ from $f_{Clos'}$ to $f_{Clos}$ and
returns $\true$.  Else it translates $b$ from $f_{next}$ to $f_{add}$, moves it to the tape that contained $a$, and repeats the loop.  We visualise
the execution in the latter two cases in Tables~\ref{tab:exec-LookupStep-S} and~\ref{tab:exec-LookupStep-0}.

\begin{table}[t]
  \centering
  \scriptsize
  \begin{tabular}{l||l|l|l|l|l|l|l|l}
    Input      & $\MS{Nth'}$      & $\MS{MatchOpt}$       & $\MS{MatchPair}$     & $\MS{MatchNat}$ & $\MS{CopyValue}$  & $\MS{Translate}$ & $\MS{Reset}$ & $\MS{Reset}$ \\ \hline
    $0:H$      & $0:H$            &                       &                      &                 &                   &                  &              &              \\
    $1:a$      & $1:\dashv$       &                       &                      &                 & $1:b$             & $0:b$            &              &              \\
    $2:n$      &                  &                       &                      & $0:n'$          &                   &                  &              &              \\
    $3:\dashv$ &                  &                       & $1: g$               &                 &                   &                  &              & $0:\dashv$   \\
    $4:\dashv$ & $2:\Some{(g,b)}$ & $0:(g,b)$             & $0:b$                &                 & $0:b$             &                  & $0:\dashv$   &              \\
  \end{tabular}
  \caption{Execution protocol of $\MS{LookupStep}$ in case $H[a] = \Some{\Some{(g,b)}}$ and $n=S~n'$.  It terminates in the partition $\None$.  The
    translation is from $f_{next}$ to $f_{add}$.}
  \label{tab:exec-LookupStep-S}
\end{table}
\begin{table}[t]
  \centering
  \scriptsize
  \begin{tabular}{l||l|l|l|l|l|l|l}
    Input      & $\MS{Nth'}$      & $\MS{MatchOpt}$       & $\MS{MatchPair}$     & $\MS{MatchNat}$ & $\MS{Reset}$ & $\MS{Reset}$ & $\MS{Translate}$ \\ \hline
    $0:H$      & $0:H$            &                       &                      &                 &              &              &                  \\
    $1:a$      & $1:\dashv$       &                       &                      &                 &              &              &                  \\
    $2:n$      &                  &                       &                      & $0:n'$          &              & $0:\dashv$   &                  \\
    $3:\dashv$ &                  &                       & $1: g$               &                 &              &              & $0:g$            \\
    $4:\dashv$ & $2:\Some{(g,b)}$ & $0:(g,b)$             & $0:b$                &                 & $0:\dashv$   &              &                  \\
  \end{tabular}
  \caption{Execution protocol of $\MS{LookupStep}$ in case $H[a] = \Some{\Some{(g,b)}}$ and $n=0'$.  It terminates in the partition $\Some\true$.  The
    translation is from $f_{Clos'}$ to $f_{Clos}$.}
  \label{tab:exec-LookupStep-0}
\end{table}

\begin{definition}[$\MS{LookupStep}$]
  \label{def:Lookup_Step}
  ~
  \begin{align*}
    & \MS{LookupStep} := \\
    & \quad \MS{If}~(\MS{Nth'}~f_{heap}~f_{add}) \\
    & \quad \MS{Then}~\MS{If}~(\LiftBoth{\MS{MatchOption}}{RetrList ~\circ~ f_{heap}}{\Vector{4}}) \\
    & \quad \phantom{\MS{Then}}~\MS{Then}~\LiftBoth{\MS{MatchPair}}{RetrOpt \circ RetrList ~\circ~ f_{heap}}{\Vector{4;3}} \Seq \\
    & \quad \phantom{\MS{Then}~\MS{Then}}~\MS{If}~(\LiftBoth{\MS{MatchNat}}{f_{var}}{\Vector{2}}) \\
    & \quad \phantom{\MS{Then}~\MS{Then}~\MS{Then}}~\MS{Then}~ \MS{Return}~\bigl(
      \LiftTapes{\MS{CopyValue}}{\Vector{4;1}} \Seq
      \LiftTapes{\MS{Translate}~f_{next}~f_{ad}}{\Vector{1}} \Seq \\
    & \quad \phantom{\MS{Then}~\MS{Then}~\MS{Then}~\MS{Then}~\MS{Return}\bigl(}
      \LiftTapes{\MS{Reset}}{\Vector{4}} \Seq
      \LiftTapes{\MS{Reset}}{\Vector{3}}
      \bigr)~{\None} \\
    & \quad \phantom{\MS{Then}~\MS{Then}~\MS{Then}}~\MS{Else}~~~ \MS{Return}~\bigl(
      \LiftTapes{\MS{Reset}}{\Vector{4}} \Seq
      \LiftTapes{\MS{Reset}}{\Vector{2}}
      \bigr)~{\Some\true} \\
    & \quad \phantom{\MS{Then}}~\MS{Else}~~~ \Return{\Nop}{\Some\false} \\
    & \quad \MS{Else}~~~ \Return{\Nop}{\Some\false}
  \end{align*}
\end{definition}

The step machine terminates in $\Some\false$ in two cases.  Either the list lookup failed, or it returned the empty heap entry $H[a]=\Some\None$.  In
the successfully termination case (cf.\ Table~\ref{tab:exec-LookupStep-0}), $\MS{LookupStep}$ resets the afterwards unneeded tapes, especially $n$, of
which the value may have been overwritten.

Because no initialisation or clean-up is needed before or after the loop, we can define $\MS{Lookup} := \While~\MS{LookupStep}$.  The correctness
relation of $\MS{Lookup}$ says that if it terminated in the partition $\true$, we have $H[a,n] = \Some{g}$ for some closure $g$, and tape~$3$ contains
$g$ w.r.t.\ the retraction $f_{Clos}$.  Furthermore, the input tape~$0$ still contains $H$ and all other tapes are reseted.  In case $\MS{Lookup}$
terminated in $\false$, the postcondition only asserts that $H[a,n]=\None$.  Note that there two possible reasons for that: Either $H[a]=\None$, or
$H[a]=\Some\None$.  We do not distinct these two failure cases, because we then know that the state of the heap machine is a terminating state.  In
this case, $\MS{Step}$ only needs to terminate in $\Some\unit$.

\begin{lemma}[Correctness of $\MS{Lookup}$]
  \label{lem:Lookup_Realise}
  $\MS{Lookup} \Realise LookupRel$
  with
  \small
  \begin{alignat*}{1}
    & LookupRel := \\
    &\quad \lambda t~(y, t').~\forall H~a~n.~ t[0] \simeq H \rightarrow t[1] \simeq_{f_{add}} a \rightarrow t[2] \simeq_{f_{var}} n \rightarrow isRight~t[3] \rightarrow isRight~t[4] \rightarrow \\
    &\quad\quad \MS{if}~y~\MS{then}~\bigl(\exists g.~H[a,n] = \Some{g} \land \\
    &\quad\quad \phantom{\MS{if}~y~\MS{then}~\bigl(\exists g.~} t'[0] \simeq H \land isRight~t'[1] \land isRight~t'[2] \land t'[3] \simeq_{f_{Clos}} g \land isRight~t[4]\bigr) \\
    &\quad\quad \MS{else}~ H[a,n] = \None.
\end{alignat*}
\end{lemma}

\todo{How to present runtime here?}

\subsection{$\MS{JumpTarget}$}
\label{sec:JumpTarget}

\todo{I need to find a better name: This machine actually splits a program into two halves. It matches lambdas with returns and splits the program on the first unmatched return}

The machine $\MS{JumpTarget}$ realises the function $\phi$.  $\phi$, as defined in Definition~\ref{def:Heap}, splits the program into two halves at
the first $\MS{RET}$ token that does not match with a $\MS{LAM}$ token.

First, we derive constructor and deconstructor machines for tokens.  As tokens are defined as the sum type of two encodable types, we only have to
combine constructors and deconstructors from Section~\ref{sec:constructors-deconstructors}.






%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "thesis"
%%% End:
