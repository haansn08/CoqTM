\chapter{Simulating a Heap Machine}
\label{chap:heap}

In this chapter, we use all techniques, to implement a Turing machine that simulates an abstract heap machine.  First, we briefly define the semantics
of this abstract machine.  After that, we implement a Turing machine that simulates this machine and prove its correctness and polynomial runtime
overhead.  We show that this machine reduces the halting problem of the heap machine to the halting problem of multi-tape Turing machines.

\section{Heap Machine}
\label{sec:heap-def}

The abstract machine we present here is a variant of the heap machine in Kunze et~al.~\cite{KunzeEtAl:2018:Formal}.  Idem show that terms of the weak
call-by-value lambda-calculus can be refined to states of said abstract machine and formalise their results in Coq.
\todo{Should I include the compilation function $\gamma$ from lambda-terms to programs?}

Values of this machines are closures.  A closure is a program and a pointer to the environment of bindings.  This environment is implemented as a
linked list of closures.  Programs are lists of tokens, as defined below.
\begin{definition}[Programs, closures, and heaps]
  ~
  \begin{alignat*}{2}
    &Tok  &~::=~& \MS{VAR}(n:\Nat) ~|~ \MS{APP} ~|~ \MS{LAM} ~|~ \MS{RET} \\
    &Pro  &~:=~& \List(Pro) \\
    &Add  &~:=~& \Nat \\
    &Clos &~:=~& Add \times Pro \\
    &Entr &~:=~& \Option(Clos \times Add) \\
    &Heap &~:=~& \List(Entr)
  \end{alignat*}
\end{definition}

The states of the abstract machine are triples:
\[
  \Conf := \List(Clos) \times \List(Clos) \times Heap.
\]
The first list is the control stack and the second list is the value stack.  We define the small-step operational semantics of this machine as a
binary relation $\succ$ between states of the machine.
\begin{definition}[Semantics of the heap machine]
  {\small
    \begin{alignat*}{4}
      & \left((a, (\MS{LAM} \cons P)) \cons T, V, H\right)                      &~\succ~& \left((a, P') \cons_{tr} T, (a,Q) \cons V, H\right)
      \quad&& \text{if $\phi~P = \Some{(Q, P')}$} & \\
      & \left((a, (\MS{APP} \cons P)) \cons T, g \cons (b, Q) \cons V, H\right) &~\succ~& \left((c, Q) \cons (a,P) \cons_{tr} T, V, H'\right)
      \quad&& \text{if $put~H~\Some{(g,b)} = (c,H')$} \\
      & \left((a, (\MS{VAR}(n) \cons P)) \cons T, V, H\right)                   &~\succ~& \left((a, P) \cons_{tr} T, g \cons V, H\right)
      \quad&& \text{if $H[a,n]=\Some{g}$} &
    \end{alignat*}
  }
  with $put~H~c := (\length{H}, H \app [c]) $.\\
  We define $\phi~P :=~ \phi'~0~\nil~P$ with the auxiliary function $\phi' : \Nat \to Pro \to Pro \to \Option(Pro \times Pro)$, which is defined by
  recursion on $P:Pro$.
  \begin{alignat*}{4}
    &\phi'&~0~   &~Q&~(\MS{RET} \cons P) &&~:=~& \Some{(Q,P')} \\
    &\phi'&~(S~k)&~Q&~(\MS{RET} \cons P) &&~:=~& \phi'~k~(Q \app [\MS{RET}])~P \\
    &\phi'&~k    &~Q&~(\MS{LAM} \cons P) &&~:=~& \phi'~(S~k)~(Q \app [\MS{LAM}])~P \\
    &\phi'&~k    &~Q&~(t        \cons P) &&~:=~& \phi'~k~(Q \app [t])~P \\
    &\phi'&~k    &~Q&~              \nil &&~:=~& \None \\
  \end{alignat*}
  The heap lookup function $H[a,n] : \Option(Clos)$ is defined by recursion on $n$.
  \[
    H[a,n] :=
    \begin{cases}
      \Some{g}  & H[a]=\Some{\Some{(g,b)}} \land n=0 \\
      H[b, n-1] & H[a]=\Some{\Some{(g,b)}} \land n>0 \\
      \None     & \text{else}
    \end{cases}
  \]
  where $H[\cdot] : \Option(Entr)$ is the list lookup function. \\
  The tail-recursion optimised cons operation $\cons_{tr}$ is defined as follows:
  \begin{alignat*}{3}
    & (a, \nil) &~\cons_{tr}~& H &~:=~& H \\
    & (a, P   ) &~\cons_{tr}~& H &~:=~& (a, P) \cons H \qquad\text{if $P \neq \nil$}
  \end{alignat*}
\end{definition}

We write $\succ^k$ for the relational power (cf.\ Definition~\ref{def:pow}) and $\succ^*$ for the reflexive transitive closure of $\succ$ (cf.\
Definition~\ref{def:Kleene}).

The function $\phi$ matches $\MS{LAM}$ with $\MS{RET}$.  It splits the program into two parts, the first part is the ``body'' of a linearised lambda
expression and the second part the rest of the program, for example:%
{\small
  \[
    \phi[\MS{VAR}(0); \MS{LAM}; \MS{APP}; \MS{RET}; \MS{RET}; \MS{VAR}(1)] = \Some{([\MS{VAR}(0); \MS{LAM}; \MS{APP}; \MS{RET}], [\MS{VAR}(1)])}.
  \]
}%
The first $\MS{RET}$ matches to the $\MS{LAM}$ in the program above, so it is part of the first partition.  When the heap machine has a $\MS{LAM}$
token as first control token, it finds the rest of the program using $\phi$ and pushes the body on the control stack.

When the first control token is $\MS{App}$, the machine fetches two closures from the value stack.  The first closure, $g$, corresponds to the
parameter of the application.  The second closure, $(b,Q)$, corresponds to the called function.  The machine pushes $g$ on the heap.  After that it
continues executing $Q$, by adding a new closure $(c,Q)$ to the control stack, where $c$ is the updated head of the heap.

If the first control token is $\MS{VAR}(n)$, the machine looks up the $n$th entry in the environment on the heap at the address $a$, and pushes this
closure to the value stack.


\section{Implementation As Turing Machine}
\label{sec:heap-implementation}

We use the programming techniques from Chapter~\ref{chap:programming}.  For simplicity, we do not use the strict definition of functional computation.
The machines only save the input-values that the caller machines need again.  For example, we have a machine $\MS{Nth'}$ that saves the list, but not
the index.  The second change is that for functions with optional outputs, like $nth$, we do not extend the alphabet with $\Sigma_{\Option(X)}$.
Instead, we encode whether the output is $\Some{\cdot}$ or $\None$ with the partition $\Bool$.  In case that the output is $\None$, the machine
terminates in $\false$ and the output tape stays right.




\section{Reduction of the Halting Problem}
\label{sec:halting-problem}

% We can refine terms of closed lambda expressions to states of the abstract heap machine.  Hence, the halting problemm of lambda terms reduces to the
% halting problem of multi-tape Turing machines.



%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "thesis"
%%% End:
