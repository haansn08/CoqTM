\chapter{Compound Machines}
\label{cha:compound}

In this chapter, we build complex machines, using the combinators developed in Chapter~\ref{chap:combining}, as well as the tapes-lift of
Chapter~\ref{chap:lifting}.  However, we do not use the alphabet lift in this chapter.  We also prove correctness and runtime of these machines.

The general approach, when we prove correctness of a machine $M$, i.e.\ if we want to show $M \vDash R$, is to first define a relation $R'$ that $M$
realises.  For that, we use the correctness lemmas of the combinators, lifts, and all concrete machines ``involved''.  The main part of the proof is
applying Lemma~\ref{lem:Realise_monotone} and showing $R' \subseteq R$.  Note that the first part of the proof, i.e.\ generating the relation $R'$
such that $M \vDash R'$, is mechanical.  Indeed, we can automatise this step in Coq, see more in Chapter~\ref{chap:implementation}.

When $M$ always terminates in constant time $k$, we show $M \vDash^k R$ instead.  Using the monotonicity Lemma~\ref{lem:RealiseIn_monotone}, we can
prove correctness and (constant) runtime at once.

For (non-constant) runtime, we use the dual approach.  However, we have an exception for $\While$, where we have to apply
Lemma~\ref{lem:While_TerminatesIn} directly instead of using the anti-monotonicity Lemma~\ref{lem:TerminatesIn_monotone}.

\section{$\Nop$}
\label{sec:Nop}

Using the alphabet-lift (Definition~\ref{def:LiftAlphabet}) and $\MS{Null}$ (Definition~\ref{def:Null}), it is easy to define an $n$-tape machine
$\Nop : \TM_\Sigma^n$ for every alphabet $\Sigma$ and number of tapes $n$:
\begin{definition}[$\Nop$]
  $Nop := \LiftTapes{\MS{Null}}{\nil}.$
\end{definition}
Note that because $\MS{Null}$ is a 0-tape machine, and $\Nop$ is supposed to be an $n$-tape machine, the index-vector must be the vector
$\nil : \Fin_n^0$.

\begin{lemma}[Correctness of $\Nop$]
  \label{lem:Nop_Sem}
  $\Nop \vDash^0 NopRel$ with $NopRel := \lambda t~t'.~t'=t$.
\end{lemma}
\begin{proof}
  By applying monotonicity of $\vDash^\cdot$ (Lemma~\ref{lem:RealiseIn_monotone}) and the correctness of $\MS{Null}$ (Lemma~\ref{lem:Null_Sem}), it
  remains to show that $\LiftTapes{NullRel}{\nil} \subseteq NopRel$.  To show the equality $t'=t$ we show $t'[i]=t[i]$ for all $i:\Fin_n$.  This
  follows with the equality part of the relation $\LiftTapes{NullRel}{\nil}$, because $i \notin \nil$.
\end{proof}

Note that the correctness relation of $\Nop$ can also be expressed using the identity relation $Id$:
\[
  \MS{NopRel} \equiv Id.
\]
However, we have the convention to define relations of concrete machine (classes) in $\lambda$-notation, i.e.\ not using relational operators.  Also
note that the tape $t'$ is per convention always on the left side of the equality.  This convention makes rewriting of tapes uniform; therefore,
rewriting of tapes can be automatised in Coq.

\section{$\MS{WriteString}$}
\label{sec:WriteString}

The machine $\MS{WriteString}~d~str$ writes a fixed string $str:\List(\Sigma)$ in the direction $d$.  It is defined by recursion over the string:
\begin{definition}[$\MS{WriteString}$]
  \begin{alignat*}{3}
    &\MS{WriteString}~d~&&(\nil)         &~:=~& \Nop \\
    &\MS{WriteString}~d~&&(s \cons str') &~:=~& \MS{WriteMove}~s~d \Seq \MS{WriteString}~d~str'.
  \end{alignat*}
\end{definition}

Note that this is the our only machine we define per recursion.  However, the way we proof correctness in constant time (depending on the length of
$str$) is still the same.

The relation that $\MS{WriteString}$ ``automatically'' realises in $3 \cdot \length{str}$ steps is the following:
\begin{lemma}
  $\MS{WriteString}~d~str \vDash^{3 \cdot \length{str}} R'~d~str$ with
  \begin{alignat*}{3}
    &\MS{R'}~d~&&(\nil        ) &~:=~& NopRel \\
    &\MS{R'}~d~&&(s \cons str') &~:=~& DoActRel(\Some{s}, d) \circ \MS{R'}~d~str'.
  \end{alignat*}
\end{lemma}
\begin{proof}
  By induction on $str:\List(\Sigma)$, using the monotonicity Lemma~\ref{lem:RealiseIn_monotone}, the correctness of $Nop$ (Lemma~\ref{lem:Nop_Sem}),
  the correctness of $\MS{WriteMove}$ (which is defined by $\MS{DoAct}$; Lemma~\ref{lem:DoAct_Sem}), and correctness of sequential composition for
  constant time (Lemma~\ref{lem:Seq_RealiseIn}).
\end{proof}
\todo{I don't have corollaries yet about seq, and if, and $\vDash^\cdot$.}

We define the actual relation of $\MS{WriteString}$ in terms of a recursive function on tapes:
\begin{lemma}[Correctness of $\MS{WriteString}$]
  \label{lem:WriteString_Sem}
  Let $d:\Move$ and $str:\List(\Sigma)$.
  \[ \MS{WriteString}~d~str \vDash^{4\cdot\length{str}} WriteStringRel~d~str \]
  with
  $WriteStringRel~d~str := \lambda t~t'.~t' = WriteStringFun~d~t~str'$ and
  \begin{alignat*}{3}
    &WriteStringFun~d~t~&&(\nil        ) &~:=~& t \\
    &WriteStringFun~d~t~&&(s \cons str') &~:=~& WriteStringFun~d~\bigl(doAct~t~(\Some{s}, d)\bigr)~str'
  \end{alignat*}
\end{lemma}
\begin{proof}
  We apply the monotonicity Lemma~\ref{lem:RealiseIn_monotone} and have to show\\
  $R'~d~str \subseteq WriteStringRel~d~str$.  We show this by induction on $str$.
\end{proof}

Note that we could as well use the $\MS{Mirror}$ operator instead of parametrising the machine $\MS{WritingString}$ over the direction.  However, in
this particular example, this approach seems to be easier.

\section{$\MS{MovePar}$}
\label{sec:MovePar}

The two-tape machine $\MS{MovePar}~d~d'$ combines two $\MS{Move}$ machines.  It first moves the $0$th\footnote{To avoid confusion with zero-based
  indices, we write the $0$th or $1$st tape, instead of the first or second tape.} tape in direction $d$ and after that the $1$st tape in
direction $d'$.
\begin{definition}[$\MS{MovePar}$]
  \label{def:MovePar}
  $\MS{MovePar}~d~d' := \LiftTapes{(\MS{Move}~d)}{\Vector{0}} \Seq \LiftTapes{(\MS{Move}~d')}{\Vector{1}}$.
\end{definition}
\begin{lemma}[Correctness of $\MS{MovePar}$]
  \label{lem:MovePar_Sem}
  $\MS{MovePar}~d~d' \vDash^3 MoveParRel~d~d'$ with
  \[ MoveParRel~d~d' := \lambda t~t'.~t'[0]=\MS{mv}~d~t[0] ~\land~ t'[1]=\MS{mv}~d'~t[1]. \]
\end{lemma}
\begin{proof}
  We have to show
  $$
    \LiftTapes{(\MS{DoActRel}(\None,d ))}{\Vector{0}} \circ
    \LiftTapes{(\MS{DoActRel}(\None,d'))}{\Vector{1}} \subseteq
    \MS{MovePairRel}~d~d'.
  $$
  We assume tapes $t, t', t''$ such that $(\LiftTapes{(\MS{DoActRel}(\None,d ))}{\Vector{0}})~t~t'$ and \\
  $(\LiftTapes{(\MS{DoActRel}(\None,d'))}{\Vector{1}})~t'~t''$, and have to show $t''[0]=\MS{mv}~d~t[0]$ and $t''[1]=\MS{mv}~d'~t[1]$.  By definition,
  we know $t'[0]=\MS{mv}~d~t[0]$ and $t'[1]=t[1]$ (because $1 \notin \Vector{0}$).  We also know $t''[1]=\MS{mv}~d'~t'[1]$ and $t''[0]=t'[0]$ (because
  $0 \notin \Vector{1}$).  The goal follows trivially.
\end{proof}
Note that this kind of proof is very mechanical: We only need to unfold the relations, and rewrite tapes.  Indeed, these steps are automatised in Coq.
Thus, we do not do more proofs of this kind on paper.

\section{$\MS{CopySymbols}$}
\label{sec:CopySymbols}

The machine $\MS{CopySymbols}~h : \TM_\Sigma^2$, where $h:\Sigma\to\Bool$, is a compound machine involving a $\While$-loop.  The machine reads the
symbol on tape $0$.  It reads the symbol on tape $0$ and writes it to tape $1$.  If the symbol fulfils $h$, then the machine halts.  Else it moves
both tapes right and continues the loop.  The machine also halts if there was no current symbol to read from tape $0$.

We first define the machine for the step.  Since we want to apply the $\While$ operator on the step machine, it must be partitioned over
$\Option(\Unit)$; $\Some\unit$ means break out of the loop and $\None$ means repeat the loop.
\begin{definition}[$\MS{CopySymbolsStep}$]
  \label{CopySymbols_Step}
  \begin{multline*}
    \MS{CopySymbolsStep}~f :=
    \Match(\LiftTapes{Read}{\Vector{0}}) \\
    \Biggl(
    \lambda s.
    \begin{cases}
      \Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}}\bigr)}{\Some\unit} & s=\Some{x} ~\land~ f(x)=\true \\
      \Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}} \Seq \MS{MovePar}~R~R\bigr)}{\None} & s=\Some{x} ~\land~ f(x)=\false \\
      \Return{\Nop}{\Some\unit} & s=\None
    \end{cases}
    \Biggr)
  \end{multline*}
\end{definition}

\begin{lemma}[Correctness of $\MS{CopySymbolsStep}$]
  \label{lem:CopySymbols_Step_Sem}
  ~
  \[
    \MS{CopySymbolsStep} \vDash^7 CopySymbolsStepRel
  \]
  with
  \begin{multline*}
    CopySymbolsStepRel := \lambda t~(y, t').~\\
    \begin{cases}
      t'[0] = t[0]           \land t'[1]=\MS{wr}~t[1]~\Some{x}         \land y=\Some\unit & \MS{current}~t[0]=\Some{x} \land       f(x) \\
      t'[0] = \MS{mv}~R~t[0] \land t'[1]=\MS{doAct}~t[1]~(\Some{x}, R) \land y=\None      & \MS{current}~t[0]=\Some{x} \land \lnot f(x) \\
      t' = t \land y=\Some\unit                                                           & \text{else}
    \end{cases}
  \end{multline*}
\end{lemma}
\todo{This looks \emph{ugly}!!!!!}
\begin{proof}
  Mechanical, with case-analysis over $t[0]$.
\end{proof}

Now, to define $\MS{CopySymbols}$, we simply apply the $\While$ operator to the step machine:
\begin{definition}[$\MS{CopySymbols}$]
  \label{def:CopySymbols}
  $\MS{CopySymbols}~f := \While(\MS{CopySymbolsStep}~f)$.
\end{definition}

The correctness of $\MS{CopySymbols}$ can be expressed using a recursive function on tapes:
\begin{lemma}[Correctness of $\MS{CopySymbols}$]
  \label{lem:CopySymbols_Realise}
  \
  $$\MS{CopySymbols}~f \vDash CopySymbolsRel~f$$
  with $CopySymbolsRel~f := \lambda t~t' = CopySymbolsFun~f~t$ and
  \begin{multline*}
    CopySymbolsFun~f~t :=\\
    \begin{cases}
      \Vector{t[0]; \MS{wr}~t[1]~(\Some{x})}                                  & \MS{current}(t[0])=\Some{x} \land f(x) \\
      CopySymbolsFun~f~\Vector{\MS{mv}~R~t[0]; \MS{doAct}~t[1]~(\Some{x}, R)} & \MS{current}(t[0])=\Some{x} \land \lnot f(x) \\
      t                                                                       & \MS{current}(t[0])=\None
    \end{cases}
  \end{multline*}
  Note that the function $CopySymbolsFun$ is not structural recursive.  It terminates because tapes have only finitely many symbols.
\end{lemma}
\begin{proof}
  To show: $WhileRel~CopySymbolsStepRel \subseteq CopySymbolsRel$.  By $\While$-induction (Lemma~\ref{lem:WhileInduction}).
\end{proof}

We observe that the runtime of $\MS{CopySymbols}$ only depends on the $0$th tape.  Therefore, we define a function
$CopySymbolsSteps : \Tape_\Sigma^n \to \Nat$ that overestimates the number of steps needed for the loop, depending on the $0$th tape.  Note that
$\While$ requires one additional step for each repeat of the loop.
\begin{lemma}[Runtime of $\MS{CopySymbols}$]
  $\MS{CopySymbols} \downarrow CopySymbolsT$ with \\
  $CopySymbolsT := \lambda t~k.~CopySymbolsSteps(t) \leq k$ and
  \begin{multline*}
    CopySymbolsSteps (t) := \\
    \begin{cases}
      8                                & \MS{current}(t)=\Some{x} \land f(x) \\
      8 + CopySymbolSteps(\MS{mv}~R~t) & \MS{current}(t)=\Some{x} \land \lnot f(x) \\
      8                                & \MS{current}(t)=\None
    \end{cases}
  \end{multline*}
\end{lemma}
\begin{proof}
  We use the termination Lemma~\ref{lem:While_TerminatesIn} of $\While$, with the correctness and (constant) runtime of $\MS{CopySymbolsStep}$
  (Lemma~\ref{lem:Realise_total} with Lemma~\ref{lem:CopySymbols_Realise}).\\
  Let $CopySymbolsSteps~t[0] \leq k$.  We have two cases.
  \begin{enumerate}
  \item We have $CopySymbolsStepRel~t~(\Some\unit, t')$.  Therefore, we know that either $\MS{current}(t[0])=\Some{x}$ with $f(x)=\true$, or
    $\MS{current}(t[0])=\None$.  In both cases, we have $CopySymbolsSteps(t[0]) = 8$.  Thus, we have
    $$ 7 \leq CopySymbolSteps(t[0]) = 8 \leq k. $$
  \item We have $CopySymbolsStepRel~t~(\None, t')$.  Therefore, we have $\MS{current}(t[0])=\Some{x}$ with $f(x)=\false$, and $t'[0]=\MS{mv}~R~t[0]$.
    Then, we have
    $$ 1+7+CopySymbolSteps(t'[0]) = CopySymbolSteps(t[0]) \leq k.$$
    \qed
  \end{enumerate}
\end{proof}
% Note that we see in the proof that we could replace the $8$s in the non-recursive parts of the runtime functions with $7$s.



%%% Local Variables:
%%% TeX-master: "thesis"
%%% End: