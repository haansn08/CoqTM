\chapter{Simple Machines}
\label{chap:compound}

In this chapter, we build and verify simple machines, using the primitive machines from Chapter~\ref{chap:basic}, the combinators developed in
Chapter~\ref{chap:combining}, and the tapes-lift of Chapter~\ref{chap:lifting}.  The machines in this chapter will be useful in the next chapter.
However, we do not use the alphabet-lift yet.  We show how we prove correctness and termination of machines in general.

When we prove $M \Realise R$ for a machine $M$ and its correctness relation $R$, the general approach is to first find a relation $R'$ that $M$
realises.  To find the relation $R'$, we apply the correctness lemmas of the combinators, lifts, and concrete machines.  Then, we apply
Lemma~\ref{lem:Realise_monotone}, and have to show $R' \subseteq R$.  Finding the relation $R'$ is mechanical, and indeed, we automate this step in
Coq, see more in the appendix.  So the main part of the proof is showing $R' \subseteq R$.

When $M$ always terminates in constant time $k$, we show $M \RealiseIn{k} R$ instead.  Using the monotonicity Lemma~\ref{lem:RealiseIn_monotone}, we
can prove correctness and constant time at once.  For non-constant running time, we show $M \TerminatesIn T$ for a running time relation~$T$.  For
that, we use the dual approach and apply the anti-monotonicity Lemma~\ref{lem:TerminatesIn_monotone}.


\section{$\Nop$}
\label{sec:Nop}
\setCoqFilename{ProgrammingTuringMachines.TM.Compound.Multi}%


Using the tapes-lift (Definition~\ref{def:LiftTapes}) and $\MS{Null}$ (Definition~\ref{def:Null}), it is easy to define an $n$-tape machine
$\Nop : \TM_\Sigma^n$ for every alphabet $\Sigma$ and number of tapes $n$:
\begin{definition}[$\Nop$][Nop]
  $\Nop \defop \LiftTapes{\MS{Null}}{\nil}$
\end{definition}
Note that because $\MS{Null}$ is a 0-tape machine, and $\Nop$ is supposed to be an $n$-tape machine, the index-vector must be the vector
$\nil : \Fin_n^0$.

\begin{lemma}[Correctness of $\Nop$][Nop_Sem]
  \label{lem:Nop_Sem}
  $\Nop \RealiseIn0 NopRel$ with $NopRel := \lambda t~t'.~t'=t$.
\end{lemma}
\begin{proof}
  We apply the monotonicity Lemma~\ref{lem:RealiseIn_monotone} of $\RealiseIn\cdot$, the correctness Lemma~\ref{lem:Null_Sem} of $\MS{Null}$, and the
  correctness Lemma~\ref{lem:LiftTapes_Realise} of the tapes-lift.  It remains to show:
  \[
    \left( \lambda t~t'.~ NullRel~t~t' \land \left(\forall i:\Fin_n.~i \notin \nil \rightarrow t'[i] = t[i] \right)\right)
    \subseteq NopRel
  \]
  Let $t,t' : \Tape_\Sigma^n$.  To show the equality $t'=t$ we show $t'[i]=t[i]$ for all $i:\Fin_n$.  This follows with the equality part of the
  relation $\LiftTapes{NullRel}{\nil}$, since $i \notin \nil$.
\end{proof}

Note that the correctness relation of $\Nop$ can also be expressed using the identity relation $Id$:
\[
  NopRel \equiv Id.
\]
We have the convention to define relations of concrete machines in $\lambda$-notation, i.e.\ not using relational operators.  Also note that the tape
$t'$ is, per convention, always on the left side of the equality.  These conventions makes rewriting of tapes uniform; therefore, rewriting of tapes
can be automated in Coq.

\section{$\MS{WriteString}$}
\label{sec:WriteString}
\setCoqFilename{ProgrammingTuringMachines.TM.Compound.WriteString}%

The machine $\MS{WriteString}~d~str$ writes a fixed string $str:\List(\Sigma)$ in the direction $d$.  It is defined by recursion over the string:
\begin{definition}[$\MS{WriteString}$][WriteString]
  \begin{alignat*}{3}
    &\MS{WriteString}~d~&&(\nil)         &~:=~& \Nop \\
    &\MS{WriteString}~d~&&(s \cons \nil) &~:=~& \MS{Write}~s \\
    &\MS{WriteString}~d~&&(s \cons str') &~:=~& \MS{WriteMove}~s~d \Seq \MS{WriteString}~d~str'.
  \end{alignat*}
\end{definition}

Note that this is our only machine we define per recursion.  The way we prove correctness in constant time (depending on the length of $str$) is still
the same.

The machine writes all symbols of the string $str$ to the tape and moves in the tape in direction $d$ after each (but the last) symbol.  When it
terminates, the head of the tape is under the last written symbol, which is the last symbol of $str$.  It terminates in constant time, after
$2\cdot\length{str}-1$ steps.

The relation that $\MS{WriteString}$ ``mechanically'' realises, is also defined per recursion over the string:
\begin{lemma}[][WriteString_fix_Sem]
  $\MS{WriteString}~d~str \RealiseIn{2 \cdot \length{str} - 1} R'~d~str$ with
  \begin{alignat*}{3}
    &\MS{R'}~d~&&(\nil        ) &~:=~& NopRel \\
    &\MS{R'}~d~&&(s \cons \nil) &~:=~& DoActRel(\Some{s}, N) \\
    &\MS{R'}~d~&&(s \cons str') &~:=~& DoActRel(\Some{s}, d) \circ \MS{R'}~d~str'.
  \end{alignat*}
\end{lemma}
\begin{proof}
  By induction on $str:\List(\Sigma)$, using the monotonicity Lemma~\ref{lem:RealiseIn_monotone}, the correctness of $\Nop$ (Lemma~\ref{lem:Nop_Sem}),
  the correctness of $\MS{Write}$ and $\MS{WriteMove}$ (which are defined using $\MS{DoAct}$; Lemma~\ref{lem:DoAct_Sem}), and correctness of
  sequential composition for constant time (Lemma~\ref{lem:Seq_RealiseIn}).
\end{proof}

We define the actual relation of $\MS{WriteString}$ in terms of a function on tapes, defined by recursion over $str$:
\begin{lemma}[Correctness of $\MS{WriteString}$][WriteString_Sem]
  \label{lem:WriteString_Sem}
  Let $d:\Move$ and $str:\List(\Sigma)$.
  \[ \MS{WriteString}~d~str \RealiseIn{4\cdot\length{str}} WriteStringRel~d~str \]
  with
  $WriteStringRel~d~str := \lambda t~t'.~t' = WriteStringFun~d~t~str$ and
  \begin{alignat*}{3}
    &WriteStringFun~d~t~&&(\nil        ) &~:=~& t \\
    &WriteStringFun~d~t~&&(s \cons \nil) &~:=~& \MS{wr}~t~(\Some{s}) \\
    &WriteStringFun~d~t~&&(s \cons str') &~:=~& WriteStringFun~d~\bigl(doAct~t~(\Some{s}, d)\bigr)~str'
  \end{alignat*}
\end{lemma}
\begin{proof}
  We apply the monotonicity Lemma~\ref{lem:RealiseIn_monotone} and have to show\\
  $R'~d~str \subseteq WriteStringRel~d~str$.  This can be shown by induction on $str$.
\end{proof}

Note that we could as well use the $\MS{Mirror}$ operator instead of parametrising the machine $\MS{WritingString}$ over the direction.  In this
particular example, the former approach seems to be easier.

\section{$\MS{MovePar}$}
\label{sec:MovePar}
\setCoqFilename{ProgrammingTuringMachines.TM.Compound.Multi}%

The two-tape machine $\MS{MovePar}~d_0~d_1$ combines two $\MS{Move}$ machines.  It first moves the $0$th\footnote{To avoid confusion with zero-based
  indices used throughout this thesis, we write ``the $0$th or $1$st tape'', instead of ``the first or second tape.''} tape in direction $d_0$ and
after that the $1$st tape in direction $d_1$.
\begin{definition}[$\MS{MovePar}$][MovePar]
  \label{def:MovePar}
  $\MS{MovePar}~d_0~d_1 \defop \LiftTapes{(\MS{Move}~d_0)}{\Vector{0}} \Seq \LiftTapes{(\MS{Move}~d_1)}{\Vector{1}}$.
\end{definition}
\begin{lemma}[Correctness of $\MS{MovePar}$][MovePar_Sem]
  \label{lem:MovePar_Sem}
  $\MS{MovePar}~d_0~d_1 \RealiseIn3 MoveParRel~d_0~d_1$ with
  \[ MoveParRel~d_0~d_1 := \lambda t~t'.~t'[0]=\MS{mv}~d_0~t[0] ~\land~ t'[1]=\MS{mv}~d_1~t[1]. \]
\end{lemma}
\begin{proof}
  We have to show
  $$
    \LiftTapes{(DoActRel(\None,d_0))}{\Vector{0}} \circ
    \LiftTapes{(DoActRel(\None,d_1))}{\Vector{1}} \subseteq
    MovePairRel~d_0~d_1.
  $$
  We assume tape vectors $t, t', t'' : \Tape_\Sigma^2$, such that $(\LiftTapes{(DoActRel(\None,d_0))}{\Vector{0}})~t~t'$ and \\
  $(\LiftTapes{(DoActRel(\None,d_1))}{\Vector{1}})~t'~t''$.  We have to show $t''[0]=\MS{mv}~d_0~t[0]$ and $t''[1]=\MS{mv}~d_1~t[1]$.  By definition,
  we know $t'[0]=\MS{mv}~d_0~t[0]$ and $t'[1]=t[1]$ (because $1 \notin \Vector{0}$).  We also know $t''[1]=\MS{mv}~d_1~t'[1]$ and $t''[0]=t'[0]$
  (because $0 \notin \Vector{1}$).  The goal follows trivially.
\end{proof}
Note that this kind of proof is very mechanical: We only need to unfold the relations, and rewrite tapes.  Indeed, these steps are automated in Coq.
Thus, we also do not present more proofs of this kind on paper.

\section{$\MS{CopySymbols}$}
\label{sec:CopySymbols}
\setCoqFilename{ProgrammingTuringMachines.TM.Compound.CopySymbols}%

The machine $\MS{CopySymbols}~h : \TM_\Sigma^2$, where $h:\Sigma\to\Bool$, is a compound machine involving a $\While$-loop.  It reads a symbol on tape
$0$, writes it to tape $1$, and moves both tapes to right, until the read symbol satisfies $h$.  If there was no current symbol on tape $0$, it also
terminates.

We first define the machine for the step.  Since we want to apply the $\While$ operator on the step machine, it must be partitioned over
$\Option(\Unit)$.  $\Some\unit$ means to break out of the loop and $\None$ means to repetition the loop.
\begin{definition}[$\MS{CopySymbolsStep}$][CopySymbols_Step]
  \label{CopySymbols_Step}
  % \begin{multline*}
  %   \MS{CopySymbolsStep}~h :=
  %   \Match(\LiftTapes{Read}{\Vector{0}}) \\
  %   \Biggl(
  %   \lambda s.
  %   \begin{cases}
  %     \Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}}\bigr)}{\Some\unit} & s=\Some{x} ~\land~ h(x)=\true \\
  %     \Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}} \Seq \MS{MovePar}~R~R\bigr)}{\None} & s=\Some{x} ~\land~ h(x)=\false \\
  %     \Return{\Nop}{\Some\unit} & s=\None
  %   \end{cases}
  %   \Biggr)
  % \end{multline*}
  % \centerline{\emph{versus}}
  % \small
  % \todo{Decide!}
\begin{lstlisting}[style=semicoqstyle]
$\MS{CopySymbolsStep}~h :=$
  Match($\LiftTapes{\MS{Read}}{\Vector{0}}$)
       ($\lambda (s:\Option(\Sigma)).~\MS{match}~s$
          [$\Some{x}$=>
            $\MS{if}~h(x)$
            $\pthen$ $\Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}}\bigr)}{\Some\unit}$ 
            $\pelse$ $\Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}} \Seq \MS{MovePar}~R~R\bigr)}{\None}$ 
          |$\None$ => $\Return{\Nop}{\Some\unit}$ 
          ]).
\end{lstlisting}
\end{definition}

Note that the $\MS{match}$ denotes pattern matching in the logical language.

\begin{lemma}[Correctness of $\MS{CopySymbolsStep}$][CopySymbols_Step_Sem]
  \label{lem:CopySymbols_Step_Sem}
  ~
  \[
    \MS{CopySymbolsStep} \RealiseIn{7} CopySymbolsStepRel
  \]
  with
  \small
  \begin{multline*}
    CopySymbolsStepRel := \lambda t~(y, t').~\\
    \begin{cases}
      t'[0] = t[0]           \land t'[1]=\MS{wr}~t[1]~\Some{x}         \land y=\Some\unit & \MS{current}~t[0]=\Some{x} \land       h(x) \\
      t'[0] = \MS{mv}~R~t[0] \land t'[1]=\MS{doAct}~t[1]~(\Some{x}, R) \land y=\None      & \MS{current}~t[0]=\Some{x} \land \lnot h(x) \\
      t' = t \land y=\Some\unit                                                           & \text{else}
    \end{cases}
  \end{multline*}
\end{lemma}
\begin{proof}
  Mechanical, with case-analysis over $\MS{current}~t[0]$.
\end{proof}

We define $\MS{CopySymbol}$ by applying the $\While$ combinator to $\MS{CopySymbolsStep}$:
\begin{definition}[$\MS{CopySymbols}$][CopySymbols]
  \label{def:CopySymbols}
  $\MS{CopySymbols}~h := \While(\MS{CopySymbolsStep}~h)$.
\end{definition}

The correctness of $\MS{CopySymbols}$ can be expressed using a recursive function on tapes:
\begin{lemma}[Correctness of $\MS{CopySymbols}$][CopySymbols_Realise]
  \label{lem:CopySymbols_Realise}
  $\MS{CopySymbols}~h \Realise CopySymbolsRel~h$
  with $CopySymbolsRel~h := \lambda t~t'. t' = CopySymbolsFun~h~t$ and
  {
    \small
    \begin{multline*}
      CopySymbolsFun~h~t :=\\
      \begin{cases}
        \Vector{t[0];~ \MS{wr}~t[1]~\Some{x}}                                    & \MS{current}~t[0]=\Some{x} \land h(x) \\
        CopySymbolsFun~h~\Vector{\MS{mv}~R~t[0];~ \MS{doAct}~t[1]~(\Some{x}, R)} & \MS{current}~t[0]=\Some{x} \land \lnot h(x) \\
        t                                                                        & \MS{current}~t[0]=\None
      \end{cases}
    \end{multline*}
  }
  Note that the function $CopySymbolsFun$ is not structural recursive.  It terminates because tapes have only finitely many symbols.
\end{lemma}
\begin{proof}
  To show: $WhileRel~CopySymbolsStepRel \subseteq CopySymbolsRel$.  By $\While$-induction (Lemma~\ref{lem:WhileInduction}).
\end{proof}

We observe that the running time of $\MS{CopySymbols}$ only depends on the $0$th tape.  Therefore, we define a function
$CopySymbolsSteps : \Tape_\Sigma \to \Nat$ that overestimates the number of steps needed for the loop, depending on the $0$th tape.  Note that
$\While$ requires one additional step for each repeat of the loop.
\begin{lemma}[Runtime of $\MS{CopySymbols}$][CopySymbols_TerminatesIn]
  $\MS{CopySymbols} \TerminatesIn CopySymbolsT$ with \\
  $CopySymbolsT := \lambda t~k.~stepsCopySymbols(t) \leq k$ and
  \begin{multline*}
    stepsCopySymbols (t) := \\
    \begin{cases}
      8 + CopySymbolSteps(\MS{mv}~R~t) & \MS{current}(t)=\Some{x} \land \lnot h(x) \\
      8                                & \text{otherwise}
    \end{cases}
  \end{multline*}
\end{lemma}
\begin{proof}
  We have to show $CopySymbolsT \subseteq WhileT~CopySymbolsStepRel~(\lambda \_~k.~7 \leq k)$, using the co-induction
  Lemma~\ref{lem:WhileCoInduction}.  Let $stepsCopySymbols~t[0] \leq k$.  We choose $k_1 := 7$.  We have two cases.
  \begin{enumerate}
  \item We have $CopySymbolsStepRel~t~(\Some\unit, t')$.  Therefore, we know that either $\MS{current}(t[0])=\Some{x}$ with $h(x)=\true$, or
    $\MS{current}(t[0])=\None$.  In both cases, we have $stepsCopySymbols(t[0]) = 8$.  Thus, we have
    $$ 7 \leq CopySymbolSteps(t[0]) = 8 \leq k. $$
  \item We have $CopySymbolsStepRel~t~(\None, t')$.  Therefore, we have $\MS{current}(t[0])=\Some{x}$ with $h(x)=\false$, and $t'[0]=\MS{mv}~R~t[0]$.
    Then, we have
    $$ 1+7+CopySymbolSteps(t'[0]) = CopySymbolSteps(t[0]) \leq k.$$
    \qed
  \end{enumerate}
\end{proof}
% Note that we see in the proof that we could replace the $8$s in the non-recursive parts of the running time functions with $7$s.

Using the $\MS{Mirror}$ operator, we can define a machine $\MS{CopySymbolsL}$ that copies and goes to the left instead.  We also have to ``mirror''
the correctness relations and their respective functions.  We do not repeat the definitions here.
\begin{definition}[$\MS{CopySymbolsL}$][CopySymbols_L]
  $\MS{CopySymbolsL}~h := \MS{Mirror}(\MS{CopySymbols}~h).$
\end{definition}

\section{$\MS{MoveToSymbol}$}
\label{sec:MoveToSymbol}

We can define a machine $\MS{MoveToSymbol}~h~f : \TM_\Sigma^1$, where $h:\Sigma\to\Bool$ and $f:\Sigma\to\Sigma$.  This machine behaves similar as
$\MS{CopySymbols}~h$.  Instead of copying the symbols from one tape to another tape, it ``translates'' the symbols it read, until it reads a symbol
that satisfies the boolean predicate $h$.  We leave out the correctness and running time statements, as they can be derived from the statements about
$\MS{CopySymbols}$ above.

\begin{definition}[$\MS{MoveToSymbol}$][MoveToSymbol]
  ~
\begin{lstlisting}[style=semicoqstyle]
$\MS{MoveToSymbolStep}~h~f :=$
  Match($\MS{Read}$)
       ($\lambda (s:\Option(\Sigma)).~\MS{match}~s$
          [$\Some{x}$=> 
            if $h(x)$
            $\pthen$ $\Return{\bigl(\MS{Write}~(f~x)       \bigr)}{\Some\unit}$ 
            $\pelse$ $\Return{\bigl(\MS{WriteMove}~(f~x)~R \bigr)}{\None}$ 
          |$\None$ => $\Return{\Nop}{\Some\unit}$ 
          ]).
\end{lstlisting}
  \begin{align*}
    \MS{MoveToSymbol }~h~f &:= \While(\MS{MoveToSymbolStep}~h~f) \\
    \MS{MoveToSymbolL}~h~f &:= \MS{Mirror}(\MS{MoveToSymbol}~h~f)
  \end{align*}
\end{definition}



%%% Local Variables:
%%% TeX-master: "thesis"
%%% End: