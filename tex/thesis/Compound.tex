\chapter{Compound Machines}
\label{chap:compound}

In this chapter, we build complex machines, using the combinators developed in Chapter~\ref{chap:combining}, as well as the tapes-lift of
Chapter~\ref{chap:lifting}.  However, we do not use the alphabet lift in this chapter.  We also prove correctness and runtime of these machines.

The general approach, when we prove correctness of a machine $M$, i.e.\ if we want to show $M \Realise R$, is to first define a relation $R'$ that $M$
realises.  For that, we use the correctness lemmas of the combinators, lifts, and concrete machines.  We applying Lemma~\ref{lem:Realise_monotone} and
have to show $R' \subseteq R$.  Note that the first part of the proof, i.e.\ generating the relation $R'$ such that $M \Realise R'$, is mechanical.
Indeed, we can automate this step in Coq, see more in Chapter~\ref{chap:implementation}.

When $M$ always terminates in constant time $k$, we show $M \RealiseIn{k} R$ instead.  Using the monotonicity Lemma~\ref{lem:RealiseIn_monotone}, we
can prove correctness and (constant) runtime at once.  For (non-constant) runtime, we use the dual approach, using the anti-monotonicity
Lemma~\ref{lem:TerminatesIn_monotone}.

\section{$\Nop$}
\label{sec:Nop}

Using the alphabet-lift (Definition~\ref{def:LiftAlphabet}) and $\MS{Null}$ (Definition~\ref{def:Null}), it is easy to define an $n$-tape machine
$\Nop : \TM_\Sigma^n$ for every alphabet $\Sigma$ and number of tapes $n$:
\begin{definition}[$\Nop$]
  $\Nop \defop \LiftTapes{\MS{Null}}{\nil}$
\end{definition}
Note that because $\MS{Null}$ is a 0-tape machine, and $\Nop$ is supposed to be an $n$-tape machine, the index-vector must be the vector
$\nil : \Fin_n^0$.

\begin{lemma}[Correctness of $\Nop$]
  \label{lem:Nop_Sem}
  $\Nop \RealiseIn0 NopRel$ with $NopRel := \lambda t~t'.~t'=t$.
\end{lemma}
\begin{proof}
  By applying monotonicity of $\RealiseIn\cdot$ (Lemma~\ref{lem:RealiseIn_monotone}) and the correctness of $\MS{Null}$ (Lemma~\ref{lem:Null_Sem}).  It
  remains to show that $\LiftTapes{NullRel}{\nil} \subseteq NopRel$.  To show the equality $t'=t$ we show $t'[i]=t[i]$ for all $i:\Fin_n$.  This
  follows with the equality part of the relation $\LiftTapes{NullRel}{\nil}$, because $i \notin \nil$.
\end{proof}

Note that the correctness relation of $\Nop$ can also be expressed using the identity relation $Id$:
\[
  NopRel \equiv Id.
\]
We have the convention to define relations of concrete machines in $\lambda$-notation, i.e.\ not using relational operators.  Also note that
the tape $t'$ is per convention always on the left side of the equality.  This convention makes rewriting of tapes uniform; therefore, rewriting of
tapes can be automated in Coq.

\section{$\MS{WriteString}$}
\label{sec:WriteString}

The machine $\MS{WriteString}~d~str$ writes a fixed string $str:\List(\Sigma)$ in the direction $d$.  It is defined by recursion over the string:
\begin{definition}[$\MS{WriteString}$]
  \begin{alignat*}{3}
    &\MS{WriteString}~d~&&(\nil)         &~:=~& \Nop \\
    &\MS{WriteString}~d~&&(s \cons \nil) &~:=~& \MS{Write}~s \\
    &\MS{WriteString}~d~&&(s \cons str') &~:=~& \MS{WriteMove}~s~d \Seq \MS{WriteString}~d~str'.
  \end{alignat*}
\end{definition}

Note that this is our only machine we define per recursion.  The way we prove correctness in constant time (depending on the length of $str$) is still
the same.

The machine writes all symbols of the string $str$ to the tape and moves in the tape in direction $d$ after each (but the last) symbol.  When it
terminates, the head of the tape is under the last written symbol, which is the last symbol of $str$.  It terminates in constant time, after
$2\cdot\length{str}-1$ steps.

The relation that $\MS{WriteString}$ ``automatically'' realises, is also defined per recursion over the string:
\begin{lemma}
  $\MS{WriteString}~d~str \RealiseIn{2 \cdot \length{str} - 1} R'~d~str$ with
  \begin{alignat*}{3}
    &\MS{R'}~d~&&(\nil        ) &~:=~& NopRel \\
    &\MS{R'}~d~&&(s \cons \nil) &~:=~& DoActRel(\Some{s}, N) \\
    &\MS{R'}~d~&&(s \cons str') &~:=~& DoActRel(\Some{s}, d) \circ \MS{R'}~d~str'.
  \end{alignat*}
\end{lemma}
\begin{proof}
  By induction on $str:\List(\Sigma)$, using the monotonicity Lemma~\ref{lem:RealiseIn_monotone}, the correctness of $\Nop$ (Lemma~\ref{lem:Nop_Sem}),
  the correctness of $\MS{Write}$ and $\MS{WriteMove}$ (which are defined by $\MS{DoAct}$; Lemma~\ref{lem:DoAct_Sem}), and correctness of sequential
  composition for constant time (Lemma~\ref{lem:Seq_RealiseIn}).
\end{proof}

We define the actual relation of $\MS{WriteString}$ in terms of a function on tapes, defined by recursion over $str$:
\begin{lemma}[Correctness of $\MS{WriteString}$]
  \label{lem:WriteString_Sem}
  Let $d:\Move$ and $str:\List(\Sigma)$.
  \[ \MS{WriteString}~d~str \RealiseIn{4\cdot\length{str}} WriteStringRel~d~str \]
  with
  $WriteStringRel~d~str := \lambda t~t'.~t' = WriteStringFun~d~t~str$ and
  \begin{alignat*}{3}
    &WriteStringFun~d~t~&&(\nil        ) &~:=~& t \\
    &WriteStringFun~d~t~&&(s \cons \nil) &~:=~& \MS{wr}~t~(\Some{s}) \\
    &WriteStringFun~d~t~&&(s \cons str') &~:=~& WriteStringFun~d~\bigl(doAct~t~(\Some{s}, d)\bigr)~str'
  \end{alignat*}
\end{lemma}
\begin{proof}
  We apply the monotonicity Lemma~\ref{lem:RealiseIn_monotone} and have to show\\
  $R'~d~str \subseteq WriteStringRel~d~str$.  This can be shown by induction on $str$.
\end{proof}

Note that we could as well use the $\MS{Mirror}$ operator instead of parametrising the machine $\MS{WritingString}$ over the direction.  In this
particular example, the former approach seems to be easier.

\section{$\MS{MovePar}$}
\label{sec:MovePar}

The two-tape machine $\MS{MovePar}~d~d'$ combines two $\MS{Move}$ machines.  It first moves the $0$th\footnote{To avoid confusion with zero-based
  indices used throughout this thesis, we write ``the $0$th or $1$st tape'', instead of ``the first or second tape.''} tape in direction $d$ and after
that the $1$st tape in direction $d'$.
\begin{definition}[$\MS{MovePar}$]
  \label{def:MovePar}
  $\MS{MovePar}~d_1~d_2 \defop \LiftTapes{(\MS{Move}~d_1)}{\Vector{0}} \Seq \LiftTapes{(\MS{Move}~d_2)}{\Vector{1}}$.
\end{definition}
\begin{lemma}[Correctness of $\MS{MovePar}$]
  \label{lem:MovePar_Sem}
  $\MS{MovePar}~d_1~d_2 \RealiseIn3 MoveParRel~d_1~d_2$ with
  \[ MoveParRel~d_1~d_2 := \lambda t~t'.~t'[0]=\MS{mv}~d_1~t[0] ~\land~ t'[1]=\MS{mv}~d_2~t[1]. \]
\end{lemma}
\begin{proof}
  We have to show
  $$
    \LiftTapes{(DoActRel(\None,d_1))}{\Vector{0}} \circ
    \LiftTapes{(DoActRel(\None,d_2))}{\Vector{1}} \subseteq
    MovePairRel~d_1~d_2.
  $$
  We assume tape vectors $t, t', t'' : \Tape_\Sigma^2$, such that $(\LiftTapes{(DoActRel(\None,d_1))}{\Vector{0}})~t~t'$ and \\
  $(\LiftTapes{(DoActRel(\None,d_2))}{\Vector{1}})~t'~t''$.  We have to show $t''[0]=\MS{mv}~d_1~t[0]$ and $t''[1]=\MS{mv}~d_2~t[1]$.  By definition,
  we know $t'[0]=\MS{mv}~d_1~t[0]$ and $t'[1]=t[1]$ (because $1 \notin \Vector{0}$).  We also know $t''[1]=\MS{mv}~d_2~t'[1]$ and $t''[0]=t'[0]$
  (because $0 \notin \Vector{1}$).  The goal follows trivially.
\end{proof}
Note that this kind of proof is very mechanical: We only need to unfold the relations, and rewrite tapes.  Indeed, these steps are automated in Coq.
Thus, we also do not more proofs of this kind on paper.

\section{$\MS{CopySymbols}$}
\label{sec:CopySymbols}

The machine $\MS{CopySymbols}~h : \TM_\Sigma^2$, where $h:\Sigma\to\Bool$, is a compound machine involving a $\While$-loop.  It reads a symbol on tape
$0$, writes it to tape $1$, and moves both tapes to right, until the read symbol satisfies $h$.  If there was no current symbol on tape $0$, it also
terminates.

We first define the machine for the step.  Since we want to apply the $\While$ operator on the step machine, it must be partitioned over
$\Option(\Unit)$.  $\Some\unit$ means to break out of the loop and $\None$ means to repeat the loop.
\begin{definition}[$\MS{CopySymbolsStep}$]
  \label{CopySymbols_Step}
  % \begin{multline*}
  %   \MS{CopySymbolsStep}~h :=
  %   \Match(\LiftTapes{Read}{\Vector{0}}) \\
  %   \Biggl(
  %   \lambda s.
  %   \begin{cases}
  %     \Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}}\bigr)}{\Some\unit} & s=\Some{x} ~\land~ h(x)=\true \\
  %     \Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}} \Seq \MS{MovePar}~R~R\bigr)}{\None} & s=\Some{x} ~\land~ h(x)=\false \\
  %     \Return{\Nop}{\Some\unit} & s=\None
  %   \end{cases}
  %   \Biggr)
  % \end{multline*}
  % \centerline{\emph{versus}}
  % \small
  % \todo{Decide!}
\begin{lstlisting}[style=semicoqstyle]
$\MS{CopySymbolsStep}~h :=$
  Match($\LiftTapes{\MS{Read}}{\Vector{0}}$)
       ($\lambda (s:\Option(\Sigma)).~\MS{match}~s$
          [$\Some{x}$ =>
            if $h(x)$
            then $\Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}}\bigr)}{\Some\unit}$ 
            else $\Return{\bigl(\LiftTapes{(\MS{Write}~x)}{\Vector{1}} \Seq \MS{MovePar}~R~R\bigr)}{\None}$ 
          |$\None$ => $\Return{\Nop}{\Some\unit}$ 
          ]).
\end{lstlisting}
\end{definition}

\begin{lemma}[Correctness of $\MS{CopySymbolsStep}$]
  \label{lem:CopySymbols_Step_Sem}
  ~
  \[
    \MS{CopySymbolsStep} \RealiseIn{7} CopySymbolsStepRel
  \]
  with
  \small
  \begin{multline*}
    CopySymbolsStepRel := \lambda t~(y, t').~\\
    \begin{cases}
      t'[0] = t[0]           \land t'[1]=\MS{wr}~t[1]~\Some{x}         \land y=\Some\unit & \MS{current}~t[0]=\Some{x} \land       h(x) \\
      t'[0] = \MS{mv}~R~t[0] \land t'[1]=\MS{doAct}~t[1]~(\Some{x}, R) \land y=\None      & \MS{current}~t[0]=\Some{x} \land \lnot h(x) \\
      t' = t \land y=\Some\unit                                                           & \text{else}
    \end{cases}
  \end{multline*}
\end{lemma}
\begin{proof}
  Mechanical, with case-analysis over $\MS{current}~t[0]$.
\end{proof}

We define $\MS{CopySymbol}$ by applying the $\While$ combinator to $\MS{CopySymbolsStep}$:
\begin{definition}[$\MS{CopySymbols}$]
  \label{def:CopySymbols}
  $\MS{CopySymbols}~h := \While(\MS{CopySymbolsStep}~h)$.
\end{definition}

The correctness of $\MS{CopySymbols}$ can be expressed using a recursive function on tapes:
\begin{lemma}[Correctness of $\MS{CopySymbols}$]
  \label{lem:CopySymbols_Realise}
  $\MS{CopySymbols}~h \Realise CopySymbolsRel~h$
  with $CopySymbolsRel~h := \lambda t~t' = CopySymbolsFun~h~t$ and
  {
    \small
    \begin{multline*}
      CopySymbolsFun~h~t :=\\
      \begin{cases}
        \Vector{t[0]; \MS{wr}~t[1]~(\Some{x})}                                  & \MS{current}~t[0]=\Some{x} \land h(x) \\
        CopySymbolsFun~h~\Vector{\MS{mv}~R~t[0]; \MS{doAct}~t[1]~(\Some{x}, R)} & \MS{current}~t[0]=\Some{x} \land \lnot h(x) \\
        t                                                                       & \MS{current}~t[0]=\None
      \end{cases}
    \end{multline*}
  }
  Note that the function $CopySymbolsFun$ is not structural recursive.  It terminates because tapes have only finitely many symbols.
\end{lemma}
\begin{proof}
  To show: $WhileRel~CopySymbolsStepRel \subseteq CopySymbolsRel$.  By $\While$-induction (Lemma~\ref{lem:WhileInduction}).
\end{proof}

We observe that the runtime of $\MS{CopySymbols}$ only depends on the $0$th tape.  Therefore, we define a function
$CopySymbolsSteps : \Tape_\Sigma \to \Nat$ that overestimates the number of steps needed for the loop, depending on the $0$th tape.  Note that
$\While$ requires one additional step for each repeat of the loop.
\begin{lemma}[Runtime of $\MS{CopySymbols}$]
  $\MS{CopySymbols} \TerminatesIn CopySymbolsT$ with \\
  $CopySymbolsT := \lambda t~k.~CopySymbolsSteps(t) \leq k$ and
  \begin{multline*}
    CopySymbolsSteps (t) := \\
    \begin{cases}
      8 + CopySymbolSteps(\MS{mv}~R~t) & \MS{current}(t)=\Some{x} \land \lnot h(x) \\
      8                                & \text{otherwise}
    \end{cases}
  \end{multline*}
\end{lemma}
\begin{proof}
  We have to show $CopySymbolsT \subseteq WhileT~CopySymbolsStepRel~(\lambda \_~k.~7 \leq k)$, using the co-induction
  Lemma~\ref{lem:WhileCoInduction}.  Let $CopySymbolsSteps~t[0] \leq k$.  We chose $k_1 := 7$.  We have two cases.
  \begin{enumerate}
  \item We have $CopySymbolsStepRel~t~(\Some\unit, t')$.  Therefore, we know that either $\MS{current}(t[0])=\Some{x}$ with $h(x)=\true$, or
    $\MS{current}(t[0])=\None$.  In both cases, we have $CopySymbolsSteps(t[0]) = 8$.  Thus, we have
    $$ 7 \leq CopySymbolSteps(t[0]) = 8 \leq k. $$
  \item We have $CopySymbolsStepRel~t~(\None, t')$.  Therefore, we have $\MS{current}(t[0])=\Some{x}$ with $h(x)=\false$, and $t'[0]=\MS{mv}~R~t[0]$.
    Then, we have
    $$ 1+7+CopySymbolSteps(t'[0]) = CopySymbolSteps(t[0]) \leq k.$$
    \qed
  \end{enumerate}
\end{proof}
% Note that we see in the proof that we could replace the $8$s in the non-recursive parts of the runtime functions with $7$s.

Using the $\MS{Mirror}$ operator, we can define a machine $\MS{CopySymbolsL}$ that copies and goes to the left instead.  We also have to ``mirror''
the correctness relations and their respective functions.  We do not repeat the definitions here.
\begin{definition}[$\MS{CopySymbolsL}$]
  $\MS{CopySymbolsL}~h := \MS{Mirror}(\MS{CopySymbols}~h).$
\end{definition}

\section{$\MS{MoveToSymbol}$}
\label{sec:MoveToSymbol}

We can define a machine $\MS{MoveToSymbol}~h~f : \TM_\Sigma^1$, where $h:\Sigma\to\Bool$ and $f:\Sigma\to\Sigma$.  This machine behaves similarly like
$\MS{CopySymbols}~h$.  Instead of copying the symbols from one tape to another tape, it ``translates'' the symbols it read, until it reads a
symbol that satisfies the boolean predicate $h$.  We leave out the correctness and runtime statements, as they can be derived from the statements
about $\MS{CopySymbols}$ above.

\begin{definition}[$\MS{MoveToSymbol}$]
  ~
\begin{lstlisting}[style=semicoqstyle]
$\MS{MoveToSymbolStep}~h~f :=$
  Match ($\MS{Read}$)
        ($\lambda (s:\Option(\Sigma)).$ match $s$
           [$\Some{x}$ => 
             if $h(x)$
             then $\Return{\bigl(\MS{Write}~(f~x)       \bigr)}{\Some\unit}$ 
             else $\Return{\bigl(\MS{WriteMove}~(f~x)~R \bigr)}{\None}$ 
           |$\None$ => $\Return{\Nop}{\Some\unit}$ 
           ]).
\end{lstlisting}
  and
  \begin{align*}
    \MS{MoveToSymbol }~h~f &:= \While(\MS{MoveToSymbolStep}~h~f) \\
    \MS{MoveToSymbolL}~h~f &:= \MS{Mirror}(\MS{MoveToSymbol}~h~f)
  \end{align*}
\end{definition}



%%% Local Variables:
%%% TeX-master: "thesis"
%%% End: