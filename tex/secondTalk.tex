\documentclass{beamer} %
% \usetheme{CambridgeUS}
\usepackage[latin1]{inputenc}
% \usefonttheme{professionalfonts}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{minted}
\usecolortheme{orchid}
\usetikzlibrary{arrows,shapes,snakes}


%%
%% Important note:
%% Add [fragile] to each frame using listings!
%% AUCTeX does this automatically!
%%

\include{mypreamble}


%% Use these versions of the type names
\renewcommand{\Type}{\mathbb{T}}
\renewcommand{\Nat}{\mathbb{N}}
\renewcommand{\Bool}{\mathbb{B}}
\renewcommand{\Option}{\mathcal{O}}
\renewcommand{\List}{\mathcal{L}}
\newcommand{\Pow}{\mathcal{P}}

% Hide Controls
\beamertemplatenavigationsymbolsempty%
% \setbeamertemplate{footline}[page number]
%% Show only current page number
\setbeamertemplate{footline}{\raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[20pt]{\scriptsize{\color{gray}\insertframenumber}}}}}

%% Display a list of references at the bottom
\newcommand\refs[1]{%
  \begin{textblock*}{8cm}(0.3cm,9.0cm)%
    \scriptsize {\color{gray}#1}
  \end{textblock*}
}


\title{Formalising Multi-Tape Turing Machines In Coq}
\subtitle{Second Bachelor Seminar Talk}
\author{Maximilian Wuttke}
\institute{Saarland University\\
  \bigskip
  \tiny
  Programming Systems Lab
}
\date{March 20, 2018\\
  \bigskip{}
  \bigskip{}
  {
    \tiny
    Advisor: Yannick Forster\\
    Supervisor: Prof.\ Dr.\ Gert Smolka%
  }
}

\begin{document}


\tikzstyle{every picture}+=[remember picture]




\frame{\titlepage}

\begin{frame}{Small Recap: Muli-Tape Turing Machines in Coq}

  \begin{itemize}
  \item \textbf{Partitioned machines}: $pM : \setOf{M : \MS{mTM}~\Sigma~n;~ f \from Q_{M} \to F}$ for \textbf{finite} types $F$
  \item Parametrised relations: $R \subseteq (\Tape_\Sigma^n) \times (F \times \Tape_\Sigma^n)$
  \item Weak realisation: $pM \VDash R$
  \item Termination: $M \downarrow T$
  \end{itemize}

\end{frame}

\begin{frame}{Realisation}

  \begin{definition}[Realisation, $pM \VDash R$]
    Let $R \subseteq (\Tape_\Sigma^n) \times (F \times \Tape_\Sigma^n)$ for a finite $F$.
    \begin{multline*}
      \mathbf{pM \VDash R} :=
      \forall (t_{in}~t_{out} : \Tape_\Sigma^n)~(q_{out}:Q_M)~(k:\Nat). \\
      M(t_{in}) \triangleright^k (q_{out}, t_{out}) \rightarrow
      \left(t_{in}, \left(f(q_{out}), t_{out} \right) \right) \in R.
    \end{multline*}
    We say that $pM$ \textbf{realises} $R$.
  \end{definition}

  \begin{lemma}[Monoticity of $\VDash$]
    If $pM \VDash R_1$ and $R_1 \subseteq R_2$, then $pM \VDash R_2$.
  \end{lemma}

\end{frame}

\begin{frame}{Termination}

  \begin{definition}[Termination, $M \downarrow T$]
    Let $T \subseteq (\Tape_\Sigma^n) \times \Nat$.
    \[
      \mathbf{M \downarrow T} :=
      \forall (t_{in},~k) \in T.~
      \exists c_{out},~M(t_{in}) \triangleright^k c_{out}
    \]
    We say that $M$ \textbf{terminates in} $T$.
  \end{definition}

  \begin{lemma}[Monoticity of $\downarrow$]
    If $M \downarrow T_1$ and $T_2 \subseteq T_1$, then $M \downarrow T_2$.
  \end{lemma}

\end{frame}


\begin{frame}{Combinators for Parametrised Machines}
  \emph{Shallow-embedded} language for constructing partitioned machines:
  
  \begin{itemize}
  \item $\MS{Match}~pM_1~(\lam {x:F_1} \cdots pM_2 \cdots pM_3 \cdots)$
  \item $\MS{If}~pM_1~pM_2~pM_3$
  \item $pM_1;~ pM_2$
  \item $\MS{While}~pM$
  \end{itemize}

  \pause

  \begin{lemma}[Correctness of $\MS{While}$]
    Let $pM$ be a partitioned (and $R$ parametrised) over $\Bool \times F$.\\
    % Overload While for a relation operator and a machine operator?
    If $pM \VDash R$, then $\MS{While}~pM \VDash \MS{While}~R$ with
    \[
      \MS{While}~R :=
      (\bigcup_{y \in F} \bigl({R\at{(true, y)}}\bigr)^* \circ R\at{\MS{fst}=\false}.
    \]
  \end{lemma}
\end{frame}

\begin{frame}{Machine transformations}
  \textbf{Problem:}
  When combining machines, the numbers of tapes and the alphabet have to match!
  \pause%
  \bigskip

  \textbf{Solution:} Two operations on machines:
  \begin{itemize}
    \item $n$-Lift: add/rearange tapes
    \item $\Sigma$-Lift: translate symbols
  \end{itemize}
\end{frame}
\begin{frame}{$n$-Lift}
  Let $f \from \Fin_m \hookrightarrow \Fin_n$ be an injection between tape indexes.

  Let $M$ be an $m$-tape $F$-partitioned Turing machine parametrised over $\Sigma$,
  and $R$ be a $F$-parametrised relation.

  Define an $n$-tape Turing machine $\MS{Lift}_f~M$ and a relation $\MS{Lift}_f~R$.
  \begin{align*}
    \MS{Lift}_f~R := \setMap{(t_{in}, (a, t_{out})) &}{ \bigl(f^{-1}(t_{in}), (a, f^{-1}(t_{out})) \bigr) \in R } \cap \\
    \Uparrow \setMap{(t_{in}, t_{out}) &}{ \forall i \notin \MS{img}~f.~ t_{in}[i] = t_{out}[i] }
  \end{align*}
  {\footnotesize (Where $f^{-1} \from \Tape^m \to \Tapes^n$)}
  % (Tapes that are not in the image of $f$ do nothing, the other tapes simulate the corresponding tapes of $M$.)

  \begin{lemma}[Correctness of the $n$-Lift]
    \[
      M \VDash R \rightarrow (\MS{Lift}_f~M) \VDash (\MS{Lift}_f~R)
    \]
  \end{lemma}

\end{frame}

\begin{frame}{$\Sigma$-Lift}
  Let $f \from \Sigma \hookrightarrow \Tau$ be an injection between alphabets.

  Let $\mathbf{default} : \Sigma^n$.

  Let $M$ be an $m$-tape $F$-partitioned Turing machine parametrised over $\Sigma$,
  and $R$ be a $F$-parametrised relation.

  Define an $n$-tape Turing machine $\MS{Lift}_{f,\MS{default}}~M$ and a relation $\MS{Lift}_{f,\MS{default}}~R$.
  \begin{align*}
    \MS{Lift}_{f,\MS{default}}~R := \setMap{(t_{in}, (a, t_{out}))}{ (f^{-1}_{\MS{default}} (t_{in}) , (a, f^{-1}_{\MS{default}} (t_{out}))) \in R}
  \end{align*}

  \begin{lemma}[Correctness of the $\Sigma$-Lift]
    \[
      M \VDash R \rightarrow (\MS{Lift}_{f, \MS{default}}~M) \VDash (\MS{Lift}_{f, \MS{default}}~R)
    \]
  \end{lemma}
\end{frame}


\begin{frame}[fragile]{Encoding Values on Tapes}

  \begin{itemize}
  \item
    Typeclass for \emph{encodable} types $X$ and alphabets $\Sigma$:

    \footnotesize
    \begin{minted}{coq}
Class encodable (X : Type) (sig : finType) := {
  encode : X -> list sig;
}.
    \end{minted}
    For example: $\MS{encode}~(b:\Bool) := [b]$ and $\MS{encode} (n:\Nat) := 1^n 0$.
    \pause

  \item
    Insert start end end symbols into an encoding:
    $\Sigma^+ := \Bool + \Sigma$. \pause
    
  \item
    Define class of predicates for \emph{calue-containing} of tapes:

    \begin{definition}[value-containing, $t \eqsim_{[r1;r2]} x$]
      Let $X$ be encodable over $\Sigma$, and $t \in \Tape_\Sigma$.
      \[
        t \eqsim_{[r1;r2]} x :=
        t = \midtape{(r_1 \app [\inl \true])}{(\inr y)}{(\map~\inr~ys \app \inl \false \cons r_2)}
        }.
      \]
      for $\MS{encode}(x) = y \cons ys$.
      % or:
      % \[
      %   t \eqsim_{[r1;r2]} x :=
      %   t = \midtape{(r_1 \app [\inl \true])}{\inl \false }{r_2}
      % \]
      % f
      % and $\MS{encode}(x) = \nil$ and
    \end{definition}

    { \footnotesize
      We write $t \eqsim x$ for $\exists r_1~r_2.~t \eqsim_{[r_1;r_2]} x$ \\
      and $t \eqsim_{\{;s\}} x$ for $\exists r_1~r_2.~t\eqsim_{[r_1;r_2]} x \land |r_2| \le s$.
    }
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{A Relation for (Unary) Function Computation}

  Convention:
  \begin{itemize}
  \item Input tapes; output tape; ``internal tapes''
  \item Callee-safe
  \item ``Internal tapes'' stay right
  \item Output grows to the left
  \end{itemize}
  \pause
  { \footnotesize
    \begin{columns}
      \begin{column}{0.5\textwidth}
        Let $X, Y, Z$ be encodable over $\Sigma$.
        \begin{alignat*}{2}
          & \MS{Computes}~(f:X \to Y) := \\
          & \quad \lam {t_{in}~(\_, t_{out})} \forall (x:X), \\
          & \quad\quad t_{in}[0] \eqsim x \rightarrow \\
          & \quad\quad \MS{isRight}~t_{in}[1] \rightarrow \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t_{in}[2+i]) \rightarrow \\
          & \quad\quad t_{out}[0] \eqsim x ~\land \\
          & \quad\quad t_{out}[1] \eqsim_{\{;0\}} f~x ~\land \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t_{out}[2+i])
        \end{alignat*}
      \end{column}
      \pause
      \begin{column}{0.5\textwidth}
        \begin{alignat*}{2}
          & \MS{Computes2}~(f:X \to Y \to Z) := \\
          & \quad \lam {t_{in}~(\_, t_{out})} \forall (x:X)~(y:Y), \\
          & \quad\quad t_{in}[0] \eqsim x \rightarrow \\
          & \quad\quad t_{in}[1] \eqsim y \rightarrow \\
          & \quad\quad \MS{isRight}~t_{in}[2] \rightarrow \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t_{in}[3+i]) \rightarrow \\
          & \quad\quad t_{out}[0] \eqsim x ~\land \\
          & \quad\quad t_{out}[1] \eqsim y ~\land \\
          & \quad\quad t_{out}[1] \eqsim_{\{;0\}} f~x~y ~\land \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t_{out}[3+i])
        \end{alignat*}
      \end{column}
    \end{columns}
  }
\end{frame}


\begin{frame}{Value-Manipulating Machines}
  \begin{itemize}
  \item Match/destruct
  \item Constructor
  \item CopyValue
  \item MoveRight
  \item WriteValue
  \end{itemize}
\end{frame}


\begin{frame}[fragile] \frametitle{Match $\Nat$}
  \footnotesize

  {\footnotesize
    \begin{align*}
      & \MS{Match\_Nat\_Rel} := \\
      & \quad \lam {t_{in}~(y_{out}, t_{out})} \forall (n:\Nat) \uncover<2->{(s:\Nat)}, \\
      & \quad\quad t_{in}[0] \eqsim_{\uncover<2->{\{;s\}}} n \rightarrow \\
      & \quad\quad \MS{match}~n~\MS{with} \\
      & \quad\quad |~0 \Rightarrow t_{out} = t_{in} ~\land~ y_{out} = \false \\
      & \quad\quad |~S~n' \Rightarrow t_{out}[0]  \eqsim_{\uncover<2->{\{;s\}}} n' ~\land~ y_{out} = \true \\
      & \quad\quad \MS{end}
    \end{align*}
  }

  \pause\pause
  \begin{columns}
    \begin{column}{0.5\textwidth}
      
\begin{lstlisting}[language=c, escapechar=!]
if (n--) {
  // ...
} else {!\tikz\node [coordinate] (n1) {};!
  // ...
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{align*}
        & \MS{If}~(\MS{Inject}~\MS{MatchNat}~\Vector{ \text{\tiny \# of tape where $n$ is stored} }) \\
        & \quad pM_1~pM_2
      \end{align*}
    \end{column}
  \end{columns}

  \begin{tikzpicture}[overlay]
    \draw[->, snake] ([xshift=1.5cm] n1) -- +(2cm,0);
  \end{tikzpicture} 
\end{frame}

\begin{frame}
  \frametitle{General Design of A Turing Machine}
  \begin{enumerate}
  \item Write the program in pseudo code
  \item Partition the program into smaller programs
  \item For each partion: map values to tapes
  \item For each partion: write a machine using primitive machines and combinators
  \item Compose machines
  \item For each machine: define a correctness relation and proof correctness
  \item For each machine: define a termination relation and proof termination
  \end{enumerate}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Case Study: Designing A Multiplication Machine}

  \begin{overlayarea}{\textwidth}{\textheight}

    \begin{onlyenv}<1>
\begin{lstlisting}
c := 0
while (m--) {
  c += n
}
return c
\end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<2>
\begin{lstlisting}
m' := m
c := 0
while (m'--) {
  Add(n, c, c')
  CopyValue(c', c)
  Reset(c')
}
Reset(m')
return c
\end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<3->
\begin{lstlisting}[escapechar=!]
m' := m !\tikz\node [coordinate] (init1) {};!
c := 0 !\tikz\node [coordinate] (init2) {};!
while (true) { !\tikz\node [coordinate] (loop1) {};!
  if (m--) { !\tikz\node [coordinate] (step1) {};!
    Add(n, c, c')
    CopyValue(c', c)
    Reset(c')
    continue
  } else {
    break
  } !\tikz\node [coordinate] (step2) {};!
} !\tikz\node [coordinate] (loop2) {};!
Reset(m') !\tikz\node [coordinate] (reset) {};!
return c
\end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<4->
      \begin{tikzpicture}[overlay]
        \node (init1') at ([yshift=+0.2cm] init1 -| (5,0));
        \node (init2') at ([yshift=-0.2cm] init2 -| (5,0));
        \node (loop1') at ([yshift=+0.2cm] loop1 -| (7,0));
        \node (loop2') at ([yshift=-0.2cm] loop2 -| (7,0));
        \node (step1') at ([yshift=+0.2cm] step1 -| (5,0));
        \node (step2') at ([yshift=-0.2cm] step2 -| (5,0));
        \node (reset1') at ([yshift=+0.3cm] reset -| (5,0));
        \node (reset2') at ([yshift=-0.3cm] reset -| (5,0));
        \node (initloop1) at (init1' -| (8.5, 0));
        \node (initloop2) at (loop2' -| (8.5, 0));
        \draw[snake=brace] (init1')  -- (init2')  node[midway, xshift=0.6cm] {Init};
        \draw[snake=brace] (step1')  -- (step2')  node[midway, xshift=0.6cm] {Step};
        \draw[snake=brace] (loop1')  -- (loop2')  node[midway, xshift=0.6cm] {Loop};
        \draw[snake=brace] (reset1') -- (reset2') node[midway, xshift=0.6cm] {Reset};
        \draw[snake=brace] (initloop1) -- (initloop2) node[midway, xshift=1cm] {Init+Loop};
      \end{tikzpicture}
    \end{onlyenv}
  \end{overlayarea}

\end{frame}


\begin{frame}[fragile,fragile]
  \frametitle{Multiplication: Step Machine}
  \footnotesize
  
  We assumue a machine $\MS{Add} \VDash \MS{Computes2}~add$.

  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}[escapechar=!]
if (m--) {
  Add(n, c, c')
  CopyValue(c', c)
  Reset(c')!\tikz\node [coordinate] (n1) {};!
  continue
} else {
  break
}
\end{lstlisting}

    \end{column}

    \begin{column}{0.6\textwidth}
      \begin{overlayarea}{\textwidth}{5cm}
        \begin{onlyenv}<2->

          \begin{tikzpicture}[overlay]
            \draw[->, snake] ([xshift=1.5cm] n1) -- +(2cm,0);
          \end{tikzpicture} 
          
          \begin{align*}
            & \MS{Mult\_Step} := \\
            & \quad\MS{If}~(\MS{Inject}~\MS{MatchNat}~\Vector{0}) \\
            & \quad\bigl(\MS{Return}( \bigr. \\
            & \quad\quad\quad \MS{Inject}~\MS{Add}~\Vector{1; 2; 3; 4}; \\
            & \quad\quad\quad \MS{Inject}~\MS{CopyValue}~\Vector{3;2}; \\
            & \quad\quad\quad \MS{Inject}~\MS{MoveToRight}~\Vector{3} \\
            & \quad\quad\bigl. )~(\true, \unit \bigr) \\
            & \quad\bigl(\MS{Nop}~(\false, \unit)\bigr)
          \end{align*}
        \end{onlyenv}
      \end{overlayarea}
    \end{column}
    
  \end{columns}

\begin{lstlisting}
t0: m' (t0 for MatchNat)
t1: n  (t0 for Add)
t2: c  (t1 for Add) (t1 for CopyValue)
t3: c' (t2 for Add) (t0 for CopyValue) (t0 for MoveToRight)
t4: ?  (t3 for Add)
\end{lstlisting}

\end{frame}

\begin{frame}
  \frametitle{Multiplication: Verification of $\MS{Mult\_Loop}$}
  \footnotesize

  \begin{columns}
    \tiny
    \begin{column}{0.5\textwidth}
      % \begin{align*}
      %   & \MS{Mult\_Step\_Rel} := \\
      %   &\quad \lam{t_{in}~(y, t_{out})} \forall (c~m'~n:\Nat), \\
      %   &\quad\quad t_{in}[0] \eqsim_{\{;0\}} m' \rightarrow \\
      %   &\quad\quad t{in}[1] \eqsim n \rightarrow \\
      %   &\quad\quad t{in}[2] \eqsim c \rightarrow \\
      %   &\quad\quad \MS{isRight}~t_{in}[3] \rightarrow \\
      %   &\quad\quad \MS{isRight}~t_{in}[4] \rightarrow \\
      %   &\quad\quad \MS{match}~m'~\MS{with} \\
      %   &\quad\quad |~O \Rightarrow t_{out} = t_{in} ~\land~ y=\false \\
      %   &\quad\quad |~S~m'' \Rightarrow \\
      %   &\quad\quad\quad t_{out}[0] \eqsim_{\{;0\}} m'' ~\land \\
      %   &\quad\quad\quad t_{out}[1] \eqsim n ~\land \\
      %   &\quad\quad\quad t_{out}[2] \eqsim n+c ~\land \\
      %   &\quad\quad\quad \MS{isRight}~t_{out}[3] ~\land \\
      %   &\quad\quad\quad \MS{isRight}~t_{out}[4] ~\land \\
      %   &\quad\quad\quad y = \true \\
      %   &\quad\quad \MS{end}
      % \end{align*}
      \begin{align*}
        & \MS{Mult\_Step\_Rel} := \\
        &\quad \lam{t_{in}~(y, t_{out})} \forall (c~m'~n:\Nat), \\
        &\quad\quad t_{in}[0] \eqsim_{\{;0\}} m' \rightarrow \\
        &\quad\quad t{in}[1] \eqsim n \rightarrow t{in}[2] \eqsim c \rightarrow \\
        &\quad\quad \MS{isRight}~t_{in}[3] \rightarrow \MS{isRight}~t_{in}[4] \rightarrow \\
        &\quad\quad \MS{match}~m'~\MS{with} \\
        &\quad\quad |~O \Rightarrow t_{out} = t_{in} ~\land~ y=\false \\
        &\quad\quad |~S~m'' \Rightarrow \\
        &\quad\quad\quad t_{out}[0] \eqsim_{\{;0\}} m'' ~\land \\
        &\quad\quad\quad t_{out}[1] \eqsim n ~\land~ t_{out}[2] \eqsim n+c ~\land \\
        &\quad\quad\quad \MS{isRight}~t_{out}[3] ~\land~ \MS{isRight}~t_{out}[4] ~\land~ y = \true \\
        &\quad\quad \MS{end}
      \end{align*}
    \end{column}

    \begin{column}{0.5\textwidth}
      \begin{align*}
        & \MS{Mult\_Loop\_Rel} := \\
        &\quad \lam{t_{in}~(\unit, t_{out})} \forall (c~m'~n:\Nat), \\
        &\quad\quad t_{in}[0] \eqsim_{\{;0\}} m' \rightarrow \\
        &\quad\quad t{in}[1] \eqsim n \rightarrow \\
        &\quad\quad t{in}[2] \eqsim c \rightarrow \\
        &\quad\quad \MS{isRight}~t_{in}[3] \rightarrow \\
        &\quad\quad \MS{isRight}~t_{in}[4] \rightarrow \\
        &\quad\quad t_{out}[0] \eqsim_{\{;0\}} 0 ~\land \\
        &\quad\quad t_{out}[1] \eqsim n ~\land \\
        &\quad\quad t_{out}[2] \eqsim m' \cdot n+c ~\land \\
        &\quad\quad \MS{isRight}~t_{out}[3] ~\land \\
        &\quad\quad \MS{isRight}~t_{out}[4]
      \end{align*}
    \end{column}

  \end{columns}

  \pause

  \textbf{Lemma:}
  $\MS{Mult\_Step} \VDash \MS{Mult\_Step\_Rel}$.

  \pause

  \textbf{Lemma:}
  $\MS{Mult\_Loop} := \MS{While}~\MS{Mult\_Step} \VDash \MS{Mult\_Loop\_Rel}$.
  

  \textbf{Proof:}
  It is enough to show $\MS{While\_Rel}~\MS{Add\_Step\_Rel} \subseteq \MS{Add\_Loop\_Rel}$,
  which can be shown using the induction scheme of $\MS{Add\_Step\_Rel}$.

  \begin{enumerate}
  \item Assume $\MS{Mult\_Step\_Rel}~t_{in}~(\true, t_{mid})$; show $\MS{Mult\_Step\_Rel}~t_{in}~(\unit, t_{out})$.
  \item Assume $\MS{Mult\_Loop\_Rel}~t_{in}~(\unit, t_{mid})$ and $\MS{Mult\_Step\_Rel}~t_{mid}~(\false, t_{out})$;
      show $\MS{Mult\_Loop\_Rel}~t_{in}~(\unit, t_{out})$.
  \end{enumerate}

\end{frame}

\begin{frame}
  \frametitle{Multiplication: Putting Machines Together}
  \[
  \]
  \begin{alignat*}{2}
    \MS{Mult\_Loop} :=~& \MS{While}~\MS{Mult\_Step} \\
    \MS{Mult\_Main} :=~& \MS{Inject}~\MS{CopyValue}~\Vector{0;5}; \\
                       & \MS{Inject}~(\MS{WriteValue~0})~\Vector{2}; \\
                       & \MS{Inject}~\MS{Mult\_Loop}~\Vector{5;1;2;3;4} \\
    \MS{Mult}       :=~& \MS{Mult\_Main}; \\
                       & \MS{Inject}~\MS{MoveToRight}~\Vector{5}
  \end{alignat*}

  %\textbf{Lemma:}
  \begin{lemma}[Correctness of Mult]
    $\MS{Mult} \VDash \MS{Computes2}~mult$. \end{lemma}
  
\end{frame}

\begin{frame}
  \frametitle{Possible Future Work}
  \begin{itemize}
  \item Implement UNIV
  \item Implement an interpreter for L
  \end{itemize}
\end{frame}

\end{document}