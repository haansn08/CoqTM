\documentclass{beamer} %
\usepackage[latin1]{inputenc}
\usepackage[absolute,overlay]{textpos}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{minted}

\usepackage{tikz}
\usetikzlibrary{arrows,shapes,snakes}

% \usetheme{CambridgeUS}
% \usefonttheme{professionalfonts}
\usecolortheme{orchid}


\include{mypreamble}

% Yannick's notational wishes
\renewcommand{\eqsim}{\simeq}
\renewcommand{\Tape}{\MS{T}}
\renewcommand{\VDash}{\vDash}
\renewcommand{\Vector}[1]{\left[{#1}\right]}

% \newcommand{\Lift}{\Uparrow}
\newcommand{\WhileRel}{\oplus}

%%
%% Important note:
%% Add [fragile] to each frame that uses listings!
%% AUCTeX does this automatically!
%%


%% Use these versions of the type names
\renewcommand{\Type}{\mathbb{T}}
\renewcommand{\Nat}{\mathbb{N}}
\renewcommand{\Bool}{\mathbb{B}}
\renewcommand{\Option}{\mathcal{O}}
\renewcommand{\List}{\mathcal{L}}
\newcommand{\Pow}{\mathcal{P}}

% Hide Controls
\beamertemplatenavigationsymbolsempty%
% \setbeamertemplate{footline}[page number]
%% Show only current page number
\setbeamertemplate{footline}{\raisebox{5pt}{\makebox[\paperwidth]{\hfill\makebox[20pt]{\scriptsize{\color{gray}\insertframenumber}}}}}

% Display a list of references at the bottom
\newcommand\refs[1]{%
  \begin{textblock*}{8cm}(0.3cm,9.0cm)%
    \scriptsize {\color{gray}#1}
  \end{textblock*}
}

\newcommand{\refs}[1]{%
  \begin{tikzpicture}[remember picture, overlay]
    \node[xshift=0.3cm,yshift=1cm] at (current page.south west)%
    [text]
      #1
  \end{tikzpicture}
}


\title{Formalising Multi-Tape Turing Machines In Coq}
\subtitle{Second Bachelor Seminar Talk}
\author{Maximilian Wuttke}
\institute{Saarland University\\
  \bigskip
  \tiny
  Programming Systems Lab
}
\date{March 20, 2018}



\begin{document}

\tikzstyle{every picture}+=[remember picture]



\begin{frame}
  \titlepage
  \bigskip{}
  \bigskip{}
  {
    \tiny
    Advisor: Yannick Forster\\
    Supervisor: Prof.\ Dr.\ Gert Smolka%
  }

  % \begin{tikzpicture}[remember picture,overlay]
  %   \node [xshift=1cm,yshift=1cm] at (current page.south west)
  %   {
  %     This is an absolutely positioned text in the lower left corner. No shipout-hackery is used.
  %   };
  % \end{tikzpicture}
\end{frame}

% \frame{\titlepage}



\begin{frame}
  \frametitle{Small Recap: Multi-Tape Turing Machines in Coq}

  \begin{itemize}
  \item Partitioned machines:
    $f : Q \to F$ for some finite $F$.
  \item Realisation: $M \VDash R$
  \item (Termination: $M \downarrow T$)
  \end{itemize}

  \refs{[Asperti and Ricciotti (2015)]} % use this to show references on a slide
\end{frame}

\begin{frame}{Realisation}

  \begin{definition}[Realisation, $M \VDash R$]
    Let $R \subseteq~\Tape^n \times F \times \Tape^n$.
    \begin{multline*}
      M \VDash R :=
      \forall t~t'~q~k.~
      M(t) \triangleright^k (q_{out}, t') \rightarrow
      R~t~\left(f(q_{out}), t' \right)
    \end{multline*}
  \end{definition}

  \begin{lemma}[Monoticity of $\VDash$]
    If $M \VDash R_1$ and $R_1 \subseteq R_2$, then $M \VDash R_2$.
  \end{lemma}

  \refs{[Asperti and Ricciotti (2015)]} % use this to show references on a slide
\end{frame}

\begin{frame}{Combinators for Parametrised Machines}
  Combinators for partitioned machines:
  
  \begin{itemize}
  % \item $\MS{Match}~M_1~(\lam {x:F_1} \cdots M_2 \cdots M_3 \cdots)$
  \item $\MS{If}~M_1~M_2~M_3$
  \item $M_1;~ M_2$
  \item $\MS{While}~M$
  \end{itemize}

  \pause

  \begin{lemma}[Correctness of $\MS{While}$]
    Let $R \subseteq \Tape^n \times (\Bool \times F) \times \Tape^n$.
    
    If $M \VDash R$, then $\MS{While}~M \VDash \WhileRel R$, where
    \[
      \WhileRel R :=
      \bigl(\bigcup_{a : F} {R\at{\true; a}}\bigr)^* \circ R\at{\false}.
    \]
  \end{lemma}

  \refs{[Asperti and Ricciotti (2015)]} % use this to show references on a slide
\end{frame}

\begin{frame}{Machine transformations}
  \textbf{Problem:}
  When combining machines, the numbers of tapes and the alphabet have to match!
  \pause%
  \bigskip

  \textbf{Solution:} Two operations on machines:
  \begin{itemize}
    \item $n$-Lift: add/rearrange tapes
    \item $\Sigma$-Lift: add/translate symbols
  \end{itemize}
\end{frame}


\begin{frame}{$n$-Lift}

  Let $i : \Fin_m \hookrightarrow \Fin_n$.
  
  Let $M$ be a $m$-tape machine.

  $\Uparrow_i M $ is a $n$-tape machine.
  % $M \Uparrow_i $ is a $n$-tape machine.
  
  Let $R \subseteq \Tape^m \times F \times \Tape^m$.
  \begin{alignat*}{2}
    & \Uparrow_i R  &   :=\;& \lam{t~(a, t')} R~(i^{-1}~t)~(a, i^{-1}~t') ~\land \\
    % & R \Uparrow_i  & \;:=\;& \lam{t~(a, t')} R~(i^{-1}~t)~(a, i^{-1}~t') ~\land \\
    &&&\quad \forall k \notin \MS{img}~i.~t[k] = t'[k]
  \end{alignat*}

  \begin{lemma}[Correctness of the $n$-Lift]
    If $M \VDash R$, then $\Uparrow_i M  \VDash\; \Uparrow_i R$.
    % If $M \VDash R$, then $M \Uparrow_i  \;\VDash R \Uparrow_i$.
  \end{lemma}

\end{frame}


\begin{frame}[fragile]{Encoding Values on Tapes}

  \begin{itemize}
  \item
    Type class for \emph{encodable} types $X$ and alphabets $\Sigma$:

    \footnotesize
    \begin{minted}{coq}
Class encodable (X : Type) (sig : finType) := {
  encode : X -> list sig;
}.
    \end{minted}
    % For example: $\mathtt{encode}~(b:\Bool) := [b]$ and $\mathtt{encode} (n:\Nat) := \true^n \false$.
    \pause

  % \item
  %   Insert start end end symbols into an encoding:
  %   $\Skigma^+ := \Bool + \Sigma$. \pause
    
  \item
    Define class of predicates for \emph{value-containing} of tapes:

    \begin{definition}[value-containing, $t \eqsim_{[r_1;r_2]} x$]
      % Hier möchte ich explizit angeben, dass $t$ ein $\Sigma^+$ tape ist.
      % Let $X$ be encodable over $\Sigma$, and $t: \Tape_{\Sigma^+}$.
      Let $X$ be encodable over $\Sigma$, and $t: \Tape_{\Bool+\Sigma}$.
      \[
        t \eqsim_{[r1;r2]} x :=
        \bigl(
        t = \midtape{r_1 ~ (\inl \true)}{(\inr y)}{(\map~\inr~ys) ~ (\inl \false) ~ r_2}
        \bigr)
      \]
      for $\mathtt{encode}(x) = y \cons ys$.
      % or:
      % \[
      %   t \eqsim_{[r1;r2]} x :=
      %   t = \midtape{(r_1 \app [\inl \true])}{\inl \false }{r_2}
      % \]
      % f
      % and $\MS{encode}(x) = \nil$ and
    \end{definition}

    { \footnotesize
      $t \eqsim x := \exists r_1~r_2.~t \eqsim_{[r_1;r_2]} x$ \\
      $t \eqsim_{\{;s\}} x := \exists r_1~r_2.~t\eqsim_{[r_1;r_2]} x \land |r_2| \le s$.
    }
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{A Relation for (Unary) Function Computation}

  Convention:
  \begin{itemize}
  \item Input tape(s): ``callee-safe''
  \item Output tape: is initially right; grows to left
  \item Internal tapes: right before and after execution
  \end{itemize}
  \pause
  { \footnotesize
    \begin{columns}
      \begin{column}{0.5\textwidth}
        Let $X, Y$ be encodable over $\Sigma$.
        \begin{alignat*}{2}
          & \MS{Computes}~(f:X \to Y) := \\
          & \quad \lam {t~(\_, t')} \forall (x:X). \\
          & \quad\quad t[0] \eqsim x \rightarrow \\
          & \quad\quad \MS{isRight}~t[1] \rightarrow \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t[2+i]) \rightarrow \\
          & \quad\quad t'[0] \eqsim x ~\land \\
          & \quad\quad t'[1] \eqsim_{\{;0\}} f~x ~\land \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t'[2+i])
        \end{alignat*}
      \end{column}
      \pause
      \begin{column}{0.5\textwidth}
        \begin{alignat*}{2}
          & \MS{Computes2}~(f:X \to Y \to Z) := \\
          & \quad \lam {t~(\_, t')} \forall (x:X)~(y:Y). \\
          & \quad\quad t[0] \eqsim x \rightarrow \\
          & \quad\quad t[1] \eqsim y \rightarrow \\
          & \quad\quad \MS{isRight}~t[2] \rightarrow \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t[3+i]) \rightarrow \\
          & \quad\quad t'[0] \eqsim x ~\land \\
          & \quad\quad t'[1] \eqsim y ~\land \\
          & \quad\quad t'[1] \eqsim_{\{;0\}} f~x~y ~\land \\
          & \quad\quad (\forall i : \Fin_n.~\MS{isRight}~t'[3+i])
        \end{alignat*}
      \end{column}
    \end{columns}
  }
\end{frame}


\begin{frame}{Value-Manipulating Machines}
  \begin{itemize}
  \item Match/destruct
  \item Constructor
  \item $\MS{CopyValue}$
  \item $\MS{MoveRight}$
  \end{itemize}
\end{frame}


\begin{frame}[fragile] \frametitle{Match $\Nat$}
  \footnotesize

  \begin{columns}
    \begin{column}{0.5\textwidth}
      
\begin{lstlisting}[language=c, escapechar=!]
if (n--) {
  // ...
} else {
  // ...
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
      \tikz\node [coordinate] (n1) {};
      $\MS{If}~(\Uparrow_{\Vector{i}} \MS{MatchNat})~M_1~M_2$
      
      (Where $n$ is stored on tape $i$)
    \end{column}
    \begin{tikzpicture}[overlay]
      \draw[->, snake] ([xshift=-3cm,yshift=0.05cm] n1) -- +(2cm,0);
    \end{tikzpicture} 
  \end{columns}


  \pause
  \begin{align*}
    & \MS{Match\_Nat\_Rel} := \\
    & \quad \lam {t~(a, t')} \forall (n:\Nat) \uncover<2->{(s:\Nat)}, \\
    & \quad\quad t[0] \eqsim_{\uncover<2->{\{;s\}}} n \rightarrow \\
    & \quad\quad \MS{match}~n~\MS{with} \\
    & \quad\quad |~0 \Rightarrow t' = t ~\land~ a = \false \\
    & \quad\quad |~S~n' \Rightarrow t'[0]  \eqsim_{\uncover<2->{\{;s\}}} n' ~\land~ a = \true \\
    & \quad\quad \MS{end}
  \end{align*}

\end{frame}

\begin{frame}
  \frametitle{General Design of A Turing Machine}
  \begin{enumerate}
  \item Write the program in pseudo code
  \item Partition the program into smaller programs
  \item For each partition: map variables to tapes
  \item For each partition: write a machine using value-manipulating machines and combinators
  \item Compose machines
  \item For each machine: define a correctness relation and proof correctness
  \item For each machine: define a termination relation and proof termination
  \end{enumerate}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Case Study: Designing A Multiplication Machine}

  \begin{overlayarea}{\textwidth}{\textheight}

    \begin{onlyenv}<1>
\begin{lstlisting}
c := 0
while (m--) {
  c += n
}
return c
\end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<2>
\begin{lstlisting}
m' := m
c := 0
while (m'--) {
  Add(n, c, c')
  CopyValue(c', c)
  Reset(c')
}
Reset(m')
return c
\end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<3->
\begin{lstlisting}[escapechar=!]
m' := m !\tikz\node [coordinate] (init1) {};!
c := 0 !\tikz\node [coordinate] (init2) {};!
while (true) { !\tikz\node [coordinate] (loop1) {};!
  if (m'--) { !\tikz\node [coordinate] (step1) {};!
    Add(n, c, c')
    CopyValue(c', c)
    Reset(c')
    continue
  } else {
    break
  } !\tikz\node [coordinate] (step2) {};!
} !\tikz\node [coordinate] (loop2) {};!
Reset(m') !\tikz\node [coordinate] (reset) {};!
return c
\end{lstlisting}
    \end{onlyenv}

    \begin{onlyenv}<4->
      \begin{tikzpicture}[overlay]
        \node (init1') at ([yshift=+0.2cm] init1 -| (5,0));
        \node (init2') at ([yshift=-0.2cm] init2 -| (5,0));
        \node (loop1') at ([yshift=+0.2cm] loop1 -| (7,0));
        \node (loop2') at ([yshift=-0.2cm] loop2 -| (7,0));
        \node (step1') at ([yshift=+0.2cm] step1 -| (5,0));
        \node (step2') at ([yshift=-0.2cm] step2 -| (5,0));
        \node (reset1') at ([yshift=+0.3cm] reset -| (5,0));
        \node (reset2') at ([yshift=-0.3cm] reset -| (5,0));
        \node (initloop1) at (init1' -| (8.5, 0));
        \node (initloop2) at (loop2' -| (8.5, 0));
        \draw[snake=brace] (init1')  -- (init2')  node[midway, xshift=0.6cm] {Init};
        \draw[snake=brace] (step1')  -- (step2')  node[midway, xshift=0.6cm] {Step};
        \draw[snake=brace] (loop1')  -- (loop2')  node[midway, xshift=0.6cm] {Loop};
        \draw[snake=brace] (reset1') -- (reset2') node[midway, xshift=0.6cm] {Reset};
        \draw[snake=brace] (initloop1) -- (initloop2) node[midway, xshift=1cm] {Init+Loop};
      \end{tikzpicture}
    \end{onlyenv}
  \end{overlayarea}

\end{frame}


\begin{frame}[fragile,fragile]
  \frametitle{Multiplication: Step Machine}
  \footnotesize
  
  We assume a machine $\MS{Add} \VDash \MS{Computes2}~add$.

  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}[escapechar=!]
if (m'--) {
  Add(n, c, c')
  CopyValue(c', c)
  Reset(c')!\tikz\node [coordinate] (n1) {};!
  continue
} else {
  break
}
\end{lstlisting}

    \end{column}

    \begin{column}{0.6\textwidth}
      \begin{overlayarea}{\textwidth}{5cm}
        \begin{onlyenv}<2->

          \begin{tikzpicture}[overlay]
            \draw[->, snake] ([xshift=1.5cm] n1) -- +(2cm,0);
          \end{tikzpicture} 
          
          \begin{align*}
            & \MS{Mult\_Step} := \\
            & \quad\MS{If}~\Uparrow_{\Vector{0}} \MS{MatchNat}) \\
            & \quad\bigl(\MS{Return}( \bigr. \\
            & \quad\quad \Uparrow_{\Vector{1; 2; 3; 4}}\MS{Add}; \\
            & \quad\quad \Uparrow_{\Vector{3;2}} \MS{CopyValue}; \\
            & \quad\quad \Uparrow_{\Vector{3}} \MS{MoveToRight} \\
            & \quad\quad\bigl. )~(\true, \unit \bigr) \\
            & \quad\bigl(\MS{Nop}~(\false, \unit)\bigr)
          \end{align*}
        \end{onlyenv}
      \end{overlayarea}
    \end{column}
    
  \end{columns}

\begin{lstlisting}
t0: m' (t0 for MatchNat)
t1: n  (t0 for Add)
t2: c  (t1 for Add) (t1 for CopyValue)
t3: c' (t2 for Add) (t0 for CopyValue) (t0 for MoveToRight)
t4: ?  (t3 for Add)
\end{lstlisting}

\end{frame}

\begin{frame}
  \frametitle{Multiplication: Verification of $\MS{Mult\_Loop}$}
  \footnotesize

  \begin{columns}
    \tiny
    \begin{column}{0.5\textwidth}
      % \begin{align*}
      %   & \MS{Mult\_Step\_Rel} := \\
      %   &\quad \lam{t~(a, t')} \forall (c~m'~n:\Nat). \\
      %   &\quad\quad t[0] \eqsim_{\{;0\}} m' \rightarrow \\
      %   &\quad\quad t[1] \eqsim n \rightarrow \\
      %   &\quad\quad t[2] \eqsim c \rightarrow \\
      %   &\quad\quad \MS{isRight}~t[3] \rightarrow \\
      %   &\quad\quad \MS{isRight}~t[4] \rightarrow \\
      %   &\quad\quad \MS{match}~m'~\MS{with} \\
      %   &\quad\quad |~O \Rightarrow t' = t ~\land~ y=\false \\
      %   &\quad\quad |~S~m'' \Rightarrow \\
      %   &\quad\quad\quad t'[0] \eqsim_{\{;0\}} m'' ~\land \\
      %   &\quad\quad\quad t'[1] \eqsim n ~\land \\
      %   &\quad\quad\quad t'[2] \eqsim n+c ~\land \\
      %   &\quad\quad\quad \MS{isRight}~t'[3] ~\land \\
      %   &\quad\quad\quad \MS{isRight}~t'[4] ~\land \\
      %   &\quad\quad\quad a = \true \\
      %   &\quad\quad \MS{end}
      % \end{align*}
      \begin{align*}
        & \MS{Mult\_Step\_Rel} := \\
        &\quad \lam{t~(a, t')} \forall (c~m'~n:\Nat). \\
        &\quad\quad t[0] \eqsim_{\{;0\}} m' \rightarrow \\
        &\quad\quad t[1] \eqsim n \rightarrow t[2] \eqsim c \rightarrow \\
        &\quad\quad \MS{isRight}~t[3] \rightarrow \MS{isRight}~t[4] \rightarrow \\
        &\quad\quad \MS{match}~m'~\MS{with} \\
        &\quad\quad |~O \Rightarrow t' = t ~\land~ a = (\false,\ \unit) \\
        &\quad\quad |~S~m'' \Rightarrow \\
        &\quad\quad\quad t'[0] \eqsim_{\{;0\}} m'' ~\land \\
        &\quad\quad\quad t'[1] \eqsim n ~\land~ t'[2] \eqsim n+c ~\land \\
        &\quad\quad\quad \MS{isRight}~t'[3] ~\land~ \MS{isRight}~t'[4] ~\land~ a = (\true, \unit) \\
        &\quad\quad \MS{end}
      \end{align*}
    \end{column}

    \begin{column}{0.5\textwidth}
      \begin{align*}
        & \MS{Mult\_Loop\_Rel} := \\
        &\quad \lam{t~(\unit, t')} \forall (c~m'~n:\Nat). \\
        &\quad\quad t[0] \eqsim_{\{;0\}} m' \rightarrow \\
        &\quad\quad t[1] \eqsim n \rightarrow \\
        &\quad\quad t[2] \eqsim c \rightarrow \\
        &\quad\quad \MS{isRight}~t[3] \rightarrow \\
        &\quad\quad \MS{isRight}~t[4] \rightarrow \\
        &\quad\quad t'[0] \eqsim_{\{;0\}} 0 ~\land \\
        &\quad\quad t'[1] \eqsim n ~\land \\
        &\quad\quad t'[2] \eqsim m' \cdot n+c ~\land \\
        &\quad\quad \MS{isRight}~t'[3] ~\land \\
        &\quad\quad \MS{isRight}~t'[4]
      \end{align*}
    \end{column}

  \end{columns}

  \pause

  \textbf{Lemma 1:}
  $\MS{Mult\_Step} \VDash \MS{Mult\_Step\_Rel}$.

  \pause

  \textbf{Lemma 2:}
  $\MS{Mult\_Loop} := \MS{While}~\MS{Mult\_Step} \VDash \MS{Mult\_Loop\_Rel}$.
  

  \textbf{Proof:}
  It is enough to show $\WhileRel~\MS{Mult\_Step\_Rel} \subseteq \MS{Mult\_Loop\_Rel}$,
  which can be shown using the induction scheme of $\WhileRel$.

  \tiny
  \begin{enumerate}
  \item Assume $\MS{Mult\_Step\_Rel}~t~((\false, \unit), t')$; show $\MS{Mult\_Loop\_Rel}~t~(\unit, t')$.
  \item Assume $\MS{Mult\_Step\_Rel}~t~((\true, \unit), t')$ and $\MS{Mult\_Loop\_Rel}~t'~(\unit, t'')$;
    show $\MS{Mult\_Loop\_Rel}~t~(\unit, t'')$.
  \end{enumerate}

\end{frame}

\begin{frame}
  \frametitle{Multiplication: Putting Machines Together}

  \begin{alignat*}{2}
    \MS{Mult\_Loop} :=~& \MS{While}~\MS{Mult\_Step} \\
    \MS{Mult\_Main} :=~& \MS{Inject}~\MS{CopyValue}~\Vector{0;5}; \\
                       & \MS{Inject}~(\MS{WriteValue~0})~\Vector{2}; \\
                       & \MS{Inject}~\MS{Mult\_Loop}~\Vector{5;1;2;3;4} \\
    \MS{Mult}       :=~& \MS{Mult\_Main}; \\
                       & \MS{Inject}~\MS{MoveToRight}~\Vector{5}
  \end{alignat*}

  %\textbf{Lemma:}
  \begin{lemma}[Correctness of Mult]
    $\MS{Mult} \VDash \MS{Computes2}~mult$.
  \end{lemma}
  
\end{frame}

\begin{frame}
  \frametitle{Possible Future Work}
  \begin{itemize}
  \item Implement UNIV
  \item Implement an interpreter for L
  \end{itemize}
\end{frame}




%%
%% Backup-Slides
%%

\begin{frame}
  \center
  Thank you!
\end{frame}

\begin{frame}
  \frametitle{Related Work}
  \footnotesize
  \begin{thebibliography}{10}
    \beamertemplatearticlebibitems%
    \bibitem{}
    Xu, Jian and Zhang, Xingyuan and Urban, Christian
    \newblock{\em Mechanising Turing Machines and Computability Theory in Isabelle/HOL}%
    \newblock{ITP 2013}
    \bibitem{}
    Andrea Asperti and Wilmer Ricciotti
    \newblock{\em A formalization of multi-tape Turing machines}%
    \newblock{Theoretical Computer Science, 2015}
    \bibitem{}
    Alberto Ciaffaglione
    \newblock{\em Towards Turing computability via coinduction}%
    \newblock{Science of Computer Programming, 2016}
  \end{thebibliography}
\end{frame}



\begin{frame}
  \frametitle{Termination}

  \begin{definition}[Termination, $M \downarrow T$]
    Let $T \subseteq \Tape^n \times \Nat$.
    \[
      \mathbf{M \downarrow T} :=
      \forall t~k.~ T~t~k \rightarrow
      \exists c_{out},~M(t) \triangleright^k c_{out}
    \]
  \end{definition}

  \begin{lemma}[Monoticity of $\downarrow$]
    If $M \downarrow T_1$ and $T_2 \subseteq T_1$, then $M \downarrow T_2$.
  \end{lemma}

\end{frame}

\begin{frame}{$\Sigma$-Lift}
  Let $i \from \Sigma \hookrightarrow \Tau$ be an injection.

  Let $\mathbf{default} : \Sigma^n$.

  Let $M$ be an $n$-tape $F$-partitioned Turing machine parametrised over $\Sigma$,
  and $R$ be a $F$-parametrised relation.

  Define an $n$-tape Turing machine $\Uparrow_{i,\MS{default}} M$ and a relation $\MS{Lift}_{i,\MS{default}}~R$.
  \begin{align*}
    \Uparrow_{i; \MS{default}} R := \lam{t~(a, t')} R~(i^{-1}_{\MS{default}} t)~(a, i^{-1}_{\MS{default}} t')
  \end{align*}

  \begin{lemma}[Correctness of the $\Sigma$-Lift]
    If $M \VDash R$, then
    $\Uparrow_{i; \MS{default}} M \VDash\; \Uparrow_{i; \MS{default}} R$.
  \end{lemma}
\end{frame}



\end{document}